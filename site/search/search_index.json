{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs \u00b6 For full documentation visit mkdocs.org . Commands \u00b6 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout \u00b6 1 2 3 4 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"1 2 3 4 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"DSAyy/arrays/","text":"Array Simulation \u00b6 Spiral Order Matrix \u00b6 Question kya hai \u00b6 Matrix A: Size M x N, return all elements in the spiral order. (clockwise starting from top-left) $$ \\begin{bmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 9 \\end{bmatrix} $$ the output would be \\(1,2,3,6,9,8,7,4,5\\) How to do this \u00b6 Take 4 pointers and continuously run for loops on that bitch. Bas run top first, then right, then down, then left vector < int > spiralOrder ( vector < vector < int >> & A ){ int M = A . size (), N = A [ 0 ]. size (); int u = 0 , d = M -1 , l = 0 , r = N -1 ; vector < int > spiral ; while ( l <= r && u <= d ){ for ( int i = l ; i <= r ; ++ i ) spiral . push_back ( A [ u ][ i ]); ++ u ; for ( int i = u ; i <= d ; ++ i ) spiral . push_back ( A [ i ][ r ]); -- r ; if ( u <= d ){ for ( int i = r ; i >= l ; -- i ) spiral . push_back ( A [ d ][ i ]); -- d ; } if ( l <= r ){ for ( int i = d ; i >= u ; -- i ) spiral . push_back ( A [ i ][ l ]); ++ l ; } } return spiral ; } Iski time complexity is \\(O(n \\times m)\\) Space complexity bhi same Large Factorial \u00b6 Question \u00b6 Given integer A, compute A ! as a string, coz kuch zyaada hi bada number hai. Kaise karna hai ye \u00b6 Dekh bro as a string return karna hai answer toh legit make a multiply function for strings and karle solve. Kya hi dumb shit hai ye. Just know ki digits would be reversed for the convenience of the carry shit. Toh reverse pointer se string meh add kariyo. string factorial ( int A ){ vector < int > digits { 1 }; // har factorial meh 1 toh hota hi hai auto multiply = [ & ]( int i ) { int carry = 0 ; for ( int & d : digits ){ long long prod = ( long long ) d * i + carry ; d = prod % 10 ; // same time digit update kar diya carry = prod / 10 ; } while ( carry ){ digits . push_back ( carry % 10 ); carry /= 10 ; } }; for ( int i = 2 ; i <= A ; ++ i ) // multiply sabkuch from 2 to A { multiply ( i ); // multiple every number into 2 } string s ; // put all the digits into a string for ( auto it = digits . rbegin (); it != digits . rend (); ++ it ){ s . push_back ( '0' + * it ); } return s ; } Max Non-Negative Subarray \u00b6 Question kya hai \u00b6 Array A of N integers, find the subarray with max sum. agar tied, choose the longer one. still tied? smallest starting index Sunn BEHENCHOD, Subarray means continuous, sab kuch subsequence nahi hota Karna kaise hai \u00b6 kadane kadane khelenge agar negative number mila, that is where we stop and process the answer. By process i mean, bas compare karke check karlenge if its max End meh bhi ek baar check kar lena coz when the loop ends, ek baar remaining computation bhi toh update karni hai. vector < int > maxSet ( vector < int > & A ){ int n = A . size (); long long bestSum = -1 , curSum = 0 ; int bestStart = 0 , bestEnd = -1 , bestLen = 0 ; int curStart = 0 ; for ( int i = 0 ; i < n ; ++ i ){ if ( A [ i ] >= 0 ) curSum += A [ i ]; else { int curLen = i - curStart ; if ( curSum > bestSum || ( curSum == bestSum && curLen > bestLen )){ bestSum = curSum ; bestStart = curStart ; bestEnd = i - 1 ; bestLen = curLen ; } curSum = 0 ; curStart = i + 1 ; } } if ( curStart < n ){ int curLen = n - curStart ; if ( curSum > bestSum || ( curSum == bestSum && curLen > bestLen )){ bestSum = curSum ; bestStart = curStart ; bestEnd = n - 1 ; bestLen = curLen ; } } if ( bestEnd < bestStart ) return {}; return vector < int > ( A . begin () + bestStart , A . begin () + bestEnd + 1 ); } Time complexity is O(n), space complexity is O(1) Pick from Both Sides \u00b6 Array A of N elements. Pick exactly B elements from either left ya right end, and just get the max sum. Karna kaise hai \u00b6 Imagine kar ek sexy sa sliding window, but instead on inside the array, ye saala bahar se aa raha hai. like the right pointer is left meh and left wala is right meh. ye leke bas max sum with B elements karle. Start the right pointer at B - i, and keep the left wala at n - i, and baaju baaju shift and update karte ja. Keep a sum of first B elements, and fir middle se ek hata and right end wala ek daal. int pickBothSides ( vector < int > & A , int B ){ int n = A . size (); int window = accumulate ( A . begin (), A . begin () + B , 0 ); int ans = window ; for ( int i = 1 ; i <= B ; ++ i ){ window = window - A [ B - i ] + A [ n - i ]; ans = max ( ans , window ); } return ans ; } Time complexity is O(n) and space complexity is O(1)","title":"Arrays"},{"location":"DSAyy/arrays/#array-simulation","text":"","title":"Array Simulation"},{"location":"DSAyy/arrays/#spiral-order-matrix","text":"","title":"Spiral Order Matrix"},{"location":"DSAyy/arrays/#question-kya-hai","text":"Matrix A: Size M x N, return all elements in the spiral order. (clockwise starting from top-left) $$ \\begin{bmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 9 \\end{bmatrix} $$ the output would be \\(1,2,3,6,9,8,7,4,5\\)","title":"Question kya hai"},{"location":"DSAyy/arrays/#how-to-do-this","text":"Take 4 pointers and continuously run for loops on that bitch. Bas run top first, then right, then down, then left vector < int > spiralOrder ( vector < vector < int >> & A ){ int M = A . size (), N = A [ 0 ]. size (); int u = 0 , d = M -1 , l = 0 , r = N -1 ; vector < int > spiral ; while ( l <= r && u <= d ){ for ( int i = l ; i <= r ; ++ i ) spiral . push_back ( A [ u ][ i ]); ++ u ; for ( int i = u ; i <= d ; ++ i ) spiral . push_back ( A [ i ][ r ]); -- r ; if ( u <= d ){ for ( int i = r ; i >= l ; -- i ) spiral . push_back ( A [ d ][ i ]); -- d ; } if ( l <= r ){ for ( int i = d ; i >= u ; -- i ) spiral . push_back ( A [ i ][ l ]); ++ l ; } } return spiral ; } Iski time complexity is \\(O(n \\times m)\\) Space complexity bhi same","title":"How to do this"},{"location":"DSAyy/arrays/#large-factorial","text":"","title":"Large Factorial"},{"location":"DSAyy/arrays/#question","text":"Given integer A, compute A ! as a string, coz kuch zyaada hi bada number hai.","title":"Question"},{"location":"DSAyy/arrays/#kaise-karna-hai-ye","text":"Dekh bro as a string return karna hai answer toh legit make a multiply function for strings and karle solve. Kya hi dumb shit hai ye. Just know ki digits would be reversed for the convenience of the carry shit. Toh reverse pointer se string meh add kariyo. string factorial ( int A ){ vector < int > digits { 1 }; // har factorial meh 1 toh hota hi hai auto multiply = [ & ]( int i ) { int carry = 0 ; for ( int & d : digits ){ long long prod = ( long long ) d * i + carry ; d = prod % 10 ; // same time digit update kar diya carry = prod / 10 ; } while ( carry ){ digits . push_back ( carry % 10 ); carry /= 10 ; } }; for ( int i = 2 ; i <= A ; ++ i ) // multiply sabkuch from 2 to A { multiply ( i ); // multiple every number into 2 } string s ; // put all the digits into a string for ( auto it = digits . rbegin (); it != digits . rend (); ++ it ){ s . push_back ( '0' + * it ); } return s ; }","title":"Kaise karna hai ye"},{"location":"DSAyy/arrays/#max-non-negative-subarray","text":"","title":"Max Non-Negative Subarray"},{"location":"DSAyy/arrays/#question-kya-hai_1","text":"Array A of N integers, find the subarray with max sum. agar tied, choose the longer one. still tied? smallest starting index Sunn BEHENCHOD, Subarray means continuous, sab kuch subsequence nahi hota","title":"Question kya hai"},{"location":"DSAyy/arrays/#karna-kaise-hai","text":"kadane kadane khelenge agar negative number mila, that is where we stop and process the answer. By process i mean, bas compare karke check karlenge if its max End meh bhi ek baar check kar lena coz when the loop ends, ek baar remaining computation bhi toh update karni hai. vector < int > maxSet ( vector < int > & A ){ int n = A . size (); long long bestSum = -1 , curSum = 0 ; int bestStart = 0 , bestEnd = -1 , bestLen = 0 ; int curStart = 0 ; for ( int i = 0 ; i < n ; ++ i ){ if ( A [ i ] >= 0 ) curSum += A [ i ]; else { int curLen = i - curStart ; if ( curSum > bestSum || ( curSum == bestSum && curLen > bestLen )){ bestSum = curSum ; bestStart = curStart ; bestEnd = i - 1 ; bestLen = curLen ; } curSum = 0 ; curStart = i + 1 ; } } if ( curStart < n ){ int curLen = n - curStart ; if ( curSum > bestSum || ( curSum == bestSum && curLen > bestLen )){ bestSum = curSum ; bestStart = curStart ; bestEnd = n - 1 ; bestLen = curLen ; } } if ( bestEnd < bestStart ) return {}; return vector < int > ( A . begin () + bestStart , A . begin () + bestEnd + 1 ); } Time complexity is O(n), space complexity is O(1)","title":"Karna kaise hai"},{"location":"DSAyy/arrays/#pick-from-both-sides","text":"Array A of N elements. Pick exactly B elements from either left ya right end, and just get the max sum.","title":"Pick from Both Sides"},{"location":"DSAyy/arrays/#karna-kaise-hai_1","text":"Imagine kar ek sexy sa sliding window, but instead on inside the array, ye saala bahar se aa raha hai. like the right pointer is left meh and left wala is right meh. ye leke bas max sum with B elements karle. Start the right pointer at B - i, and keep the left wala at n - i, and baaju baaju shift and update karte ja. Keep a sum of first B elements, and fir middle se ek hata and right end wala ek daal. int pickBothSides ( vector < int > & A , int B ){ int n = A . size (); int window = accumulate ( A . begin (), A . begin () + B , 0 ); int ans = window ; for ( int i = 1 ; i <= B ; ++ i ){ window = window - A [ B - i ] + A [ n - i ]; ans = max ( ans , window ); } return ans ; } Time complexity is O(n) and space complexity is O(1)","title":"Karna kaise hai"},{"location":"DSAyy/dp/","text":"Longest Common Subsequence \u00b6 Question Statement \u00b6 Given 2 strings, find the length of uska longest common subsequence. Note subsequence does not have to be continuous. Example: A = \\(abbcdgf\\) and B = \\(bbadcgf\\) toh the output would be 5 (bbcgf is the lcs) Kaise karna hai \u00b6 Thode subproblems meh divide karte hai isse. Let \\(\\text{LCS[i][j] be LCS of substrings A[0...i] and B[0....j]}\\) . Toh the obvious relation we can find is if \\(\\text{A[i-1] == B[j-1] fir LCS[i][j] is just LCS[i-1][j-1] + 1}\\) which means ki humme ek element same mil gaya, toh length would be 1 + the substrings removing those used indexes dono strings se. else \\(\\text{take max of LCS[i-1][j] and LCS[i][j-1]}\\) coz wahi dono possibilities are left. which means dono string se ek element skip karke check karlo Humhe continuity bhi maintain karni hai. Thats it literally. int LCS ( string A , string B ){ int n = A . size (), m = B . size (); vector < vector < int >> lcs ( n + 1 , vector < int > ( m + 1 , 0 )); for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 1 ; j <= m ; ++ j ){ if ( A [ i -1 ] == B [ j -1 ]) lcs [ i ][ j ] = 1 + lcs [ i -1 ][ j -1 ]; else lcs [ i ][ j ] = max ( lcs [ i -1 ][ j ], lcs [ i ][ j -1 ]); } return lcs [ n ][ m ]; } Time complexity \\(O(n \\times m)\\) and and same with space Now the sexy part is hum isse aur optimize kar sakte hai Abhi let \\(\\text{prev}\\) be the results of the i-1 row, and \\(curr\\) be the result of the current row i \\(\\text{LCS[i-1][j-1] = previous row ka j-1}\\) \\(\\text{LCS[i-1][j] = previous row ka j}\\) \\(\\text{LCS[i][j-1] = cur row ka j-1}\\) int LCS ( string A , string B ){ int n = A . size (), m = B . size (); if ( m > n ){ // keeping the rows as the bigger one, since lcs ka upper limit toh chotta wala hi hoga swap ( A , B ); swap ( m , n ); } vector < int > prev ( m + 1 , 0 ), cur ( m + 1 , 0 ); for ( int row = 1 ; row <= n ; ++ row ){ for ( int j = 1 ; j <= m ; ++ j ){ if ( A [ i -1 ] == B [ j -1 ]) cur [ j ] = prev [ j -1 ] + 1 ; // we found a similar el, toh prev row ke result se ek zyada hoga else cur [ j ] = max ( prev [ j ], cur [ j -1 ]); } swap ( prev , cur ) } return prev [ M ] } Isme the space complexity changed from \\(O(n\\times m)\\) se \\(O(min(n,m))\\) Longest Palindromic Subsequence \u00b6 Question Statement \u00b6 Given a string A, find length of the longest palindromic subsequence. Example: \\(A = beebeeed\\) the output would be 4 coz LPS is \\(eeee\\) Karna kaise hai \u00b6 Abe chutiye, Longest palindromic substring is just the LCS of A and reversed(A) I am not even gonna waste my time fuck off. $$ LPS(A) = LCS(A, reverse(A)) $$ Edit Distance \u00b6 Problem Statement \u00b6 Given 2 strings, find min steps required to convert A to B given in one step we can - Insert a char - Delete a char - Replace a char Example: - A = abad, B = abac. The output is 1 coz sirf c ko d se replace karna Kaise karna \u00b6 Let \\(edit[i][j]\\) be the minimum dist to convert \\(A[0...i-1] \\space and \\space B[0...j-1]\\) Toh iska rishta is $$ edit[i][j] = edit[i-1][j-1] \\space \\text{if A[i-1] and B[j-1] same hai} $$ $$ \\text{else if its different, edit[i][j] is gonna be 1 + min(edit[i-1][j], edit[i-1][j-1], edit[i-1][j-1])} $$ \\(edit[i-1][j]\\) means hum \\(A[i-1]\\) delete kar rahe hai same with \\(edit[i][j-1]\\) meaning \\(B[j-1]\\) delete \\(edit[i-1][j-1]\\) matlab bro humne dono ko replace kar diya ek dusre se and both are updated Base Cases \u00b6 Kuch baate sacch hoti hai Jaise, \\(edit[0][j] = j\\) -> means \\(B[0..j]\\) ko empty karne ke liye j operations are needed. Similarly. \\(edit[i][0] = i\\) Bas bhai ab chalao for loop, sabke level nikalenge. int editDistance ( string A , string B ){ int n = A . size (), B = B . size (); vector < vector < int >> edit ( n + 1 , vector < int > ( m + 1 , 0 )); // sach baate for ( int i = 1 ; i <= n ; ++ i ) edit [ i ][ 0 ] = i ; for ( int j = 1 ; j <= m ; ++ j ) edit [ 0 ][ j ] = j ; for ( int i = 1 ; i <= n ; ++ i ){ for ( int j = 1 ; j <= m ; ++ j ){ if ( A [ i -1 ] == B [ j -1 ]) edit [ i ][ j ] = edit [ i -1 ][ j -1 ]; // no extra edits needed else { edit [ i ][ j ] = 1 + min ({ edit [ i -1 ][ j ], edit [ i ][ j -1 ], edit [ i -1 ][ j -1 ] }); } } } return dp [ n ][ m ]; } Time and Space dono in this are \\(O(n\\times m)\\) Repeating Subsequence \u00b6 Problem kya yap kar raha \u00b6 String A, check kar if its longest repeating subsequence is \\(\\geq\\) 2. Repeating subsequence is basically repeating subsequence. Example: A = \\(abab\\) , Output is 1 (subseq \\(ab\\) repeats) How to solve? \u00b6 $$ \\text{Repeating subsequence (A) is LCS(A,A) but i } \\neq j $$ Aur kuch bhi nahi. bas $$ \\text{return dp[n][n] } \\geq 2 $$ Distinct Subsequences \u00b6 Problem Statement \u00b6 Given 2 sequences A and B, count ways to form B as a subseq of A. Example: - A = rabbbit, B = rabbit, Output 3 - Basically all 3 b can be removed. Karu kaise? \u00b6 Let \\(ways[j]\\) be ways to form \\(B[0...j]\\) as a subseq of first i elements of A. Isse 1D meh fit kar sakte if we update j from right to left, toh \\(ways[j-1]\\) hoga from previous i Toh the rishta would be $$ ways[j] = ways[j] + ways[j-1] \\text{ if A[i-1] == B[j-1]} $$ warna \\(ways[j]\\) would remain 0, coz agar element hi same nai toh string kaise banega with those indexes. Note ki \\(ways[j-1]\\) humare previous i ke iteration se hoga, so we have already computed pehle ka. int distSubseq ( string A , string B ){ int n = A . size (), m = B . size (); vector < long long > ways ( m + 1 , 0 ); ways [ 0 ] = 1 ; //empty banane ke liye kya hi chahiye for ( int i = 1 ; i <= n ; ++ i ){ for ( int j = m ; j >= 1 ; -- j ){ if ( A [ i -1 ] == B [ j -1 ]){ ways [ j ] += ways [ j -1 ]; } } } return ( int ) ways [ m ]; } Scramble String \u00b6 What does the dog say? \u00b6 Given 2 strings, bata if the other string can be made by scrambling A. Now what the fuck is scrambling? B is scramble(A) if -> A can be represented as a binary tree by recursively partitioninng into two non-substrings, and by swapping left and right children any number of times, we can get B. What the helly? Input: A= we and B = we Ans = 1. Bhai mar jau meh? \u00b6 Iske liye we use 3D dp. Whether A[i...i+len - 1] can be scrambled into B[j....j+len - 1] Let scramble[i][j][len] be true if A.substr(i,len) can be scrambled into B.substr(j,len Hard Truth \u00b6 Bhai pata nahi yaar ye scrambling shit kya hai Base Case : For length 1, scramble[i][j][1] = (A[i] == B[j]) Like bhai ek hi toh length hai, same string hi hogaya ye toh For each length \\(l\\) from 2 to n, for all A.substr(i,l) and B.substr(j,l) har ek split k try kar le - No swap: scramble[i][j][l] is true if \\(scramble[i][j][k] \\space \\& \\space scramble[i][j][l-k]\\) meaning dono continuous partitions valid hai. - Swap: scramble[i][j][l] is true if scramble[i][j+l-k][k] and scramble[i+k][j][l-k] dono true hai Also quick check: If dono sorted are different, tab toh they cant scramble. bool isScramble ( string A , string B ){ int n = A . size (); if ( n != B . length ()) return 0 ; //quick sorted check { array < int , 256 > freq = { 0 }; for ( char c : A ) freq [( unsigned char ) c ] ++ ; for ( char c : B ) freq [( unsigned char ) c ] -- ; for ( int x : freq ) if ( x != 0 ) return 0 ; } static bool scramble [ 51 ][ 51 ][ 51 ]; memset ( dp , false , sizeof ( scramble )); // base case for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) scramlbe [ i ][ j ][ 1 ] = ( A [ i ] == B [ i ]); for ( int len = 2 ; len <= n ; ++ len ){ for ( int i = 0 ; i + len <= n ; ++ i ){ for ( int j = 0 ; j + len <= n ; ++ j ){ for ( int k = 1 ; k < len ; k ++ ){ if (( scramble [ i ][ j ][ k ] && scramble [ i + k ][ j + k ][ len - k ]) || ( scramble [ i ][ j + len - k ][ k ] && scramble [ i + k ][ j ][ len - k ]){ scramble [ i ][ j ][ len ] = 1 ; break ; } ) } } } } return scramble [ 0 ][ 0 ][ n ] ? 1 : 0 ; } Time Complexity: \\(O(n^4)\\) WildCard Pattern Matching \u00b6 Problem kya hai \u00b6 Given 2 strings, find the wildcard pattern between them - ? matches any single character - * matches any sequence of character This match must cover the entire string Return if A can be formed with the B pattern - A = aa and B = a* , then ans is 1 - A = aab and B = c*a*b , then output 0 hai Karna kaise hai \u00b6 Iske liye 2 pointer greedy karna padega with some backtracking for the * wala part. - If the character at B is * , remember uska position and current index in A, and try to match it with 0 chars first. - If there is a mismatch, then look for the previous * , since that can save us, and then advance the A pointer and try to match with more. - If the current pointer in B is ? ya fir it matches A, then advance both the pointers - If A khatam hogaya, then skip the trailing * in B - If dono khatam, then ans is 1 bool isMatch ( string A , string B ){ int n = A . size (), m = B . size (); int i = 0 , j = 0 ; int last_star = -1 , match_i = 0 ; while ( i < n ){ if ( j < m && ( B [ j ] == A [ i ] || B [ i ] == '?' )) i ++ , j ++ ; else if ( j < m && B [ j ] == '*' ){ last_star = j ; match_i = i ; j ++ ; } else if ( last_star != -1 ){ j = last_star + 1 ; match_i ++ ; i = match_i ; } else return 0 ; } while ( j < m && B [ j ] == '*' ) j ++ ; return ( j == m ) ? 1 : 0 ; } Pattern Matching . and * \u00b6 Problem kya hai \u00b6 Again pattern matching but, - . means atleast ek element hai here - * ek element nahi bhi hoga toh chalega Example: match( aa , .* ) is 1, but match( aa , . ) is 0. Kaise karna hai \u00b6 Yaha we finally use dynamic programming. match[i][j] means a[0...i-1] matches b[0..j-1] But isse bhi optimize karenge for only two rows. Rishte \u00b6 If B[j-1] is . or a[i-1] matches one character, tab match[i][j] = match[i-1][j-1] If B[j-1] is * , tab it can match zero or more previous element: Zero occurence: \\(match[i][j] \\space | \\space match[i][j-2]\\) One or more: If A[i-1] matched B[j-2] or B[j-2] is . , then match[i][j] |= match[i-1][j] else match[i][j] = 0 Truth \u00b6 match[0][0] = 1 (empty toh match hoga hi) match[0][j] = 1 if B[0...j-1] can represent empty match[i][0] = 0 for i > 0 coz non-empty match nahi kar sakta empty se The less optimized one but easier to understand: /* Regex-like pattern match for . = exactly one arbitrary character * = zero or more copies of the PREVIOUS pattern symbol dp[i][j] == true \u21d4 A[0 .. i-1] matches B[0 .. j-1] (so the table has (n+1) \u00d7 (m+1) entries) */ bool isMatch2D ( const string & A , const string & B ) { int n = A . size (), m = B . size (); vector < vector < bool >> dp ( n + 1 , vector < bool > ( m + 1 , false )); // \u278a empty pattern vs. empty text dp [ 0 ][ 0 ] = true ; // \u278b first row: empty text vs. longer & longer pattern // Only a chain like x* y* z* can match emptiness for ( int j = 2 ; j <= m ; ++ j ) if ( B [ j - 1 ] == '*' ) dp [ 0 ][ j ] = dp [ 0 ][ j - 2 ]; // \u278c fill the whole grid for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { char pc = B [ j - 1 ]; // current pattern symbol if ( pc != '*' ) // case 1: normal char or '.' { bool same = ( pc == '.' || pc == A [ i - 1 ]); dp [ i ][ j ] = same && dp [ i - 1 ][ j - 1 ]; } else // case 2: we\u2019re at a '*' { // pc == '*' \u2190 it always modifies B[j-2] // let prev = B[j - 2] // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 // zero copies of prev* bool zero = dp [ i ][ j - 2 ]; // one-or-more copies \u21d2 prev must match A[i-1] bool oneOrMore = false ; char prevPat = B [ j - 2 ]; if ( prevPat == '.' || prevPat == A [ i - 1 ]) oneOrMore = dp [ i - 1 ][ j ]; dp [ i ][ j ] = zero || oneOrMore ; } } } return dp [ n ][ m ]; } The optimized one: bool isMatch ( string A , string B ){ int n = A . size (), m = B . size (); vector < bool > prev ( m + 1 , false ), cur ( m + 1 , false ); prev [ 0 ] = true ; for ( int j = 1 ; j <= m ; ++ j ){ if ( B [ j -1 ] == '*' && j >= 2 ) prev [ j ] = prev [ j -2 ]; else prev [ j ] = false ; } for ( int i = 1 ; i <= n ; ++ i ){ cur [ 0 ] = false ; for ( int j = 1 ; j <= m ; ++ j ){ if ( B [ j -1 ] == '.' || B [ j -1 ] == A [ i -1 ]) cur [ j ] = prev [ j -1 ]; else if ( B [ j -1 ] == '*' ){ bool matchZero = ( j >= 2 ) ? cur [ j -2 ] : false ; bool matchOneOrMore = ( j >= 2 && ( B [ j -2 ] == '.' || B [ j -2 ] == A [ i -1 ]) ) ? prev [ j ] : false ; cur [ j ] = matchZero || matchOneOrMore ; } else cur [ j ] = false ; } swap ( cur , prev ); } return prev [ m ] ? 1 : 0 ; } Length of Longest Subsequence \u00b6 Problem yap \u00b6 Given array A, find length of longest sequence whihc is strictly increasing then strictly decreasing. (mountain peak type shit) Example: - A = [1,11,2,10,4,5,2,1] , output is 6 ( 1,2,10,4,2,1 ) How???? \u00b6 So this mountain thing is called bitonic subsequence. - For each i, compute lis[i] which is the length of longest increasing subsequence ending at i. - then also compute lds[i] which is length of longest decreasing subsequence starting at i - Ab bas har ek index pe compute dono ka sum \\(lis[i] + lds[i] - 1\\) int longSubseq ( vector < int > & A ){ int n = A . size (); if ( n == 0 ) return 0 ; vector < int > lis ( n , 1 ); for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) if ( A [ j ] < A [ j ]) lis [ i ] = max ( lis [ i ], lis [ j ] + 1 ); vector < int > lds ( n , 1 ); for ( int i = n -1 ; i >= 0 ; -- i ) for ( int j = i + 1 ; j < n ; ++ j ) if ( A [ j ] < A [ i ]) lds [ i ] = max ( lds [ i ], lds [ j ] + 1 ); int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) ans = max ( ans , lis [ i ] + lds [ i ] - 1 ); return ans ; } Smallest subsequence given the primes. \u00b6 Sexy ass statement \u00b6 Given 3 prime numbers, and an integer D, find the first smallest D positive numbers which only have A,B,C, or a combination of them as their prime factors. Input: A,B,C,D, Output: Array of size D A= 2, B = 3, C = 5, D = 5 the output is 2,3,4,5,6 How to do this shit. \u00b6 What they ask is Ugly Numbers (numbers with only prime as their factors) We use 3 pointers, with a min-merge approach - Maintain an array res initialized with the sequence {1} - For each index, multiple previous seq elements by A,B,C and pick the smallest new candidate. - Increment pointers which produced the candidate to avoid duplicates. $$ res[next] = min(res[i_1]\\times A,res[i_2]\\times B, res[i_3]\\times C) $$ vector < int > subseq ( int A , int B , int C , int D ){ vector < long long > primes = {( long long ) A ,( long long ) B , ( long long ) C }; sort ( primes . begin (), primes . end ()); long long p1 = primes [ 0 ], p2 = primes [ 1 ], p3 = primes [ 2 ]; vector < unsigned long long > res ( D + 1 ); res [ 0 ] = 1ull ; int i1 = 0 , i2 = 0 , i3 = 0 ; for ( int idx = 1 ; idx <= D ; idx ++ ){ unsigned long long nextA = res [ i1 ] * p1 , nextB = res [ i2 ] * p2 , nextC = res [ i3 ] * p3 ; unsigned long long val = min ({ nextA , nextB , nextC }); res [ idx ] = val ; if ( val == nextA ) i1 ++ ; if ( val == nextB ) i2 ++ ; if ( val == nextC ) i3 ++ ; } vector < int > ans ; for ( int k = 1 ; k <= D ; ++ k ){ ans . push_back (( int ) res [ k ]); } return ans ; } Largest Area of Rectangle with Permutations \u00b6 What does this bitch yap \u00b6 Given a binary grid A of \\(N \\times M\\) , find the area of the largest rectangle containing only 1s. We are allowed to permute the columns of the matrix in any order. Example $$ A = [[1,0,1],[0,1,0],[1,0,0]] $$ The output is 2 How to do this? \u00b6 For each cell (i,j), compute H[i][j] = number of consecutive 1's ending at (i,j) upto row i. For each row, treat H[i] as histogram of column heights, and since H[i] can be permuted, sort H[i] in descending order. For each width k (the k largest column heights), the maximal rectangle is \\(height \\times width = H[i][k-1] \\times k\\) Take the best over all i and k. Example dry run: A row0 1 0 1 1 0 1 row1 1 1 1 1 1 1 row2 1 1 1 0 1 1 row3 0 1 1 1 1 0 row4 1 1 1 1 1 1 row i formula per column j H[i] 0 first row \u2192 copy A 1 0 1 1 0 1 1 if A[1][j]==1 then 1+H[0][j] else 0 2 1 2 2 1 2 2 same rule 3 2 3 0 2 3 3 same rule 0 3 4 1 3 0 4 same rule 1 4 5 2 4 1 row original H[i] after sort \u2193 k height \u00b7 width 0 1 0 1 1 0 1 1 1 1 0 0 0 1 \u2192 1 2 \u2192 2 3 \u2192 3 3 1 2 1 2 2 1 2 2 2 2 2 1 1 1 \u2192 2 2 \u2192 4 3 \u2192 6 4 \u2192 8 5 \u2192 5 6 \u2192 6 8 2 3 2 3 0 2 3 3 3 3 2 2 0 1 \u2192 3 2 \u2192 6 3 \u2192 9 4 \u2192 8 5 \u2192 10 10 3 0 3 4 1 3 0 4 3 3 1 0 0 1 \u2192 4 2 \u2192 6 3 \u2192 9 4 \u2192 4 9 4 1 4 5 2 4 1 5 4 4 2 1 1 1 \u2192 5 2 \u2192 8 3 \u2192 12 4 \u2192 8 12 Hence the largest we find is \\(4 \\times 3 = 12\\) int maximalRectangle ( vector < vector < int >> & A ){ int N = A . size (); if ( N == 0 ) return 0 ; int M = A [ 0 ]. size (); // building H matrix vector < vector < int >> H ( N , vector < int > ( M , 0 )); for ( int j = 0 ; j < M ; ++ j ){ H [ 0 ][ j ] = A [ 0 ][ j ]; // starting meh consecutive ones is the 1 if the value at that ind is 1 } for ( int i = 1 ; i < N ; ++ i ) for ( int j = 0 ; j < M ; ++ j ){ if ( A [ i ][ j ] == 1 ) H [ i ][ j ] = H [ i -1 ][ j ] + 1 ; else H [ i ][ j ] = 0 ; } int ans = 0 ; for ( int i = 0 ; i < N ; ++ i ){ vector < int > row = H [ i ]; sort ( row . rbegin (), row . rend ()); for ( int k = 1 ; k <= M ; ++ k ){ int height = row [ k -1 ]; int area = height * k ; ans = max ( ans , area ); } } return ans ; } Tiling with Dominoes \u00b6 Problem Statement \u00b6 Given integer A, find total ways to tile a \\(3 \\times A\\) board with \\(2 \\times 1\\) dominoes. Return answer % \\(10^9 + 7\\) . Example: - A = 2, Output = 3 - A = 1, Output = 0 Maths behind this \u00b6 Let f(n) be the number of ways to tile a \\(3 \\times n\\) board. - f[0] = 1. (empty board) - f[1] = 0 (cannot be completely tiled) - f[2] = 3 - f[3] = 0. (odd ke liye toh impossible hai completely tile karna, always some remainder) - For n \\(\\geq\\) 4, even n, \\(f[n] = 4 \\times f[n-2] - f[n-4]\\) - For odd n, f[n] = 0 int domino ( int A ){ const int MOD = 1e9 + 7 ; vector < int > f ( A + 1 , 0 ); if ( A >= 0 ) f [ 0 ] = 1 ; if ( A >= 1 ) f [ 1 ] = 0 ; if ( A >= 2 ) f [ 2 ] = 1 ; if ( A >= 3 ) f [ 3 ] = 0 ; for ( int n = 4 ; n <= A ; ++ n ){ if ( n & 1 ) f [ n ] = 0 ; else { long long x = ( 4L L * f [ n -2 ]) % MOD ; x = ( x - f [ n -4 ] + MOD ) % MOD ; f [ n ] = ( int ) x ; } } return f [ A ]; } Paint House \u00b6 N houses in a row, each can be painted with RGB. Painting each house with a certain color has a given cost, represented by \\(n \\times 3\\) matrix A, where A[i][j] is the cost to paint the house i with cost j (0 -> red, 1-> blue, 2-> green). Paint such that - No two adjacent houses have the same color. - Minimize the total painting cost. Input \\(N\\times 3\\) matrix, output -> min cost to paint all. Example: $$ A = \\begin{matrix} 1 && 2 && 3\\ 10 && 11 && 12 \\end{matrix} $$ Output: 12 Paint 0 with R, 1 with G: 1 + 11 = 12 How to do this painting \u00b6 Let cost[i][c] be the min cost to paint houses 0 to i with house i painted color c. But since each row only depends on the previous,, we can just use 2 arrays. $$ cost[i][0] = A[i][0] + min(cost[i-1][1], cost[i-1][2]) $$ $$ cost[i][1] = A[i][1] + min(cost[i-1][0], cost[i-1][2]) $$ $$ cost[i][2] = A[i][2] + min(cost[i-1][0], cost[i-1][1]) $$ Iss se simple dp ho nahi sakta Thoda simple karne ke liye let prev_cost[c] be cost of painting the previous house with color c. prev_cost[c] = cost[i-1][c] int minCost ( vector < vector < int >> & A ){ int N = A . size (); if ( N == 0 ) return 0 ; long long prev_cost [ 3 ]; for ( int c = 0 ; c < 3 ; ++ c ) prev_cost [ c ] = A [ 0 ][ c ]; for ( int i = 1 ; i < N ; ++ i ){ long long cost [ 3 ]; cost [ 0 ] = A [ i ][ 0 ] + min ( prev_cost [ 1 ], prev_cost [ 2 ]); cost [ 1 ] = A [ i ][ 1 ] + min ( prev_cost [ 0 ], prev_cost [ 2 ]); cost [ 2 ] = A [ i ][ 2 ] + min ( prev_cost [ 0 ], prev_cost [ 1 ]); for ( int c = 0 ; c < 3 ; ++ c ) prev_cost [ c ] = cost [ c ]; } long long ans = min ({ prev_cost [ 0 ], prev_cost [ 1 ], prev_cost [ 2 ]}); return ( int ) ans ; } Ways to decode \u00b6 Given an encoded string A consisting of digits. - 'A' = 1, 'B' = 2 ... 'Z' = 26 find the total number of ways of decoding A modulo \\(10^9 + 7\\) . Input: String A, Output: total number of decoding ways. Example: - A = '8', Output = 1 (\"H\") - B = '12', Output = 2 (\"AB\", \"L\") Karna kaise hai \u00b6 Let ways[i] be number of ways to decode A[0...i] (first i characters) Toh iss ke rishte kuch aise honge: - If \\(A[0] = '0'\\) , single digit is valid, add ways[i-1] - If A[i-2,i-1] form a valid 2 digit number between 10 and 26, add ways[i-2] Base cases: - \\(ways[0] = 1\\) (empty string banane ka there is only one way) - \\(ways[1] = 1 \\text{ if A[0] } \\neq '0', \\text{ else 0}\\) int numDecodings ( string A ){ int n = A . length (); const int MOD = 1e9 + 7 ; if ( n == 0 ) return 0 ; vector < int > ways ( n + 1 , 0 ); ways [ 0 ] = 1 ; ways [ 1 ] = ( A [ 0 ] != '0' ) ? 1 : 0 ; for ( int i = 2 ; i <= n ; ++ i ){ char c1 = A [ i -1 ], c0 = A [ i -2 ]; if ( c1 != '0' ) ways [ i ] = ( ways [ i ] + ways [ i -1 ]) % MOD ; if ( c0 == '1' || ( c0 == '2' && c1 <= '6' )) ways [ i ] = ( ways [ i ] + ways [ i -2 ]) % MOD ; } return ways [ n ]; } Stairs \u00b6 Legendary beginner problem \u00b6 You are climbing a staircase with A steps. You can climb either 1 or 2 steps; How many distinct ways can you reach the top? Input: A = 2, Output = 2 ( [1,1],[2] ) Karna kaise hai \u00b6 Let \\(waysToStep[n]\\) be the number of ways to reach step n $$ waysToStep[i] = waysToStep[i-1] + waysToStep[i-2] $$ Some facts: \\(waysToStep[0] = 1\\) (1 way to stay at the bottom) \\(waysToStep[1] = 1\\) (climb one step) int climbStairs ( int A ){ if ( A <= 1 ) return 1 ;; int prev = 1 , curr = 2 ; for ( int i = 3 ; i <= A ; ++ i ) { int next = prev + curr ; prev = curr ; curr = next ; } return curr ; } Longest Increasing Subsequence \u00b6 Problem kya hai \u00b6 Given array of integers A, find the length of Longest Increasing Subsequence. Example: - A = [1,2,1,5] Output: 3 (LIS = [1,2,5] ) Karna kaise hai \u00b6 BINARY SEARCH BITCH - Maintain a list tail where tail[i] is the smallest possible tail value of an increasing subsequence of length i+1 - tail[i] is the smallest possible value that can end a increasing subsequence of length i+1 - For each x in A: - Use lower_bound to find the first element in tail \\(\\geq\\) x. - If none, append x (increase the LIS length) - Otherwise, replace it. (keep tail as small as possible for future extensions) - the older value was bigger than x, and it wouldn't be a valid increasing subsequence ending at i so we replace the bigger value withh this new pookie. Length of the tail at the end is the ans int lis ( vector < int > & A ){ vector < int > tail ; for ( int x : A ){ auto it = lower_bound ( tail . begin (), tail . end (), x ); // find first el >= x if ( it == tail . end ()) tail . push_back ( x ); else * it = x ; } return tails . size (); } Intersecting chords in a circle \u00b6 Given an integer \\(A\\) return the number of ways to draw A chords in a circle with \\(2A\\) points, such that no two chords intersect. Two ways are different if atleast one chord is present in one way but not the other. Return modulo \\(10^9 + 7\\) Example: - A = 1, Output = 1 - A = 2, Output = 2 How tho \u00b6 The number of ways to draw A non-intersecting chords on 2A points on a circle is the A-th Catalan number. $$ C_0 = 1, \\space \\space C_n = \\sum_{i=0}^{n-1} C_i \\times C_{n-1 - i} $$ where \\(C_n\\) is the number of valid chord drawings with n chords. int chordCut ( int A ){ const int MOD = 1e9 + 7 ; vector < long long > C ( A + 1 , 0 ); C [ 0 ] = 1 ; for ( int n = 1 ; n <= A ; ++ n ){ long long ways = 0 ; for ( int i = 0 ; i < n ; ++ i ){ ways = ( ways + C [ i ] * C [ n -1 - i ]) % MOD ; } C [ n ] = ways ; } return ( int ) C [ A ]; } Birthday Bombs \u00b6 Problem \u00b6 Tengu has N friends. Each friend \\(i\\) has a positive strength \\(B[i]\\) and can kick tengu any number of times. Tengu has pain resistance limit A. Find lexicographically smallest array of max pos length of friend indices, where each friend index can appear any number of times, such that their sum of strengths is \\(\\leq\\) A. How \u00b6 Max num of kicks: \\(M = \\frac{A}{w_{min}}\\) where \\(w_{min}\\) is the min val in B. At each kick pos, to keep ans smallest, try each friend in asc order and pick the lowest index friend whose cost allows enough resistance for remaining M-1 kicks, all possibly using the cheapest friend. After choosing, subtract from capacity and continue. vector < int > smallKicks ( int A , vector < int >& B ){ int N = B . size (); int w_min = * min_element ( B . begin (), B . end ()); int M = A / w_min ; if ( M == 0 ) return {}; vector < int > ans ; long long cap = A ; // remaining capacity for ( int pos = 0 ; pos < M ; ++ pos ){ int rem = M - pos - 1 ; for ( int i = 0 ; i < N ; ++ i ){ long long cost_i = B [ i ]; long long needed_for_rest = 1L L * rem * w_min ; if ( cost_i + needed_for_rest <= cap ){ ans . push_back ( i ); cap -= cost_i ; break ; } } } return ans ; } Jump Game Array \u00b6 Problem \u00b6 Given array A with non-neg int, you are at index 0. Each element A[i] is the max jump len from pos i. Determine if you can reach the last index. Example - \\(A = [2,3,1,1,4]\\) , Output = 1 - \\(A = [3,2,1,0,4]\\) , Output = 0 How: \u00b6 Keep track of maxReach index, like the farthest we can reach - for each index i, if i > maxReach, we are stuck, return 0 - warna update maxReach and move on int canJump ( vector < int > & A ){ int n = A . size (); long long maxReach = 0 ; for ( int i = 0 ; i < n ; ++ i ){ if ( i > maxReach ) return 0 ; maxReach = max ( maxReach , ( long long i ) + A [ i ]); if ( maxReach >= n -1 ) return 1 ; } return 1 ; } Min Jumps Array \u00b6 Problem \u00b6 Given array A with non-neg int, you are at index 0. Each A[i] represents the max jump length from that pos. Return the min number of jumps required to reach the last index. If not pos, return -1. How \u00b6 Use a greedy BFS - current_end : the farthest index we can reach with current jumps - furthest : farthest we can reach with one more jump - for every i in \\([0,current\\_end]\\) , update furthest to the farthest you can go. - when i reaches current_end, increment jump count, and extend curr_end to furthest. - if current_end cannot be extended, return -1 int jump ( vector < int > $A ){ int n = A . size (); if ( n <= 1 ) return 0 ; if ( A [ 0 ] == 0 ) return -1 ; int jumps = 0 , current_end = 0 , furthest = 0 ; for ( int i = 0 ; i + 1 < n ; ++ i ){ furthest = max ( furthest , i + A [ i ]); if ( i == current_end ){ jumps ++ ; current_end = furthest ; if ( current_end >= n -1 ) return jumps ; if ( current_end == i ) return -1 ; } } return ( current_end >= n -1 ) ? jumps : -1 ; }","title":"Dynamic Programming"},{"location":"DSAyy/dp/#longest-common-subsequence","text":"","title":"Longest Common Subsequence"},{"location":"DSAyy/dp/#question-statement","text":"Given 2 strings, find the length of uska longest common subsequence. Note subsequence does not have to be continuous. Example: A = \\(abbcdgf\\) and B = \\(bbadcgf\\) toh the output would be 5 (bbcgf is the lcs)","title":"Question Statement"},{"location":"DSAyy/dp/#kaise-karna-hai","text":"Thode subproblems meh divide karte hai isse. Let \\(\\text{LCS[i][j] be LCS of substrings A[0...i] and B[0....j]}\\) . Toh the obvious relation we can find is if \\(\\text{A[i-1] == B[j-1] fir LCS[i][j] is just LCS[i-1][j-1] + 1}\\) which means ki humme ek element same mil gaya, toh length would be 1 + the substrings removing those used indexes dono strings se. else \\(\\text{take max of LCS[i-1][j] and LCS[i][j-1]}\\) coz wahi dono possibilities are left. which means dono string se ek element skip karke check karlo Humhe continuity bhi maintain karni hai. Thats it literally. int LCS ( string A , string B ){ int n = A . size (), m = B . size (); vector < vector < int >> lcs ( n + 1 , vector < int > ( m + 1 , 0 )); for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 1 ; j <= m ; ++ j ){ if ( A [ i -1 ] == B [ j -1 ]) lcs [ i ][ j ] = 1 + lcs [ i -1 ][ j -1 ]; else lcs [ i ][ j ] = max ( lcs [ i -1 ][ j ], lcs [ i ][ j -1 ]); } return lcs [ n ][ m ]; } Time complexity \\(O(n \\times m)\\) and and same with space Now the sexy part is hum isse aur optimize kar sakte hai Abhi let \\(\\text{prev}\\) be the results of the i-1 row, and \\(curr\\) be the result of the current row i \\(\\text{LCS[i-1][j-1] = previous row ka j-1}\\) \\(\\text{LCS[i-1][j] = previous row ka j}\\) \\(\\text{LCS[i][j-1] = cur row ka j-1}\\) int LCS ( string A , string B ){ int n = A . size (), m = B . size (); if ( m > n ){ // keeping the rows as the bigger one, since lcs ka upper limit toh chotta wala hi hoga swap ( A , B ); swap ( m , n ); } vector < int > prev ( m + 1 , 0 ), cur ( m + 1 , 0 ); for ( int row = 1 ; row <= n ; ++ row ){ for ( int j = 1 ; j <= m ; ++ j ){ if ( A [ i -1 ] == B [ j -1 ]) cur [ j ] = prev [ j -1 ] + 1 ; // we found a similar el, toh prev row ke result se ek zyada hoga else cur [ j ] = max ( prev [ j ], cur [ j -1 ]); } swap ( prev , cur ) } return prev [ M ] } Isme the space complexity changed from \\(O(n\\times m)\\) se \\(O(min(n,m))\\)","title":"Kaise karna hai"},{"location":"DSAyy/dp/#longest-palindromic-subsequence","text":"","title":"Longest Palindromic Subsequence"},{"location":"DSAyy/dp/#question-statement_1","text":"Given a string A, find length of the longest palindromic subsequence. Example: \\(A = beebeeed\\) the output would be 4 coz LPS is \\(eeee\\)","title":"Question Statement"},{"location":"DSAyy/dp/#karna-kaise-hai","text":"Abe chutiye, Longest palindromic substring is just the LCS of A and reversed(A) I am not even gonna waste my time fuck off. $$ LPS(A) = LCS(A, reverse(A)) $$","title":"Karna kaise hai"},{"location":"DSAyy/dp/#edit-distance","text":"","title":"Edit Distance"},{"location":"DSAyy/dp/#problem-statement","text":"Given 2 strings, find min steps required to convert A to B given in one step we can - Insert a char - Delete a char - Replace a char Example: - A = abad, B = abac. The output is 1 coz sirf c ko d se replace karna","title":"Problem Statement"},{"location":"DSAyy/dp/#kaise-karna","text":"Let \\(edit[i][j]\\) be the minimum dist to convert \\(A[0...i-1] \\space and \\space B[0...j-1]\\) Toh iska rishta is $$ edit[i][j] = edit[i-1][j-1] \\space \\text{if A[i-1] and B[j-1] same hai} $$ $$ \\text{else if its different, edit[i][j] is gonna be 1 + min(edit[i-1][j], edit[i-1][j-1], edit[i-1][j-1])} $$ \\(edit[i-1][j]\\) means hum \\(A[i-1]\\) delete kar rahe hai same with \\(edit[i][j-1]\\) meaning \\(B[j-1]\\) delete \\(edit[i-1][j-1]\\) matlab bro humne dono ko replace kar diya ek dusre se and both are updated","title":"Kaise karna"},{"location":"DSAyy/dp/#base-cases","text":"Kuch baate sacch hoti hai Jaise, \\(edit[0][j] = j\\) -> means \\(B[0..j]\\) ko empty karne ke liye j operations are needed. Similarly. \\(edit[i][0] = i\\) Bas bhai ab chalao for loop, sabke level nikalenge. int editDistance ( string A , string B ){ int n = A . size (), B = B . size (); vector < vector < int >> edit ( n + 1 , vector < int > ( m + 1 , 0 )); // sach baate for ( int i = 1 ; i <= n ; ++ i ) edit [ i ][ 0 ] = i ; for ( int j = 1 ; j <= m ; ++ j ) edit [ 0 ][ j ] = j ; for ( int i = 1 ; i <= n ; ++ i ){ for ( int j = 1 ; j <= m ; ++ j ){ if ( A [ i -1 ] == B [ j -1 ]) edit [ i ][ j ] = edit [ i -1 ][ j -1 ]; // no extra edits needed else { edit [ i ][ j ] = 1 + min ({ edit [ i -1 ][ j ], edit [ i ][ j -1 ], edit [ i -1 ][ j -1 ] }); } } } return dp [ n ][ m ]; } Time and Space dono in this are \\(O(n\\times m)\\)","title":"Base Cases"},{"location":"DSAyy/dp/#repeating-subsequence","text":"","title":"Repeating Subsequence"},{"location":"DSAyy/dp/#problem-kya-yap-kar-raha","text":"String A, check kar if its longest repeating subsequence is \\(\\geq\\) 2. Repeating subsequence is basically repeating subsequence. Example: A = \\(abab\\) , Output is 1 (subseq \\(ab\\) repeats)","title":"Problem kya yap kar raha"},{"location":"DSAyy/dp/#how-to-solve","text":"$$ \\text{Repeating subsequence (A) is LCS(A,A) but i } \\neq j $$ Aur kuch bhi nahi. bas $$ \\text{return dp[n][n] } \\geq 2 $$","title":"How to solve?"},{"location":"DSAyy/dp/#distinct-subsequences","text":"","title":"Distinct Subsequences"},{"location":"DSAyy/dp/#problem-statement_1","text":"Given 2 sequences A and B, count ways to form B as a subseq of A. Example: - A = rabbbit, B = rabbit, Output 3 - Basically all 3 b can be removed.","title":"Problem Statement"},{"location":"DSAyy/dp/#karu-kaise","text":"Let \\(ways[j]\\) be ways to form \\(B[0...j]\\) as a subseq of first i elements of A. Isse 1D meh fit kar sakte if we update j from right to left, toh \\(ways[j-1]\\) hoga from previous i Toh the rishta would be $$ ways[j] = ways[j] + ways[j-1] \\text{ if A[i-1] == B[j-1]} $$ warna \\(ways[j]\\) would remain 0, coz agar element hi same nai toh string kaise banega with those indexes. Note ki \\(ways[j-1]\\) humare previous i ke iteration se hoga, so we have already computed pehle ka. int distSubseq ( string A , string B ){ int n = A . size (), m = B . size (); vector < long long > ways ( m + 1 , 0 ); ways [ 0 ] = 1 ; //empty banane ke liye kya hi chahiye for ( int i = 1 ; i <= n ; ++ i ){ for ( int j = m ; j >= 1 ; -- j ){ if ( A [ i -1 ] == B [ j -1 ]){ ways [ j ] += ways [ j -1 ]; } } } return ( int ) ways [ m ]; }","title":"Karu kaise?"},{"location":"DSAyy/dp/#scramble-string","text":"","title":"Scramble String"},{"location":"DSAyy/dp/#what-does-the-dog-say","text":"Given 2 strings, bata if the other string can be made by scrambling A. Now what the fuck is scrambling? B is scramble(A) if -> A can be represented as a binary tree by recursively partitioninng into two non-substrings, and by swapping left and right children any number of times, we can get B. What the helly? Input: A= we and B = we Ans = 1.","title":"What does the dog say?"},{"location":"DSAyy/dp/#bhai-mar-jau-meh","text":"Iske liye we use 3D dp. Whether A[i...i+len - 1] can be scrambled into B[j....j+len - 1] Let scramble[i][j][len] be true if A.substr(i,len) can be scrambled into B.substr(j,len","title":"Bhai mar jau meh?"},{"location":"DSAyy/dp/#hard-truth","text":"Bhai pata nahi yaar ye scrambling shit kya hai Base Case : For length 1, scramble[i][j][1] = (A[i] == B[j]) Like bhai ek hi toh length hai, same string hi hogaya ye toh For each length \\(l\\) from 2 to n, for all A.substr(i,l) and B.substr(j,l) har ek split k try kar le - No swap: scramble[i][j][l] is true if \\(scramble[i][j][k] \\space \\& \\space scramble[i][j][l-k]\\) meaning dono continuous partitions valid hai. - Swap: scramble[i][j][l] is true if scramble[i][j+l-k][k] and scramble[i+k][j][l-k] dono true hai Also quick check: If dono sorted are different, tab toh they cant scramble. bool isScramble ( string A , string B ){ int n = A . size (); if ( n != B . length ()) return 0 ; //quick sorted check { array < int , 256 > freq = { 0 }; for ( char c : A ) freq [( unsigned char ) c ] ++ ; for ( char c : B ) freq [( unsigned char ) c ] -- ; for ( int x : freq ) if ( x != 0 ) return 0 ; } static bool scramble [ 51 ][ 51 ][ 51 ]; memset ( dp , false , sizeof ( scramble )); // base case for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) scramlbe [ i ][ j ][ 1 ] = ( A [ i ] == B [ i ]); for ( int len = 2 ; len <= n ; ++ len ){ for ( int i = 0 ; i + len <= n ; ++ i ){ for ( int j = 0 ; j + len <= n ; ++ j ){ for ( int k = 1 ; k < len ; k ++ ){ if (( scramble [ i ][ j ][ k ] && scramble [ i + k ][ j + k ][ len - k ]) || ( scramble [ i ][ j + len - k ][ k ] && scramble [ i + k ][ j ][ len - k ]){ scramble [ i ][ j ][ len ] = 1 ; break ; } ) } } } } return scramble [ 0 ][ 0 ][ n ] ? 1 : 0 ; } Time Complexity: \\(O(n^4)\\)","title":"Hard Truth"},{"location":"DSAyy/dp/#wildcard-pattern-matching","text":"","title":"WildCard Pattern Matching"},{"location":"DSAyy/dp/#problem-kya-hai","text":"Given 2 strings, find the wildcard pattern between them - ? matches any single character - * matches any sequence of character This match must cover the entire string Return if A can be formed with the B pattern - A = aa and B = a* , then ans is 1 - A = aab and B = c*a*b , then output 0 hai","title":"Problem kya hai"},{"location":"DSAyy/dp/#karna-kaise-hai_1","text":"Iske liye 2 pointer greedy karna padega with some backtracking for the * wala part. - If the character at B is * , remember uska position and current index in A, and try to match it with 0 chars first. - If there is a mismatch, then look for the previous * , since that can save us, and then advance the A pointer and try to match with more. - If the current pointer in B is ? ya fir it matches A, then advance both the pointers - If A khatam hogaya, then skip the trailing * in B - If dono khatam, then ans is 1 bool isMatch ( string A , string B ){ int n = A . size (), m = B . size (); int i = 0 , j = 0 ; int last_star = -1 , match_i = 0 ; while ( i < n ){ if ( j < m && ( B [ j ] == A [ i ] || B [ i ] == '?' )) i ++ , j ++ ; else if ( j < m && B [ j ] == '*' ){ last_star = j ; match_i = i ; j ++ ; } else if ( last_star != -1 ){ j = last_star + 1 ; match_i ++ ; i = match_i ; } else return 0 ; } while ( j < m && B [ j ] == '*' ) j ++ ; return ( j == m ) ? 1 : 0 ; }","title":"Karna kaise hai"},{"location":"DSAyy/dp/#pattern-matching-and","text":"","title":"Pattern Matching . and *"},{"location":"DSAyy/dp/#problem-kya-hai_1","text":"Again pattern matching but, - . means atleast ek element hai here - * ek element nahi bhi hoga toh chalega Example: match( aa , .* ) is 1, but match( aa , . ) is 0.","title":"Problem kya hai"},{"location":"DSAyy/dp/#kaise-karna-hai_1","text":"Yaha we finally use dynamic programming. match[i][j] means a[0...i-1] matches b[0..j-1] But isse bhi optimize karenge for only two rows.","title":"Kaise karna hai"},{"location":"DSAyy/dp/#rishte","text":"If B[j-1] is . or a[i-1] matches one character, tab match[i][j] = match[i-1][j-1] If B[j-1] is * , tab it can match zero or more previous element: Zero occurence: \\(match[i][j] \\space | \\space match[i][j-2]\\) One or more: If A[i-1] matched B[j-2] or B[j-2] is . , then match[i][j] |= match[i-1][j] else match[i][j] = 0","title":"Rishte"},{"location":"DSAyy/dp/#truth","text":"match[0][0] = 1 (empty toh match hoga hi) match[0][j] = 1 if B[0...j-1] can represent empty match[i][0] = 0 for i > 0 coz non-empty match nahi kar sakta empty se The less optimized one but easier to understand: /* Regex-like pattern match for . = exactly one arbitrary character * = zero or more copies of the PREVIOUS pattern symbol dp[i][j] == true \u21d4 A[0 .. i-1] matches B[0 .. j-1] (so the table has (n+1) \u00d7 (m+1) entries) */ bool isMatch2D ( const string & A , const string & B ) { int n = A . size (), m = B . size (); vector < vector < bool >> dp ( n + 1 , vector < bool > ( m + 1 , false )); // \u278a empty pattern vs. empty text dp [ 0 ][ 0 ] = true ; // \u278b first row: empty text vs. longer & longer pattern // Only a chain like x* y* z* can match emptiness for ( int j = 2 ; j <= m ; ++ j ) if ( B [ j - 1 ] == '*' ) dp [ 0 ][ j ] = dp [ 0 ][ j - 2 ]; // \u278c fill the whole grid for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { char pc = B [ j - 1 ]; // current pattern symbol if ( pc != '*' ) // case 1: normal char or '.' { bool same = ( pc == '.' || pc == A [ i - 1 ]); dp [ i ][ j ] = same && dp [ i - 1 ][ j - 1 ]; } else // case 2: we\u2019re at a '*' { // pc == '*' \u2190 it always modifies B[j-2] // let prev = B[j - 2] // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 // zero copies of prev* bool zero = dp [ i ][ j - 2 ]; // one-or-more copies \u21d2 prev must match A[i-1] bool oneOrMore = false ; char prevPat = B [ j - 2 ]; if ( prevPat == '.' || prevPat == A [ i - 1 ]) oneOrMore = dp [ i - 1 ][ j ]; dp [ i ][ j ] = zero || oneOrMore ; } } } return dp [ n ][ m ]; } The optimized one: bool isMatch ( string A , string B ){ int n = A . size (), m = B . size (); vector < bool > prev ( m + 1 , false ), cur ( m + 1 , false ); prev [ 0 ] = true ; for ( int j = 1 ; j <= m ; ++ j ){ if ( B [ j -1 ] == '*' && j >= 2 ) prev [ j ] = prev [ j -2 ]; else prev [ j ] = false ; } for ( int i = 1 ; i <= n ; ++ i ){ cur [ 0 ] = false ; for ( int j = 1 ; j <= m ; ++ j ){ if ( B [ j -1 ] == '.' || B [ j -1 ] == A [ i -1 ]) cur [ j ] = prev [ j -1 ]; else if ( B [ j -1 ] == '*' ){ bool matchZero = ( j >= 2 ) ? cur [ j -2 ] : false ; bool matchOneOrMore = ( j >= 2 && ( B [ j -2 ] == '.' || B [ j -2 ] == A [ i -1 ]) ) ? prev [ j ] : false ; cur [ j ] = matchZero || matchOneOrMore ; } else cur [ j ] = false ; } swap ( cur , prev ); } return prev [ m ] ? 1 : 0 ; }","title":"Truth"},{"location":"DSAyy/dp/#length-of-longest-subsequence","text":"","title":"Length of Longest Subsequence"},{"location":"DSAyy/dp/#problem-yap","text":"Given array A, find length of longest sequence whihc is strictly increasing then strictly decreasing. (mountain peak type shit) Example: - A = [1,11,2,10,4,5,2,1] , output is 6 ( 1,2,10,4,2,1 )","title":"Problem yap"},{"location":"DSAyy/dp/#how","text":"So this mountain thing is called bitonic subsequence. - For each i, compute lis[i] which is the length of longest increasing subsequence ending at i. - then also compute lds[i] which is length of longest decreasing subsequence starting at i - Ab bas har ek index pe compute dono ka sum \\(lis[i] + lds[i] - 1\\) int longSubseq ( vector < int > & A ){ int n = A . size (); if ( n == 0 ) return 0 ; vector < int > lis ( n , 1 ); for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) if ( A [ j ] < A [ j ]) lis [ i ] = max ( lis [ i ], lis [ j ] + 1 ); vector < int > lds ( n , 1 ); for ( int i = n -1 ; i >= 0 ; -- i ) for ( int j = i + 1 ; j < n ; ++ j ) if ( A [ j ] < A [ i ]) lds [ i ] = max ( lds [ i ], lds [ j ] + 1 ); int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) ans = max ( ans , lis [ i ] + lds [ i ] - 1 ); return ans ; }","title":"How????"},{"location":"DSAyy/dp/#smallest-subsequence-given-the-primes","text":"","title":"Smallest subsequence given the primes."},{"location":"DSAyy/dp/#sexy-ass-statement","text":"Given 3 prime numbers, and an integer D, find the first smallest D positive numbers which only have A,B,C, or a combination of them as their prime factors. Input: A,B,C,D, Output: Array of size D A= 2, B = 3, C = 5, D = 5 the output is 2,3,4,5,6","title":"Sexy ass statement"},{"location":"DSAyy/dp/#how-to-do-this-shit","text":"What they ask is Ugly Numbers (numbers with only prime as their factors) We use 3 pointers, with a min-merge approach - Maintain an array res initialized with the sequence {1} - For each index, multiple previous seq elements by A,B,C and pick the smallest new candidate. - Increment pointers which produced the candidate to avoid duplicates. $$ res[next] = min(res[i_1]\\times A,res[i_2]\\times B, res[i_3]\\times C) $$ vector < int > subseq ( int A , int B , int C , int D ){ vector < long long > primes = {( long long ) A ,( long long ) B , ( long long ) C }; sort ( primes . begin (), primes . end ()); long long p1 = primes [ 0 ], p2 = primes [ 1 ], p3 = primes [ 2 ]; vector < unsigned long long > res ( D + 1 ); res [ 0 ] = 1ull ; int i1 = 0 , i2 = 0 , i3 = 0 ; for ( int idx = 1 ; idx <= D ; idx ++ ){ unsigned long long nextA = res [ i1 ] * p1 , nextB = res [ i2 ] * p2 , nextC = res [ i3 ] * p3 ; unsigned long long val = min ({ nextA , nextB , nextC }); res [ idx ] = val ; if ( val == nextA ) i1 ++ ; if ( val == nextB ) i2 ++ ; if ( val == nextC ) i3 ++ ; } vector < int > ans ; for ( int k = 1 ; k <= D ; ++ k ){ ans . push_back (( int ) res [ k ]); } return ans ; }","title":"How to do this shit."},{"location":"DSAyy/dp/#largest-area-of-rectangle-with-permutations","text":"","title":"Largest Area of Rectangle with Permutations"},{"location":"DSAyy/dp/#what-does-this-bitch-yap","text":"Given a binary grid A of \\(N \\times M\\) , find the area of the largest rectangle containing only 1s. We are allowed to permute the columns of the matrix in any order. Example $$ A = [[1,0,1],[0,1,0],[1,0,0]] $$ The output is 2","title":"What does this bitch yap"},{"location":"DSAyy/dp/#how-to-do-this","text":"For each cell (i,j), compute H[i][j] = number of consecutive 1's ending at (i,j) upto row i. For each row, treat H[i] as histogram of column heights, and since H[i] can be permuted, sort H[i] in descending order. For each width k (the k largest column heights), the maximal rectangle is \\(height \\times width = H[i][k-1] \\times k\\) Take the best over all i and k. Example dry run: A row0 1 0 1 1 0 1 row1 1 1 1 1 1 1 row2 1 1 1 0 1 1 row3 0 1 1 1 1 0 row4 1 1 1 1 1 1 row i formula per column j H[i] 0 first row \u2192 copy A 1 0 1 1 0 1 1 if A[1][j]==1 then 1+H[0][j] else 0 2 1 2 2 1 2 2 same rule 3 2 3 0 2 3 3 same rule 0 3 4 1 3 0 4 same rule 1 4 5 2 4 1 row original H[i] after sort \u2193 k height \u00b7 width 0 1 0 1 1 0 1 1 1 1 0 0 0 1 \u2192 1 2 \u2192 2 3 \u2192 3 3 1 2 1 2 2 1 2 2 2 2 2 1 1 1 \u2192 2 2 \u2192 4 3 \u2192 6 4 \u2192 8 5 \u2192 5 6 \u2192 6 8 2 3 2 3 0 2 3 3 3 3 2 2 0 1 \u2192 3 2 \u2192 6 3 \u2192 9 4 \u2192 8 5 \u2192 10 10 3 0 3 4 1 3 0 4 3 3 1 0 0 1 \u2192 4 2 \u2192 6 3 \u2192 9 4 \u2192 4 9 4 1 4 5 2 4 1 5 4 4 2 1 1 1 \u2192 5 2 \u2192 8 3 \u2192 12 4 \u2192 8 12 Hence the largest we find is \\(4 \\times 3 = 12\\) int maximalRectangle ( vector < vector < int >> & A ){ int N = A . size (); if ( N == 0 ) return 0 ; int M = A [ 0 ]. size (); // building H matrix vector < vector < int >> H ( N , vector < int > ( M , 0 )); for ( int j = 0 ; j < M ; ++ j ){ H [ 0 ][ j ] = A [ 0 ][ j ]; // starting meh consecutive ones is the 1 if the value at that ind is 1 } for ( int i = 1 ; i < N ; ++ i ) for ( int j = 0 ; j < M ; ++ j ){ if ( A [ i ][ j ] == 1 ) H [ i ][ j ] = H [ i -1 ][ j ] + 1 ; else H [ i ][ j ] = 0 ; } int ans = 0 ; for ( int i = 0 ; i < N ; ++ i ){ vector < int > row = H [ i ]; sort ( row . rbegin (), row . rend ()); for ( int k = 1 ; k <= M ; ++ k ){ int height = row [ k -1 ]; int area = height * k ; ans = max ( ans , area ); } } return ans ; }","title":"How to do this?"},{"location":"DSAyy/dp/#tiling-with-dominoes","text":"","title":"Tiling with Dominoes"},{"location":"DSAyy/dp/#problem-statement_2","text":"Given integer A, find total ways to tile a \\(3 \\times A\\) board with \\(2 \\times 1\\) dominoes. Return answer % \\(10^9 + 7\\) . Example: - A = 2, Output = 3 - A = 1, Output = 0","title":"Problem Statement"},{"location":"DSAyy/dp/#maths-behind-this","text":"Let f(n) be the number of ways to tile a \\(3 \\times n\\) board. - f[0] = 1. (empty board) - f[1] = 0 (cannot be completely tiled) - f[2] = 3 - f[3] = 0. (odd ke liye toh impossible hai completely tile karna, always some remainder) - For n \\(\\geq\\) 4, even n, \\(f[n] = 4 \\times f[n-2] - f[n-4]\\) - For odd n, f[n] = 0 int domino ( int A ){ const int MOD = 1e9 + 7 ; vector < int > f ( A + 1 , 0 ); if ( A >= 0 ) f [ 0 ] = 1 ; if ( A >= 1 ) f [ 1 ] = 0 ; if ( A >= 2 ) f [ 2 ] = 1 ; if ( A >= 3 ) f [ 3 ] = 0 ; for ( int n = 4 ; n <= A ; ++ n ){ if ( n & 1 ) f [ n ] = 0 ; else { long long x = ( 4L L * f [ n -2 ]) % MOD ; x = ( x - f [ n -4 ] + MOD ) % MOD ; f [ n ] = ( int ) x ; } } return f [ A ]; }","title":"Maths behind this"},{"location":"DSAyy/dp/#paint-house","text":"N houses in a row, each can be painted with RGB. Painting each house with a certain color has a given cost, represented by \\(n \\times 3\\) matrix A, where A[i][j] is the cost to paint the house i with cost j (0 -> red, 1-> blue, 2-> green). Paint such that - No two adjacent houses have the same color. - Minimize the total painting cost. Input \\(N\\times 3\\) matrix, output -> min cost to paint all. Example: $$ A = \\begin{matrix} 1 && 2 && 3\\ 10 && 11 && 12 \\end{matrix} $$ Output: 12 Paint 0 with R, 1 with G: 1 + 11 = 12","title":"Paint House"},{"location":"DSAyy/dp/#how-to-do-this-painting","text":"Let cost[i][c] be the min cost to paint houses 0 to i with house i painted color c. But since each row only depends on the previous,, we can just use 2 arrays. $$ cost[i][0] = A[i][0] + min(cost[i-1][1], cost[i-1][2]) $$ $$ cost[i][1] = A[i][1] + min(cost[i-1][0], cost[i-1][2]) $$ $$ cost[i][2] = A[i][2] + min(cost[i-1][0], cost[i-1][1]) $$ Iss se simple dp ho nahi sakta Thoda simple karne ke liye let prev_cost[c] be cost of painting the previous house with color c. prev_cost[c] = cost[i-1][c] int minCost ( vector < vector < int >> & A ){ int N = A . size (); if ( N == 0 ) return 0 ; long long prev_cost [ 3 ]; for ( int c = 0 ; c < 3 ; ++ c ) prev_cost [ c ] = A [ 0 ][ c ]; for ( int i = 1 ; i < N ; ++ i ){ long long cost [ 3 ]; cost [ 0 ] = A [ i ][ 0 ] + min ( prev_cost [ 1 ], prev_cost [ 2 ]); cost [ 1 ] = A [ i ][ 1 ] + min ( prev_cost [ 0 ], prev_cost [ 2 ]); cost [ 2 ] = A [ i ][ 2 ] + min ( prev_cost [ 0 ], prev_cost [ 1 ]); for ( int c = 0 ; c < 3 ; ++ c ) prev_cost [ c ] = cost [ c ]; } long long ans = min ({ prev_cost [ 0 ], prev_cost [ 1 ], prev_cost [ 2 ]}); return ( int ) ans ; }","title":"How to do this painting"},{"location":"DSAyy/dp/#ways-to-decode","text":"Given an encoded string A consisting of digits. - 'A' = 1, 'B' = 2 ... 'Z' = 26 find the total number of ways of decoding A modulo \\(10^9 + 7\\) . Input: String A, Output: total number of decoding ways. Example: - A = '8', Output = 1 (\"H\") - B = '12', Output = 2 (\"AB\", \"L\")","title":"Ways to decode"},{"location":"DSAyy/dp/#karna-kaise-hai_2","text":"Let ways[i] be number of ways to decode A[0...i] (first i characters) Toh iss ke rishte kuch aise honge: - If \\(A[0] = '0'\\) , single digit is valid, add ways[i-1] - If A[i-2,i-1] form a valid 2 digit number between 10 and 26, add ways[i-2] Base cases: - \\(ways[0] = 1\\) (empty string banane ka there is only one way) - \\(ways[1] = 1 \\text{ if A[0] } \\neq '0', \\text{ else 0}\\) int numDecodings ( string A ){ int n = A . length (); const int MOD = 1e9 + 7 ; if ( n == 0 ) return 0 ; vector < int > ways ( n + 1 , 0 ); ways [ 0 ] = 1 ; ways [ 1 ] = ( A [ 0 ] != '0' ) ? 1 : 0 ; for ( int i = 2 ; i <= n ; ++ i ){ char c1 = A [ i -1 ], c0 = A [ i -2 ]; if ( c1 != '0' ) ways [ i ] = ( ways [ i ] + ways [ i -1 ]) % MOD ; if ( c0 == '1' || ( c0 == '2' && c1 <= '6' )) ways [ i ] = ( ways [ i ] + ways [ i -2 ]) % MOD ; } return ways [ n ]; }","title":"Karna kaise hai"},{"location":"DSAyy/dp/#stairs","text":"","title":"Stairs"},{"location":"DSAyy/dp/#legendary-beginner-problem","text":"You are climbing a staircase with A steps. You can climb either 1 or 2 steps; How many distinct ways can you reach the top? Input: A = 2, Output = 2 ( [1,1],[2] )","title":"Legendary beginner problem"},{"location":"DSAyy/dp/#karna-kaise-hai_3","text":"Let \\(waysToStep[n]\\) be the number of ways to reach step n $$ waysToStep[i] = waysToStep[i-1] + waysToStep[i-2] $$ Some facts: \\(waysToStep[0] = 1\\) (1 way to stay at the bottom) \\(waysToStep[1] = 1\\) (climb one step) int climbStairs ( int A ){ if ( A <= 1 ) return 1 ;; int prev = 1 , curr = 2 ; for ( int i = 3 ; i <= A ; ++ i ) { int next = prev + curr ; prev = curr ; curr = next ; } return curr ; }","title":"Karna kaise hai"},{"location":"DSAyy/dp/#longest-increasing-subsequence","text":"","title":"Longest Increasing Subsequence"},{"location":"DSAyy/dp/#problem-kya-hai_2","text":"Given array of integers A, find the length of Longest Increasing Subsequence. Example: - A = [1,2,1,5] Output: 3 (LIS = [1,2,5] )","title":"Problem kya hai"},{"location":"DSAyy/dp/#karna-kaise-hai_4","text":"BINARY SEARCH BITCH - Maintain a list tail where tail[i] is the smallest possible tail value of an increasing subsequence of length i+1 - tail[i] is the smallest possible value that can end a increasing subsequence of length i+1 - For each x in A: - Use lower_bound to find the first element in tail \\(\\geq\\) x. - If none, append x (increase the LIS length) - Otherwise, replace it. (keep tail as small as possible for future extensions) - the older value was bigger than x, and it wouldn't be a valid increasing subsequence ending at i so we replace the bigger value withh this new pookie. Length of the tail at the end is the ans int lis ( vector < int > & A ){ vector < int > tail ; for ( int x : A ){ auto it = lower_bound ( tail . begin (), tail . end (), x ); // find first el >= x if ( it == tail . end ()) tail . push_back ( x ); else * it = x ; } return tails . size (); }","title":"Karna kaise hai"},{"location":"DSAyy/dp/#intersecting-chords-in-a-circle","text":"Given an integer \\(A\\) return the number of ways to draw A chords in a circle with \\(2A\\) points, such that no two chords intersect. Two ways are different if atleast one chord is present in one way but not the other. Return modulo \\(10^9 + 7\\) Example: - A = 1, Output = 1 - A = 2, Output = 2","title":"Intersecting chords in a circle"},{"location":"DSAyy/dp/#how-tho","text":"The number of ways to draw A non-intersecting chords on 2A points on a circle is the A-th Catalan number. $$ C_0 = 1, \\space \\space C_n = \\sum_{i=0}^{n-1} C_i \\times C_{n-1 - i} $$ where \\(C_n\\) is the number of valid chord drawings with n chords. int chordCut ( int A ){ const int MOD = 1e9 + 7 ; vector < long long > C ( A + 1 , 0 ); C [ 0 ] = 1 ; for ( int n = 1 ; n <= A ; ++ n ){ long long ways = 0 ; for ( int i = 0 ; i < n ; ++ i ){ ways = ( ways + C [ i ] * C [ n -1 - i ]) % MOD ; } C [ n ] = ways ; } return ( int ) C [ A ]; }","title":"How tho"},{"location":"DSAyy/dp/#birthday-bombs","text":"","title":"Birthday Bombs"},{"location":"DSAyy/dp/#problem","text":"Tengu has N friends. Each friend \\(i\\) has a positive strength \\(B[i]\\) and can kick tengu any number of times. Tengu has pain resistance limit A. Find lexicographically smallest array of max pos length of friend indices, where each friend index can appear any number of times, such that their sum of strengths is \\(\\leq\\) A.","title":"Problem"},{"location":"DSAyy/dp/#how_1","text":"Max num of kicks: \\(M = \\frac{A}{w_{min}}\\) where \\(w_{min}\\) is the min val in B. At each kick pos, to keep ans smallest, try each friend in asc order and pick the lowest index friend whose cost allows enough resistance for remaining M-1 kicks, all possibly using the cheapest friend. After choosing, subtract from capacity and continue. vector < int > smallKicks ( int A , vector < int >& B ){ int N = B . size (); int w_min = * min_element ( B . begin (), B . end ()); int M = A / w_min ; if ( M == 0 ) return {}; vector < int > ans ; long long cap = A ; // remaining capacity for ( int pos = 0 ; pos < M ; ++ pos ){ int rem = M - pos - 1 ; for ( int i = 0 ; i < N ; ++ i ){ long long cost_i = B [ i ]; long long needed_for_rest = 1L L * rem * w_min ; if ( cost_i + needed_for_rest <= cap ){ ans . push_back ( i ); cap -= cost_i ; break ; } } } return ans ; }","title":"How"},{"location":"DSAyy/dp/#jump-game-array","text":"","title":"Jump Game Array"},{"location":"DSAyy/dp/#problem_1","text":"Given array A with non-neg int, you are at index 0. Each element A[i] is the max jump len from pos i. Determine if you can reach the last index. Example - \\(A = [2,3,1,1,4]\\) , Output = 1 - \\(A = [3,2,1,0,4]\\) , Output = 0","title":"Problem"},{"location":"DSAyy/dp/#how_2","text":"Keep track of maxReach index, like the farthest we can reach - for each index i, if i > maxReach, we are stuck, return 0 - warna update maxReach and move on int canJump ( vector < int > & A ){ int n = A . size (); long long maxReach = 0 ; for ( int i = 0 ; i < n ; ++ i ){ if ( i > maxReach ) return 0 ; maxReach = max ( maxReach , ( long long i ) + A [ i ]); if ( maxReach >= n -1 ) return 1 ; } return 1 ; }","title":"How:"},{"location":"DSAyy/dp/#min-jumps-array","text":"","title":"Min Jumps Array"},{"location":"DSAyy/dp/#problem_2","text":"Given array A with non-neg int, you are at index 0. Each A[i] represents the max jump length from that pos. Return the min number of jumps required to reach the last index. If not pos, return -1.","title":"Problem"},{"location":"DSAyy/dp/#how_3","text":"Use a greedy BFS - current_end : the farthest index we can reach with current jumps - furthest : farthest we can reach with one more jump - for every i in \\([0,current\\_end]\\) , update furthest to the farthest you can go. - when i reaches current_end, increment jump count, and extend curr_end to furthest. - if current_end cannot be extended, return -1 int jump ( vector < int > $A ){ int n = A . size (); if ( n <= 1 ) return 0 ; if ( A [ 0 ] == 0 ) return -1 ; int jumps = 0 , current_end = 0 , furthest = 0 ; for ( int i = 0 ; i + 1 < n ; ++ i ){ furthest = max ( furthest , i + A [ i ]); if ( i == current_end ){ jumps ++ ; current_end = furthest ; if ( current_end >= n -1 ) return jumps ; if ( current_end == i ) return -1 ; } } return ( current_end >= n -1 ) ? jumps : -1 ; }","title":"How"},{"location":"DSAyy/graph/","text":"\\[ a^2 + b^2 = c^2 \\]","title":"Graphs"}]}
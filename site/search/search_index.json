{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"DSAyy/arrays/","title":"Array Simulation","text":""},{"location":"DSAyy/arrays/#spiral-order-matrix","title":"Spiral Order Matrix","text":""},{"location":"DSAyy/arrays/#question-kya-hai","title":"Question kya hai","text":"<p>Matrix A: Size M x N, return all elements in the spiral order. (clockwise starting from top-left)</p> <p>$$ \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \\end{bmatrix} $$ the output would be 1,2,3,6,9,8,7,4,5</p>"},{"location":"DSAyy/arrays/#how-to-do-this","title":"How to do this","text":"<p>Take 4 pointers and continuously run for loops on that bitch.  Bas run top first, then right, then down, then left</p> <pre><code>vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt; &amp;A){\n    int M = A.size(), N = A[0].size();\n    int u = 0, d = M-1, l = 0, r = N-1;\n    vector&lt;int&gt; spiral;\n    while (l &lt;= r &amp;&amp; u &lt;= d){\n        for (int i = l; i &lt;= r; ++i)\n            spiral.push_back(A[u][i]);\n        ++u;\n        for (int i = u; i &lt;= d; ++i)\n            spiral.push_back(A[i][r]);\n        --r;\n        if (u &lt;= d){\n            for (int i = r; i &gt;= l; --i)\n                spiral.push_back(A[d][i]);\n            --d;\n        }\n        if (l &lt;= r){\n            for (int i = d; i &gt;= u; --i)\n                spiral.push_back(A[i][l]);\n            ++l;\n        }\n    }\n    return spiral;\n}\n</code></pre> <p>Iski time complexity is O(n \\times m) Space complexity bhi same</p>"},{"location":"DSAyy/arrays/#large-factorial","title":"Large Factorial","text":""},{"location":"DSAyy/arrays/#question","title":"Question","text":"<p>Given integer A, compute A ! as a string, coz kuch zyaada hi bada number hai.</p>"},{"location":"DSAyy/arrays/#kaise-karna-hai-ye","title":"Kaise karna hai ye","text":"<p>Dekh bro as a string return karna hai answer toh legit make a multiply function for strings and karle solve. Kya hi dumb shit hai ye. Just know ki digits would be reversed for the convenience of the carry shit.  Toh reverse pointer se string meh add kariyo.</p> <pre><code>string factorial(int A){\n    vector&lt;int&gt; digits {1}; // har factorial meh 1 toh hota hi hai\n\n    auto multiply = [&amp;](int i) {\n        int carry = 0;\n        for (int &amp;d : digits){\n            long long prod = (long long)d * i + carry;\n            d = prod % 10; // same time digit update kar diya\n            carry = prod / 10;\n        }\n        while (carry){\n            digits.push_back(carry % 10);\n            carry /= 10;\n        }\n    };\n\n    for (int i = 2; i &lt;= A; ++i) // multiply sabkuch from 2 to A\n    {\n        multiply(i); // multiple every number into 2\n    }\n    string s;\n    // put all the digits into a string\n    for (auto it = digits.rbegin(); it != digits.rend(); ++it){\n        s.push_back('0' + *it); \n    }\n    return s;\n}\n</code></pre>"},{"location":"DSAyy/arrays/#max-non-negative-subarray","title":"Max Non-Negative Subarray","text":""},{"location":"DSAyy/arrays/#question-kya-hai_1","title":"Question kya hai","text":"<p>Array A of N integers, find the subarray with max sum. agar tied, choose the longer one. still tied? smallest starting index</p> <p>Sunn BEHENCHOD, Subarray means continuous, sab kuch subsequence nahi hota</p>"},{"location":"DSAyy/arrays/#karna-kaise-hai","title":"Karna kaise hai","text":"<p>kadane kadane khelenge agar negative number mila, that is where we stop and process the answer. By process i mean, bas compare karke check karlenge if its max</p> <p>End meh bhi ek baar check kar lena coz when the loop ends, ek baar remaining computation bhi toh update karni hai.</p> <pre><code>vector&lt;int&gt; maxSet(vector&lt;int&gt; &amp;A){\n    int n = A.size();\n    long long bestSum = -1, curSum = 0;\n    int bestStart = 0, bestEnd = -1, bestLen = 0;\n    int curStart = 0;\n    for (int i = 0; i &lt; n; ++i){\n        if (A[i] &gt;= 0)\n            curSum += A[i];\n        else {\n            int curLen = i - curStart;\n            if (curSum &gt; bestSum || (curSum == bestSum &amp;&amp; curLen &gt; bestLen)){\n                bestSum = curSum;\n                bestStart = curStart;\n                bestEnd = i - 1;\n                bestLen = curLen;\n            }\n            curSum = 0;\n            curStart = i+1;\n        }\n    }\n    if (curStart &lt; n){\n        int curLen = n - curStart;\n        if (curSum &gt; bestSum || (curSum == bestSum &amp;&amp; curLen &gt; bestLen)){\n            bestSum = curSum;\n            bestStart = curStart;\n            bestEnd = n - 1;\n            bestLen = curLen;\n        }\n    }\n    if (bestEnd &lt; bestStart) return {};\n    return vector&lt;int&gt;(A.begin()+bestStart, A.begin()+bestEnd + 1);\n}\n</code></pre> <p>Time complexity is O(n), space complexity is O(1)</p>"},{"location":"DSAyy/arrays/#pick-from-both-sides","title":"Pick from Both Sides","text":"<p>Array A of N elements. Pick exactly B elements from either left ya right end, and just get the max sum.</p>"},{"location":"DSAyy/arrays/#karna-kaise-hai_1","title":"Karna kaise hai","text":"<p>Imagine kar ek sexy sa sliding window, but instead on inside the array, ye saala bahar se aa raha hai. like the right pointer is left meh and left wala is right meh. ye leke bas max sum with B elements karle. Start the right pointer at B - i, and keep the left wala at n - i, and baaju baaju shift and update karte ja. Keep a sum of first B elements, and fir middle se ek hata and right end wala ek daal.</p> <pre><code>int pickBothSides(vector&lt;int&gt; &amp;A, int B){\n    int n = A.size();\n    int window = accumulate(A.begin(), A.begin() + B, 0);\n    int ans = window;\n    for (int i = 1; i &lt;= B; ++i){\n        window = window - A[B-i] + A[n-i];\n        ans = max(ans, window);\n    }\n    return ans;\n}\n</code></pre> <p>Time complexity is O(n) and space complexity is O(1)</p>"},{"location":"DSAyy/dp/","title":"Dynamic Programming","text":"a^2 + b^2 = c^2"},{"location":"DSAyy/graph/","title":"Graphs","text":"a^2 + b^2 = c^2"}]}
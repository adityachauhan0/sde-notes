# N-Queens Problem

## Problem Statement

Given an integer $n$, place $n$ queens on an $n \times n$ chessboard so that no two queens attack each other.

Return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration where `'Q'` and `'.'` indicate a queen and an empty space, respectively.

### Constraints:
- $1 \leq n \leq 9$

---

## Key Insight

A queen attacks all cells in the same:
- row,
- column,
- diagonal (both directions).

We use backtracking to build the solution row by row:
- At each row, try placing a queen in each column
- Skip columns/diagonals that are already under attack
- Use sets to track columns and diagonals in use

---

## Python Code

```python
def solveNQueens(n):
    res = []
    board = [['.'] * n for _ in range(n)]
    cols = set()
    pos_diag = set()  # (r + c)
    neg_diag = set()  # (r - c)

    def backtrack(r):
        if r == n:
            res.append(["".join(row) for row in board])
            return
        for c in range(n):
            if c in cols or (r + c) in pos_diag or (r - c) in neg_diag:
                continue
            board[r][c] = 'Q'
            cols.add(c)
            pos_diag.add(r + c)
            neg_diag.add(r - c)

            backtrack(r + 1)

            board[r][c] = '.'
            cols.remove(c)
            pos_diag.remove(r + c)
            neg_diag.remove(r - c)

    backtrack(0)
    return res
```

# Sudoku Solver

## Problem Statement

Fill a 9×9 Sudoku board so that every row, column, and 3×3 subgrid contains the digits 1 through 9 exactly once.  
Empty cells are represented by `'.'`.

Modify the input board **in-place** to produce the solution.

---

## Key Insight

Sudoku is a classic **constraint satisfaction** problem. We use **backtracking** with these optimizations:

- Track used digits in each **row**, **column**, and **box** using **bitmasks**.
- At each step, pick the empty cell with **minimum available choices** (MRV heuristic).
- Try each valid digit, recurse, and **backtrack** if needed.

---

## Python Code

```python
def solveSudoku(board):
    N = 9
    row_mask = [0] * N
    col_mask = [0] * N
    box_mask = [0] * N
    empties = []

    def get_box(r, c):
        return (r // 3) * 3 + (c // 3)

    for r in range(N):
        for c in range(N):
            if board[r][c] == '.':
                empties.append((r, c))
            else:
                d = int(board[r][c]) - 1
                bit = 1 << d
                row_mask[r] |= bit
                col_mask[c] |= bit
                box_mask[get_box(r, c)] |= bit

    def dfs(idx):
        if idx == len(empties):
            return True

        # MRV heuristic
        best = idx
        min_options = 10
        for i in range(idx, len(empties)):
            r, c = empties[i]
            b = get_box(r, c)
            avail = ~(row_mask[r] | col_mask[c] | box_mask[b]) & 0x1FF
            count = bin(avail).count('1')
            if count < min_options:
                min_options = count
                best = i
                if count == 1:
                    break

        if min_options == 0:
            return False

        empties[idx], empties[best] = empties[best], empties[idx]
        r, c = empties[idx]
        b = get_box(r, c)
        avail = ~(row_mask[r] | col_mask[c] | box_mask[b]) & 0x1FF

        while avail:
            p = avail & -avail
            avail -= p
            d = (p).bit_length() - 1
            board[r][c] = str(d + 1)
            row_mask[r] |= p
            col_mask[c] |= p
            box_mask[b] |= p

            if dfs(idx + 1):
                return True

            board[r][c] = '.'
            row_mask[r] ^= p
            col_mask[c] ^= p
            box_mask[b] ^= p

        empties[idx], empties[best] = empties[best], empties[idx]
        return False

    dfs(0)
```


# Permutations (Backtracking)

## Problem Statement

Given a list of distinct integers $A$, return **all possible permutations** of the elements in any order.

### Example

```python
Input: A = [1, 2, 3]
Output:
[
 [1, 2, 3],
 [1, 3, 2],
 [2, 1, 3],
 [2, 3, 1],
 [3, 1, 2],
 [3, 2, 1]
]
````

---

## Key Insight

Permutations are generated by trying **every number at every position**.

At each recursion level (position in permutation):

- Swap current index with every possible candidate index
    
- Recurse
    
- Swap back (backtrack)
    

This is an **in-place backtracking** strategy.

---

## Python Code

```python
def permute(nums):
    res = []
    n = len(nums)

    def backtrack(idx):
        if idx == n:
            res.append(nums[:])
            return
        for i in range(idx, n):
            nums[i], nums[idx] = nums[idx], nums[i]
            backtrack(idx + 1)
            nums[i], nums[idx] = nums[idx], nums[i]

    backtrack(0)
    return res
```

---


# Generate All Parentheses (Well-Formed Combinations)

## Problem Statement

Given an integer $n$, generate all combinations of **well-formed parentheses** consisting of $n$ pairs.

### Example

```python
Input: n = 3
Output: [
 "((()))",
 "(()())",
 "(())()",
 "()(())",
 "()()()"
]
````

---

## Crazy insight

A valid parentheses sequence must:

- Never have more `)` than `(` at any point
    
- Contain exactly $n$ `(` and $n$ `)`
    

We use **backtracking** to build the string:

- Add `(` if we still have some left
    
- Add `)` only if it doesn't exceed `(` used so far
    

---

## Python Code

```python
def generateParenthesis(n):
    res = []

    def backtrack(open_count, close_count, current):
        if len(current) == 2 * n:
            res.append(current)
            return
        if open_count < n:
            backtrack(open_count + 1, close_count, current + '(')
        if close_count < open_count:
            backtrack(open_count, close_count + 1, current + ')')

    backtrack(0, 0, "")
    return res
```

---

## Example

```python
generateParenthesis(2)
# Output: ["(())", "()()"]
```

---

## Time & Space Complexity

- **Time:** $O(2^{2n})$ in the worst case (each position has 2 choices), but pruned by constraints
    
- **Space:** $O(n)$ recursion depth; output size is Catalan number $C_n$
    

---

# Palindrome Partitioning

## Problem Statement

Given a string $s$, partition it such that **every substring** in the partition is a **palindrome**.

Return all possible palindrome partitionings of $s$.

### Example

```python
Input: s = "aab"
Output: [
 ["a", "a", "b"],
 ["aa", "b"]
]
````

---

## Key Insight

Use **backtracking** to explore all substring partitions.

At each index:

- Try all substrings `s[i:j+1]`
    
- If it's a palindrome, add it to current path and recurse
    
- Backtrack and try the next cut
    

To speed up palindrome checks, precompute a **2D table** `is_pal[i][j]` that tells whether `s[i:j+1]` is a palindrome.

---

## Python Code

```python
def partition(s):
    n = len(s)
    res = []
    is_pal = [[False]*n for _ in range(n)]

    for l in range(1, n + 1):
        for i in range(n - l + 1):
            j = i + l - 1
            if s[i] == s[j] and (l <= 2 or is_pal[i+1][j-1]):
                is_pal[i][j] = True

    def backtrack(start, path):
        if start == n:
            res.append(path[:])
            return
        for end in range(start, n):
            if is_pal[start][end]:
                path.append(s[start:end+1])
                backtrack(end + 1, path)
                path.pop()

    backtrack(0, [])
    return res
```

---

## Example

```python
partition("aab")
# Output: [["a", "a", "b"], ["aa", "b"]]
```

---

## Time & Space Complexity

- **Time:** $O(2^n \cdot n)$ in worst case (exponential partitions with substring checks)
    
- **Space:** $O(n^2)$ for `is_pal` table and recursion
    

---

# Letter Combinations of a Phone Number

## Problem Statement

Given a string of digits from 0–9, return all possible letter combinations based on **telephone keypad mapping**.

### Digit to Letter Mapping:

```

2 → abc 3 → def  
4 → ghi 5 → jkl  
6 → mno 7 → pqrs  
8 → tuv 9 → wxyz  
0 → 0 1 → 1

````

### Example

```python
Input: digits = "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]
````

---

## BC Insight

This is a **Cartesian product** of characters mapped from each digit.

Use **backtracking** to build all combinations:

- At each index, try every letter for the current digit
    
- Recurse to the next digit
    
- When complete, add to result
    

---

## Python Code

```python
def letterCombinations(digits):
    if not digits:
        return []

    mapping = [
        "0", "1", "abc", "def", "ghi",
        "jkl", "mno", "pqrs", "tuv", "wxyz"
    ]

    res = []

    def backtrack(idx, path):
        if idx == len(digits):
            res.append("".join(path))
            return
        for c in mapping[int(digits[idx])]:
            path.append(c)
            backtrack(idx + 1, path)
            path.pop()

    backtrack(0, [])
    return res
```

---

## Example

```python
letterCombinations("2")
# Output: ["a", "b", "c"]
```

---

## Time & Space Complexity

- **Time:** $O(4^n)$ where $n$ is length of input (max 4 letters per digit)
    
- **Space:** $O(n)$ for recursion stack
    

---

# Gray Code Sequence

## Problem Statement

Given a non-negative integer $n$, generate the **Gray code sequence** of length $2^n$ starting from $0$.

In Gray code, two successive values differ in only **one bit**.

### Example

```python
Input: n = 2
Output: [0, 1, 3, 2]
````

Explanation:

- Binary of 0: 00
    
- Binary of 1: 01
    
- Binary of 3: 11
    
- Binary of 2: 10  
    Each step differs from the previous by exactly one bit.
    

---

## Shizuka Insight

There are two main methods to generate Gray codes:

1. **Backtracking / Reflection** (not used here):
    
    - For $n$ bits: prepend `0` to Gray codes of $n-1$ bits, then prepend `1` to their reverse
        
2. **Direct Formula** (used here):
    
    - The $i^{\text{th}}$ Gray code:
        
        $gray(i)=i⊕(i≫1)\text{gray}(i) = i \oplus (i \gg 1)$

---

## Python Code

```python
def grayCode(n):
    result = []
    for i in range(1 << n):  # 0 to 2^n - 1
        result.append(i ^ (i >> 1))
    return result
```

---

## Example

```python
grayCode(3)
# Output: [0, 1, 3, 2, 6, 7, 5, 4]
```

---

## Time & Space Complexity

- **Time:** $O(2^n)$ for generating all values
    
- **Space:** $O(2^n)$ for storing the sequence
    

---


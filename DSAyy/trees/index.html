
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../graph/">
      
      
        <link rel="next" href="../TwoPointers/">
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.14">
    
    
      
        <title>Trees - SDE Prep A2Z</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.342714a4.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../styles/custom.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
    html.glightbox-open { overflow: initial; height: 100%; }
    .gslide-title { margin-top: 0px; user-select: text; }
    .gslide-desc { color: #666; user-select: text; }
    .gslide-image img { background: white; }
    .gscrollbar-fixer { padding-right: 15px; }
    .gdesc-inner { font-size: 0.75rem; }
    body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
    body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
    body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}</style> <script src="../../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#next-greater-number-in-bst" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="SDE Prep A2Z" class="md-header__button md-logo" aria-label="SDE Prep A2Z" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            SDE Prep A2Z
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Trees
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="deep-purple" data-md-color-accent="deep-purple"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_2" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="dracula" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Dracula Mode"  type="radio" name="__palette" id="__palette_2">
    
      <label class="md-header__button md-icon" title="Dracula Mode" for="__palette_3" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2a9 9 0 0 0-9 9v11l3-3 3 3 3-3 3 3 3-3 3 3V11a9 9 0 0 0-9-9M9 8a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2 2 2 0 0 1 2-2m6 0a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2 2 2 0 0 1 2-2"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="neon" data-md-color-primary="lime" data-md-color-accent="pink"  aria-label="Neon Pulse Mode"  type="radio" name="__palette" id="__palette_3">
    
      <label class="md-header__button md-icon" title="Neon Pulse Mode" for="__palette_4" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11h3v2h-3zM1 11h3v2H1zM13 1v3h-2V1zM4.92 3.5l2.13 2.14-1.42 1.41L3.5 4.93zm12.03 2.13 2.12-2.13 1.43 1.43-2.13 2.12zM12 6a6 6 0 0 1 6 6c0 2.22-1.21 4.16-3 5.2V19a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1v-1.8c-1.79-1.04-3-2.98-3-5.2a6 6 0 0 1 6-6m2 15v1a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1v-1zm-3-3h2v-2.13c1.73-.44 3-2.01 3-3.87a4 4 0 0 0-4-4 4 4 0 0 0-4 4c0 1.86 1.27 3.43 3 3.87z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="cyberpunk" data-md-color-primary="yellow" data-md-color-accent="light-blue"  aria-label="Cyberpunk Mode"  type="radio" name="__palette" id="__palette_4">
    
      <label class="md-header__button md-icon" title="Cyberpunk Mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2a2 2 0 0 1 2 2c0 .74-.4 1.39-1 1.73V7h1a7 7 0 0 1 7 7h1a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1h-1v1a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-1H2a1 1 0 0 1-1-1v-3a1 1 0 0 1 1-1h1a7 7 0 0 1 7-7h1V5.73c-.6-.34-1-.99-1-1.73a2 2 0 0 1 2-2M7.5 13A2.5 2.5 0 0 0 5 15.5 2.5 2.5 0 0 0 7.5 18a2.5 2.5 0 0 0 2.5-2.5A2.5 2.5 0 0 0 7.5 13m9 0a2.5 2.5 0 0 0-2.5 2.5 2.5 2.5 0 0 0 2.5 2.5 2.5 2.5 0 0 0 2.5-2.5 2.5 2.5 0 0 0-2.5-2.5"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
          <a href="javascript:void(0)" class="md-search__icon md-icon" title="Share" aria-label="Share" data-clipboard data-clipboard-text="" data-md-component="search-share" tabindex="-1">
            
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"/></svg>
          </a>
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../.." class="md-tabs__link">
        
  
  
    
  
  Home

      </a>
    </li>
  

      
        
  
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../arrays/" class="md-tabs__link">
          
  
  
  DSA

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="SDE Prep A2Z" class="md-nav__button md-logo" aria-label="SDE Prep A2Z" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    SDE Prep A2Z
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
      
        
        
      
      
        
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="">
            
  
  
  <span class="md-ellipsis">
    DSA
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            DSA
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../arrays/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Arrays
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../dp/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Dynamic Programming
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../graph/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Graphs
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    Trees
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Trees
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#next-greater-number-in-bst" class="md-nav__link">
    <span class="md-ellipsis">
      Next Greater Number in BST
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Next Greater Number in BST">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#valid-bst-from-preorder" class="md-nav__link">
    <span class="md-ellipsis">
      Valid BST from PreOrder
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Valid BST from PreOrder">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_1" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#kth-smallest-element-in-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Kth Smallest Element in Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Kth Smallest Element in Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_2" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-sum-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      2-Sum Binary Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="2-Sum Binary Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_3" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bst-iterator" class="md-nav__link">
    <span class="md-ellipsis">
      BST Iterator
    </span>
  </a>
  
    <nav class="md-nav" aria-label="BST Iterator">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_4" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#recover-binary-search-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Recover Binary Search Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Recover Binary Search Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_5" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#xor-between-two-arrays" class="md-nav__link">
    <span class="md-ellipsis">
      Xor Between Two Arrays
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Xor Between Two Arrays">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_6" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#hotel-reviews" class="md-nav__link">
    <span class="md-ellipsis">
      Hotel Reviews
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Hotel Reviews">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_7" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shortest-unique-prefix" class="md-nav__link">
    <span class="md-ellipsis">
      Shortest Unique Prefix
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Shortest Unique Prefix">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_8" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#path-to-given-node" class="md-nav__link">
    <span class="md-ellipsis">
      Path to Given Node
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Path to Given Node">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_9" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#remove-half-nodes" class="md-nav__link">
    <span class="md-ellipsis">
      Remove Half Nodes
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Remove Half Nodes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_10" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#nodes-at-distance-k" class="md-nav__link">
    <span class="md-ellipsis">
      Nodes at distance K
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Nodes at distance K">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_11" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#last-node-in-a-complete-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Last Node in a complete binary tree.
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Last Node in a complete binary tree.">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_12" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#consecutive-parent-child" class="md-nav__link">
    <span class="md-ellipsis">
      Consecutive Parent-Child
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Consecutive Parent-Child">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_13" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#balanced-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Balanced Binary Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Balanced Binary Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_14" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#maximum-edge-removal" class="md-nav__link">
    <span class="md-ellipsis">
      Maximum Edge Removal
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Maximum Edge Removal">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_15" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#merge-binary-trees" class="md-nav__link">
    <span class="md-ellipsis">
      Merge Binary Trees
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Merge Binary Trees">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_16" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#symmetric-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Symmetric Binary Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Symmetric Binary Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_17" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#identical-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Identical Binary Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Identical Binary Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_18" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#construct-bst-from-preorder" class="md-nav__link">
    <span class="md-ellipsis">
      Construct BST from PreOrder
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Construct BST from PreOrder">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_19" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#inorder-traversal-of-a-cartesian-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Inorder Traversal Of a Cartesian Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Inorder Traversal Of a Cartesian Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_20" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sorted-array-to-balanced-bst" class="md-nav__link">
    <span class="md-ellipsis">
      Sorted Array to Balanced BST
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Sorted Array to Balanced BST">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_21" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#construct-binary-tree-from-inorder-and-preorder" class="md-nav__link">
    <span class="md-ellipsis">
      Construct Binary Tree from Inorder and preorder
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Construct Binary Tree from Inorder and preorder">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_22" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#binary-tree-from-inorder-and-postorder" class="md-nav__link">
    <span class="md-ellipsis">
      Binary Tree from Inorder and PostOrder
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Binary Tree from Inorder and PostOrder">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_23" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vertical-order-traversal-of-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Vertical Order Traversal of Binary Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Vertical Order Traversal of Binary Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_24" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#diagonal-traversal-of-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Diagonal Traversal Of Binary Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Diagonal Traversal Of Binary Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_25" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vertical-sum-of-a-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Vertical Sum of a Binary Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Vertical Sum of a Binary Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_26" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#covered-uncovered-nodes" class="md-nav__link">
    <span class="md-ellipsis">
      Covered / Uncovered Nodes
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Covered / Uncovered Nodes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_27" class="md-nav__link">
    <span class="md-ellipsis">
      how
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#inorder-traversal-of-a-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Inorder Traversal of A Binary Tree
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#preorder-traversal-of-a-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Preorder Traversal Of a Binary Tree
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#postorder-traversal-of-a-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      PostOrder Traversal Of a binary Tree
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#right-view-of-a-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Right view of a binary tree
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cousins-in-a-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Cousins in a binary tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Cousins in a binary tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_28" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#reverse-level-order-traversal-of-a-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Reverse Level Order Traversal of a Binary Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Reverse Level Order Traversal of a Binary Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_29" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#zigzag-level-order" class="md-nav__link">
    <span class="md-ellipsis">
      Zigzag Level Order
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#populate-next-right-pointers-in-a-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Populate Next Right Pointers in a Binary Tree
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#burn-a-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Burn a Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Burn a Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_30" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#max-depth-of-a-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Max Depth of a Binary Tree
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sum-root-to-leaf-numbers" class="md-nav__link">
    <span class="md-ellipsis">
      Sum Root to Leaf Numbers
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#path-sum" class="md-nav__link">
    <span class="md-ellipsis">
      Path Sum
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#min-depth-of-a-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Min Depth of a Binary Tree
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#root-to-leaf-paths-with-sum" class="md-nav__link">
    <span class="md-ellipsis">
      Root to leaf paths with sum
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#invert-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Invert Binary Tree
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#least-common-ancestor-in-a-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Least Common Ancestor in a Binary Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Least Common Ancestor in a Binary Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_31" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#flatten-binary-tree-to-linked-list" class="md-nav__link">
    <span class="md-ellipsis">
      Flatten Binary tree to Linked List
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#order-of-peoples-heights" class="md-nav__link">
    <span class="md-ellipsis">
      Order of People's Heights
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Order of People&#39;s Heights">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_32" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../TwoPointers/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Two Pointers
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#next-greater-number-in-bst" class="md-nav__link">
    <span class="md-ellipsis">
      Next Greater Number in BST
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Next Greater Number in BST">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#valid-bst-from-preorder" class="md-nav__link">
    <span class="md-ellipsis">
      Valid BST from PreOrder
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Valid BST from PreOrder">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_1" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#kth-smallest-element-in-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Kth Smallest Element in Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Kth Smallest Element in Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_2" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-sum-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      2-Sum Binary Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="2-Sum Binary Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_3" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bst-iterator" class="md-nav__link">
    <span class="md-ellipsis">
      BST Iterator
    </span>
  </a>
  
    <nav class="md-nav" aria-label="BST Iterator">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_4" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#recover-binary-search-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Recover Binary Search Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Recover Binary Search Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_5" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#xor-between-two-arrays" class="md-nav__link">
    <span class="md-ellipsis">
      Xor Between Two Arrays
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Xor Between Two Arrays">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_6" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#hotel-reviews" class="md-nav__link">
    <span class="md-ellipsis">
      Hotel Reviews
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Hotel Reviews">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_7" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shortest-unique-prefix" class="md-nav__link">
    <span class="md-ellipsis">
      Shortest Unique Prefix
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Shortest Unique Prefix">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_8" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#path-to-given-node" class="md-nav__link">
    <span class="md-ellipsis">
      Path to Given Node
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Path to Given Node">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_9" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#remove-half-nodes" class="md-nav__link">
    <span class="md-ellipsis">
      Remove Half Nodes
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Remove Half Nodes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_10" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#nodes-at-distance-k" class="md-nav__link">
    <span class="md-ellipsis">
      Nodes at distance K
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Nodes at distance K">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_11" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#last-node-in-a-complete-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Last Node in a complete binary tree.
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Last Node in a complete binary tree.">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_12" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#consecutive-parent-child" class="md-nav__link">
    <span class="md-ellipsis">
      Consecutive Parent-Child
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Consecutive Parent-Child">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_13" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#balanced-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Balanced Binary Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Balanced Binary Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_14" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#maximum-edge-removal" class="md-nav__link">
    <span class="md-ellipsis">
      Maximum Edge Removal
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Maximum Edge Removal">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_15" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#merge-binary-trees" class="md-nav__link">
    <span class="md-ellipsis">
      Merge Binary Trees
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Merge Binary Trees">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_16" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#symmetric-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Symmetric Binary Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Symmetric Binary Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_17" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#identical-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Identical Binary Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Identical Binary Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_18" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#construct-bst-from-preorder" class="md-nav__link">
    <span class="md-ellipsis">
      Construct BST from PreOrder
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Construct BST from PreOrder">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_19" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#inorder-traversal-of-a-cartesian-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Inorder Traversal Of a Cartesian Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Inorder Traversal Of a Cartesian Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_20" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sorted-array-to-balanced-bst" class="md-nav__link">
    <span class="md-ellipsis">
      Sorted Array to Balanced BST
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Sorted Array to Balanced BST">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_21" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#construct-binary-tree-from-inorder-and-preorder" class="md-nav__link">
    <span class="md-ellipsis">
      Construct Binary Tree from Inorder and preorder
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Construct Binary Tree from Inorder and preorder">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_22" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#binary-tree-from-inorder-and-postorder" class="md-nav__link">
    <span class="md-ellipsis">
      Binary Tree from Inorder and PostOrder
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Binary Tree from Inorder and PostOrder">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_23" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vertical-order-traversal-of-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Vertical Order Traversal of Binary Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Vertical Order Traversal of Binary Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_24" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#diagonal-traversal-of-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Diagonal Traversal Of Binary Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Diagonal Traversal Of Binary Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_25" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vertical-sum-of-a-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Vertical Sum of a Binary Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Vertical Sum of a Binary Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_26" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#covered-uncovered-nodes" class="md-nav__link">
    <span class="md-ellipsis">
      Covered / Uncovered Nodes
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Covered / Uncovered Nodes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_27" class="md-nav__link">
    <span class="md-ellipsis">
      how
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#inorder-traversal-of-a-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Inorder Traversal of A Binary Tree
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#preorder-traversal-of-a-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Preorder Traversal Of a Binary Tree
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#postorder-traversal-of-a-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      PostOrder Traversal Of a binary Tree
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#right-view-of-a-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Right view of a binary tree
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cousins-in-a-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Cousins in a binary tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Cousins in a binary tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_28" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#reverse-level-order-traversal-of-a-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Reverse Level Order Traversal of a Binary Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Reverse Level Order Traversal of a Binary Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_29" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#zigzag-level-order" class="md-nav__link">
    <span class="md-ellipsis">
      Zigzag Level Order
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#populate-next-right-pointers-in-a-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Populate Next Right Pointers in a Binary Tree
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#burn-a-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Burn a Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Burn a Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_30" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#max-depth-of-a-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Max Depth of a Binary Tree
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sum-root-to-leaf-numbers" class="md-nav__link">
    <span class="md-ellipsis">
      Sum Root to Leaf Numbers
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#path-sum" class="md-nav__link">
    <span class="md-ellipsis">
      Path Sum
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#min-depth-of-a-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Min Depth of a Binary Tree
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#root-to-leaf-paths-with-sum" class="md-nav__link">
    <span class="md-ellipsis">
      Root to leaf paths with sum
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#invert-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Invert Binary Tree
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#least-common-ancestor-in-a-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Least Common Ancestor in a Binary Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Least Common Ancestor in a Binary Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_31" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#flatten-binary-tree-to-linked-list" class="md-nav__link">
    <span class="md-ellipsis">
      Flatten Binary tree to Linked List
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#order-of-peoples-heights" class="md-nav__link">
    <span class="md-ellipsis">
      Order of People's Heights
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Order of People&#39;s Heights">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#how_32" class="md-nav__link">
    <span class="md-ellipsis">
      How
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



  <h1>Trees</h1>

<h2 id="next-greater-number-in-bst">Next Greater Number in BST<a class="headerlink" href="#next-greater-number-in-bst" title="Permanent link">&para;</a></h2>
<p>Given a BST Node, return the node which has val greater than given node.</p>
<h3 id="how">How<a class="headerlink" href="#how" title="Permanent link">&para;</a></h3>
<p>This is basically finding inorder sucessor.</p>
<p>For finding node with val just &gt; B,</p>
<ol>
<li>While searching for node with val B, whenever we move to left child, curr node is candidate for successor. We record that candidate and move ahead.</li>
<li>Once we find the node with val B:<ol>
<li>If N has a right subtree, then the sucessor is the leftmost node in the right subtree.</li>
<li>Else sucessor is the latest recorded ancestor (candidate)</li>
</ol>
</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">def</span><span class="w"> </span><span class="nf">inorder_sucessor</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="n">target</span><span class="p">):</span>
    <span class="n">successor</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1">#search for node while tracking sucessors</span>
    <span class="k">while</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
            <span class="n">successor</span> <span class="o">=</span> <span class="n">root</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span>
        <span class="k">elif</span> <span class="n">target</span><span class="o">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span> <span class="c1"># found root</span>
    <span class="k">if</span> <span class="n">target</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
        <span class="n">successor</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">right</span>
        <span class="k">while</span> <span class="n">successor</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
            <span class="n">successor</span> <span class="o">=</span> <span class="n">successor</span><span class="o">.</span><span class="n">left</span>
    <span class="k">return</span> <span class="n">successor</span>
</code></pre></div>
<h2 id="valid-bst-from-preorder">Valid BST from PreOrder<a class="headerlink" href="#valid-bst-from-preorder" title="Permanent link">&para;</a></h2>
<p>Given and int arr A representing a preorder traversal of a BST.</p>
<p>Determine if A can correspond to the preorder traversal of some valid BST.</p>
<p>$$
(\text{left subtree keys}) &lt; (\text{node key}) &lt; (\text{right subtree keys})
$$
Return if its a valid preorder of BST. </p>
<h3 id="how_1">How<a class="headerlink" href="#how_1" title="Permanent link">&para;</a></h3>
<p>A valid preorder of BST would have {root, left subtree, right subtree} order.</p>
<p>Each new preorder value should:
1. Be strictly greater than some lower bound
2. Fit into a position consistent with BST constraints implied previously</p>
<p>We can simulate building the BST without constructing it by
1. A stack to track the chain of ancestors for which we have not yet assigned a right child.
2. A lower_bound variable that tracks the smallest permissible value for the current node (once we pop from the stack, that popped value becomes the new lower bound)
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">is_valid_bst_preorder</span><span class="p">(</span><span class="n">preorder</span><span class="p">):</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">lower_bound</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;-inf&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">preorder</span><span class="p">:</span>
        <span class="c1">#val must be greater than the lowest allowed val (left subtree needs a right)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">lower_bound</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1">#nodes popped mean we are in the right subtree now</span>
        <span class="k">while</span> <span class="n">stack</span> <span class="ow">and</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1">#pop all right subtree val</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">True</span>
</code></pre></div></p>
<h2 id="kth-smallest-element-in-tree">Kth Smallest Element in Tree<a class="headerlink" href="#kth-smallest-element-in-tree" title="Permanent link">&para;</a></h2>
<p>Given a BST, write a func to find the Kth smallest element in the tree.</p>
<h3 id="how_2">How<a class="headerlink" href="#how_2" title="Permanent link">&para;</a></h3>
<p>The Kth smallest element is just the Kth element in the inorder traversal
1. Traverse BST iteratively using a stack to simulate recursion.
2. Always push left children onto the stack until we reach a null
3. Pop one node at a time, each pop node corresponds to the next smallest element in the sorted order.
4. Maintain a counter, when counter reaches k, return the popped value</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">def</span><span class="w"> </span><span class="nf">kth_smallest</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="n">k</span><span class="p">):</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">root</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1">#go as left as possible</span>
        <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">left</span>
        <span class="c1">#pop from stack</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">current</span><span class="o">.</span><span class="n">val</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">right</span>
</code></pre></div>
<h2 id="2-sum-binary-tree">2-Sum Binary Tree<a class="headerlink" href="#2-sum-binary-tree" title="Permanent link">&para;</a></h2>
<p>Given a BST, and an int B. Determine whether there are 2 distinct nodes X and Y in the tree such that
$$
X.val + Y.val = B
$$</p>
<h3 id="how_3">How<a class="headerlink" href="#how_3" title="Permanent link">&para;</a></h3>
<p>Normally we use 2 pointer in a sorted array, we need to simulate this in BST.
1. An inorder iterator (left to right) that yields val in asc order.
2. A reverse-inorder iterator (right to left) that yields val in des order.</p>
<p>Both iterators can be implemented with a stack
1. Init <span class="arithmatex">\(next-smallest\)</span> stack by pushing all left descendents from root down to leftmost node.
2. Init <span class="arithmatex">\(next-largest\)</span> stack by pushing all right descendents from root down to rightmost node.
3. getNext(): Pop from <span class="arithmatex">\(s_1\)</span> call that node's val <span class="arithmatex">\(v\)</span> . Then if that node has a right child, push its right child and all of that child's left descendents onto <span class="arithmatex">\(s_1\)</span> . Return v.
4. getPrev(): Pop from <span class="arithmatex">\(s_2\)</span> , Call that node's val <span class="arithmatex">\(u\)</span>. Then if that node has a left child, push its left child and all of its right descendents into <span class="arithmatex">\(s_2\)</span> Return u. </p>
<p>Then have a two-pointer loop. leftVal would be getNext(), rightVal would be getPrev(). Then normal 2 pointer approach.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BSTIterator</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">root</span><span class="p">,</span><span class="n">forward</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forward</span> <span class="o">=</span> <span class="n">forward</span> <span class="c1">#true is next val, false for prev</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__push_all</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__push_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
        <span class="k">while</span> <span class="n">node</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward</span> <span class="k">else</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__push_all</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__push_all</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="k">def</span><span class="w"> </span><span class="nf">find_target</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="n">k</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>
    <span class="n">left_iter</span> <span class="o">=</span> <span class="n">BSTIterator</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">right_iter</span> <span class="o">=</span> <span class="n">BSTIterator</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">left_val</span> <span class="o">=</span> <span class="n">left_iter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
    <span class="n">right_val</span> <span class="o">=</span> <span class="n">right_iter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
    <span class="k">while</span> <span class="n">left_val</span> <span class="o">&lt;</span> <span class="n">right_val</span><span class="p">:</span>
        <span class="n">cur_sum</span> <span class="o">=</span> <span class="n">left_val</span> <span class="o">+</span> <span class="n">right_val</span>
        <span class="k">if</span> <span class="n">cur_sum</span> <span class="o">==</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">cur_sum</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">left_iter</span><span class="o">.</span><span class="n">has_next</span><span class="p">():</span>
                <span class="n">left_val</span> <span class="o">=</span> <span class="n">left_iter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span> 
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">right_iter</span><span class="o">.</span><span class="n">has_next</span><span class="p">():</span>
                <span class="n">right_val</span> <span class="o">=</span> <span class="n">right_iter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
    <span class="k">return</span> <span class="kc">False</span>
</code></pre></div>
<h2 id="bst-iterator">BST Iterator<a class="headerlink" href="#bst-iterator" title="Permanent link">&para;</a></h2>
<p>Implement an iterator over a BST. Iterator is init with root of BST.
1. next() return the next smallest number in the BST
2. hasNext() return true if there is a next smallest number, otherwise false</p>
<h3 id="how_4">How<a class="headerlink" href="#how_4" title="Permanent link">&para;</a></h3>
<p>Abhi just toh kiya upar</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BSTIterator</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">root</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_push_left</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_push_left</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
        <span class="k">while</span> <span class="n">node</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_push_left</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">hasNext</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>       
</code></pre></div>
<h2 id="recover-binary-search-tree">Recover Binary Search Tree<a class="headerlink" href="#recover-binary-search-tree" title="Permanent link">&para;</a></h2>
<p>Two nodes of a BST are swapped by mistake. Identify which, and swap them back.
Return a two-element list <span class="arithmatex">\([v_1, v_2]\)</span> in asc order, wherte swapping <span class="arithmatex">\(v_1\)</span> and <span class="arithmatex">\(v_2\)</span> corrects the tree.</p>
<h3 id="how_5">How<a class="headerlink" href="#how_5" title="Permanent link">&para;</a></h3>
<p>A correct BST inorder traversal produces a strictly increasing seq of node values.
If  2 nodes are swapped, their inorder will have exactly one or two inversions.</p>
<ol>
<li>Case 1 (Non-adjacent swap): 2 inversions occur. First pair identifies the first wrong node, and second identifies the second wrong node.</li>
<li>Case 2 (adjacent swap): Exactly one inversion occurs; just swap the 2 nodes in the inversion.</li>
</ol>
<p>Perform a Morris inorder traversal, with <span class="arithmatex">\(O(1)\)</span> space. Keep track of prev pointer. Whenever <span class="arithmatex">\(prev.val &gt; curr.val\)</span>, we found an inversion.</p>
<p>If first inversion, first = prev, second = curr, if second, second = curr</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">def</span><span class="w"> </span><span class="nf">recover_bst</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="n">first</span> <span class="o">=</span> <span class="n">second</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">root</span>
    <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">current</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
            <span class="c1"># check for inversion</span>
            <span class="k">if</span> <span class="n">prev</span> <span class="ow">and</span> <span class="n">prev</span><span class="o">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">current</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">first</span><span class="p">:</span>
                    <span class="n">first</span> <span class="o">=</span> <span class="n">prev</span>
                <span class="n">second</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">right</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># morris traversal setup</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">left</span>
            <span class="k">while</span> <span class="n">pred</span><span class="o">.</span><span class="n">right</span> <span class="ow">and</span> <span class="n">pred</span><span class="o">.</span><span class="n">right</span> <span class="o">!=</span> <span class="n">current</span><span class="p">:</span>
                <span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">right</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pred</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">pred</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">current</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">left</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pred</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">prev</span> <span class="ow">and</span> <span class="n">prev</span><span class="o">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">current</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">first</span><span class="p">:</span>
                        <span class="n">first</span> <span class="o">=</span> <span class="n">prev</span>
                    <span class="n">second</span> <span class="o">=</span> <span class="n">current</span>
                <span class="n">prev</span> <span class="o">=</span> <span class="n">current</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">right</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">first</span><span class="o">.</span><span class="n">val</span><span class="p">,</span><span class="n">second</span><span class="o">.</span><span class="n">val</span><span class="p">])</span>
</code></pre></div>
<h2 id="xor-between-two-arrays">Xor Between Two Arrays<a class="headerlink" href="#xor-between-two-arrays" title="Permanent link">&para;</a></h2>
<p>Given two Int arrays A and B. Pick one element <span class="arithmatex">\(a \in\)</span> A and one element <span class="arithmatex">\(b\in\)</span> B so to maximie the val of <span class="arithmatex">\(a \oplus b\)</span>  Where <span class="arithmatex">\(\oplus\)</span> is bitwise XOR. </p>
<p>Return this max XOR value.</p>
<p>Example: A = 1 2 3, B = 4 1 2. Max is <span class="arithmatex">\(3 \oplus 4\)</span> which is 7</p>
<h3 id="how_6">How<a class="headerlink" href="#how_6" title="Permanent link">&para;</a></h3>
<p>We can insert all elements of A into a Binary Trie, instead of manually checking all the values.</p>
<p>Insert all element <span class="arithmatex">\(a \in A\)</span>  into binary trie (a bitwise trie), and then, for each b <span class="arithmatex">\(\in\)</span> B, walk the trie greedily to pick bits that maximise <span class="arithmatex">\(b \oplus a\)</span> .</p>
<p>Represent each int in 31 bits, and build a binary trie of depth 31, where each node has two children, <span class="arithmatex">\(<span class="arithmatex">\(child[0] \space \text{  bit = 0}, \text{ child[1]     
bit = 1}\)</span>\)</span>
Inserting an int x simply means descending from root, examining bits and creating child pointers as needed.</p>
<p>To query <span class="arithmatex">\(b \in B\)</span> , we walk the root, and at bit index <span class="arithmatex">\(i\)</span> , we know b's ith bit is <span class="arithmatex">\(b_i\)</span> . To maximise <span class="arithmatex">\(b \oplus a\)</span> at that bit, we would like to pick <span class="arithmatex">\(a_i = 1 - b_i\)</span> if such a branch exists. Otherwise we must follow <span class="arithmatex">\(a_i = b_i\)</span> </p>
<p>Accumulating these chosen bits builds the best possible partner <span class="arithmatex">\(a\)</span> from trie, and we compute (<span class="arithmatex">\(b \oplus a\)</span>).</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TrieNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">child</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span> <span class="c1">#child[0] for bit 0, child[1] for bit 1</span>
<span class="k">def</span><span class="w"> </span><span class="nf">max_xor_between_arrays</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">):</span>
    <span class="c1">#build trie from elements of A</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">TrieNode</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">root</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">bit</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">bit</span><span class="p">]:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">bit</span><span class="p">]</span> <span class="o">=</span> <span class="n">TrieNode</span><span class="p">()</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">bit</span><span class="p">]</span>
    <span class="c1">#step 2</span>
    <span class="n">max_xor</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">B</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">root</span>
        <span class="n">curr_xor</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">bit</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span>
            <span class="n">desired</span> <span class="o">=</span> <span class="n">bit</span> <span class="o">^</span> <span class="mi">1</span> <span class="c1"># opp bit for maximising xor</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">desired</span><span class="p">]:</span>
                <span class="n">curr_xor</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">desired</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">child</span><span class="p">[</span><span class="n">desired</span><span class="p">]</span>
        <span class="n">max_xor</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_xor</span><span class="p">,</span> <span class="n">curr_xor</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">max_xor</span>
</code></pre></div>
<h2 id="hotel-reviews">Hotel Reviews<a class="headerlink" href="#hotel-reviews" title="Permanent link">&para;</a></h2>
<p>Given a string <code>A</code> of good words, separated by <code>_</code> and a vector B of review strings, where sequence of words are also separated by underscore.</p>
<p>Define the goodness value of a review, as the num of words in the review which match one of the good words. Return a vec of original indices of reviews in B, sorted in descending value of Goodness.
If two reviews have same goodness, their relative order must be stable. (preserving original order)</p>
<p>Example: A = cool_ice_wifi, B = {water_is_cool, cold_ice_drink, cool_wifi_speed}
Ans: 2 0 1</p>
<h3 id="how_7">How<a class="headerlink" href="#how_7" title="Permanent link">&para;</a></h3>
<p>Because num of good words and length of review can be large, we cannot compare every word, so we have to build a trie (prefix tree).</p>
<p>Build a trie of all good words:
1. Split string A on '<em>' to extract good word. (length <span class="arithmatex">\(\leq\)</span>  4 in this problem).
2. Insert each good word into a 26-ary trie (one child for each letter 'a'-'z'). And mark the end of a good word with a boolean flag.
3. For each review in B split on '</em>', traverse trie to check if its marked good or not.
4. Count how many tokens appear in the review and that is the goodness val.
5. Finally perform the stable sort by comparing goodness in descending order.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TrieNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_end</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Trie</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">TrieNode</span><span class="p">()</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">word</span><span class="p">):</span>
         <span class="n">cur</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
         <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
             <span class="k">if</span> <span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cur</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                 <span class="n">cur</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="n">TrieNode</span><span class="p">()</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">char</span><span class="p">]</span>
        <span class="n">cur</span><span class="o">.</span><span class="n">is_end</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">word</span><span class="p">);</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cur</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">char</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">cur</span><span class="o">.</span><span class="n">is_end</span>
<span class="k">def</span><span class="w"> </span><span class="nf">hotel_reviews</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">):</span>
    <span class="n">trie</span> <span class="o">=</span> <span class="n">Trie</span><span class="p">()</span>
    <span class="n">good_words</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">good_words</span><span class="p">:</span>
        <span class="n">trie</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
    <span class="n">review_scores</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">review</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
        <span class="n">words</span> <span class="o">=</span> <span class="n">review</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
        <span class="n">score</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span> <span class="k">if</span> <span class="n">trie</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">word</span><span class="p">))</span>
        <span class="n">review_scores</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">score</span><span class="p">,</span><span class="n">index</span><span class="p">))</span>
    <span class="c1"># sort by desc goodness</span>
    <span class="n">review_scores</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="c1">#ret indices</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">idx</span> <span class="ow">in</span> <span class="n">review_scores</span><span class="p">]</span>
</code></pre></div>
<h2 id="shortest-unique-prefix">Shortest Unique Prefix<a class="headerlink" href="#shortest-unique-prefix" title="Permanent link">&para;</a></h2>
<p>Given a list of words (all lowercase with no word being a prefix of the other), find the shortest unique prefix for each word that distinguishes it from all other words in the list.</p>
<p>Example: zebra,dog,duck, dove. -&gt; output z,dog,dy,dov</p>
<p>Simply prefix that no one else has.</p>
<h3 id="how_8">How<a class="headerlink" href="#how_8" title="Permanent link">&para;</a></h3>
<p>We build a prefix tree, of all inputs and store at each node, the number of words that pass through the node (<code>count</code>) . Then:
1. Insert each word into the trie, incrementing <code>count</code> at every node along its path.
2. To find the shortest unique prefix of a word, traverse its path from root, char by char, appending to the prefix string. As soon as we reach a node where the count is 1, the prefix is going to be unique.
3. Because no word is a prefix of other, ans is guaranteed.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TrieNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">#num of words passing through</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Trie</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">TrieNode</span><span class="p">()</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cur</span><span class="o">.</span><span class="n">childrem</span><span class="p">:</span>
                <span class="n">cur</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="n">TrieNode</span><span class="p">()</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">char</span><span class="p">]</span>
            <span class="n">cur</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">word</span><span class="p">):</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">word</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">+=</span> <span class="n">char</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">char</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cur</span><span class="o">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">prefix</span>
        <span class="k">return</span> <span class="n">prefix</span> <span class="c1">#fallback, full word</span>
<span class="k">def</span><span class="w"> </span><span class="nf">shortest_unique_prefix</span><span class="p">(</span><span class="n">words</span><span class="p">):</span>
    <span class="n">trie</span> <span class="o">=</span> <span class="n">Trie</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span> <span class="n">trie</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">trie</span><span class="o">.</span><span class="n">find_prefix</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">]</span>
</code></pre></div>
<h2 id="path-to-given-node">Path to Given Node<a class="headerlink" href="#path-to-given-node" title="Permanent link">&para;</a></h2>
<p>Given a binary tree <code>A</code> with N nodes. Each node has unique int value. And a target <code>B</code>.
Find the path from <code>root</code> to the node whose value is <code>B</code>.</p>
<p>Given a root pointer, return a 1D array with the path from root to B.</p>
<h3 id="how_9">How<a class="headerlink" href="#how_9" title="Permanent link">&para;</a></h3>
<p>A common approach for this is DFS and keeping track of node's parent. Once we discover node <code>B</code>, we can reconstruct the path by walking backwards to the root using <code>parent</code> pointers.
The just reverse the sequence.</p>
<ol>
<li>Init an empty map parent, with <span class="arithmatex">\(nodeValue -&gt; parentValue\)</span></li>
<li>Use an explicit stack to DFS the tree. When we visit a child, record <span class="arithmatex">\(parent[child.val] = current.val\)</span> </li>
<li>As soon as we pop a node who value equals B, stops the DFS, and start reconstructing using the parent chain.</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">path_to_node</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="n">B</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="p">{</span><span class="n">root</span><span class="o">.</span><span class="n">val</span> <span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
    <span class="n">target_node</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">B</span><span class="p">:</span>
            <span class="n">target_node</span><span class="o">=</span> <span class="n">node</span>
            <span class="k">break</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
            <span class="n">parent</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">parent</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">target_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">B</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">B</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">path</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div>
<h2 id="remove-half-nodes">Remove Half Nodes<a class="headerlink" href="#remove-half-nodes" title="Permanent link">&para;</a></h2>
<p>Given a binary tree A with N nodes, remove all half nodes - nodes that have exactly one child- and return the root of the resulting tree. </p>
<p>A leaf should not be removed.</p>
<h3 id="how_10">How<a class="headerlink" href="#how_10" title="Permanent link">&para;</a></h3>
<p>If a node has 2 children, keep it, else if it has one child, bypass it by linking it directly with its non-null child.</p>
<p>A bottom-up traversal (post order?)
1. Recursively process left and right subtrees, so all the half nodes below are already removed.
2. After recursion, examine node <span class="arithmatex">\(u\)</span> :
    1. if u is a leaf, keep it
    2. if it has 2 children, keep it
    3. if it has one child, return <code>u.left</code> or <code>u.right</code> whichever is non-null
3. Recursive call returns the root of the new pruned tree.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">remove_half_nodes</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="kc">None</span>
    <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">remove_half_nodes</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
    <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">remove_half_nodes</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span>
    <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span>
    <span class="k">return</span> <span class="n">root</span>
</code></pre></div>
<h2 id="nodes-at-distance-k">Nodes at distance K<a class="headerlink" href="#nodes-at-distance-k" title="Permanent link">&para;</a></h2>
<p>Given the root of a binary tree <code>A</code>, and a target node value <code>B</code>, and an integer <code>C</code>
Return the array of all nodes that are exactly at distance <code>C</code> from the node with value <code>B</code>. 
You can return ans in any order.</p>
<h3 id="how_11">How<a class="headerlink" href="#how_11" title="Permanent link">&para;</a></h3>
<p>We treat binary tree as an undirected graph. Then we perform a BFS starting from target node, expanding outwards in all three directions (left, right, parent).
After <code>C</code> BFS levels, all nodes in the queue are at distance C.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">deque</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">=</span>  <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">distance_k</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">target_val</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_graph</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">parent</span><span class="p">:</span>
                <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
                <span class="n">graph</span><span class="p">[</span><span class="n">parent</span><span class="o">.</span><span class="n">val</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="n">build_graph</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span><span class="n">node</span><span class="p">)</span>
            <span class="n">build_graph</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
    <span class="n">build_graph</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">target_val</span><span class="p">])</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">target_val</span><span class="p">)</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">queue</span> <span class="ow">and</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
        <span class="n">distance</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
</code></pre></div>
<h2 id="last-node-in-a-complete-binary-tree">Last Node in a complete binary tree.<a class="headerlink" href="#last-node-in-a-complete-binary-tree" title="Permanent link">&para;</a></h2>
<p>Given the root of a complete binary tree A. Return the value of the rightmost node, in the last level of the tree. Aim for better than <span class="arithmatex">\(O(N)\)</span> time.</p>
<h3 id="how_12">How<a class="headerlink" href="#how_12" title="Permanent link">&para;</a></h3>
<p>In a complete binary tree of height <code>h</code>, the last level has indices 0 to <span class="arithmatex">\(2^k - 1\)</span>. </p>
<p>Define <span class="arithmatex">\(exists(idx)\)</span> that checks if a node at index <code>idx</code> exists. To do this, we start at root, and examine the bits of <code>idx</code> from (<code>h-1</code>) floor down to 0. A bit of <code>0</code> means go left, <code>1</code> means go right
. If you never reach <code>NULL</code>, then that <code>index</code> exists. This costs <span class="arithmatex">\(O(h)\)</span> </p>
<p>This is like binary search on <code>idx</code>. </p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_height</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="n">height</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
        <span class="n">height</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span>
    <span class="k">return</span> <span class="n">height</span>
<span class="k">def</span><span class="w"> </span><span class="nf">exists</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">right</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">height</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">height</span><span class="p">):</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span>
<span class="k">def</span><span class="w"> </span><span class="nf">last_node_value</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="kc">None</span>
    <span class="n">height</span> <span class="o">=</span> <span class="n">compute_height</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">height</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span>
    <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">right</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">height</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">#max pos nodes at last level</span>
    <span class="c1"># binary search for last existing node index</span>
    <span class="k">while</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">:</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">exists</span><span class="p">(</span><span class="n">mid</span><span class="p">,</span><span class="n">height</span><span class="p">,</span><span class="n">root</span><span class="p">):</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="c1"># traverse the node at index &#39;right&#39; to get its value</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">right</span>
    <span class="n">node</span><span class="o">=</span> <span class="n">root</span>
    <span class="n">left</span><span class="o">=</span>  <span class="mi">0</span>
    <span class="n">right</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">height</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">height</span><span class="p">):</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span> <span class="k">if</span> <span class="n">node</span> <span class="k">else</span> <span class="kc">None</span>
</code></pre></div>
<h2 id="consecutive-parent-child">Consecutive Parent-Child<a class="headerlink" href="#consecutive-parent-child" title="Permanent link">&para;</a></h2>
<p>Given root of binary tree A, count number of parent-child pais such that their values differ by exactly 1. 
$$
|parent.val - child.val| = 1
$$</p>
<h3 id="how_13">How<a class="headerlink" href="#how_13" title="Permanent link">&para;</a></h3>
<p>Simple tree traversal, (BFS or DFS), For each node:
1. If it has a left child, check if <span class="arithmatex">\(|node.val - node.left.val| = 1,\)</span>  if yes increment the count.
2. Same for the right.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">count_consec_pairs</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">node</span><span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span> <span class="o">-</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span> <span class="o">-</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="n">L</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">count</span>
</code></pre></div>
<h2 id="balanced-binary-tree">Balanced Binary Tree<a class="headerlink" href="#balanced-binary-tree" title="Permanent link">&para;</a></h2>
<p>Given root of binary tree A, determine if its height balanced.
A binary tree is height balanced. </p>
<p>Height balanced means <span class="arithmatex">\(|depth(A.left) - depth(A.right)| \leq 1\)</span></p>
<p>Return the boolean if its height balanced.</p>
<h3 id="how_14">How<a class="headerlink" href="#how_14" title="Permanent link">&para;</a></h3>
<p>Naive way would be computing height of its left and right subtree and checking the difference.</p>
<p>But we can use a single post-order traversal:
1. Recursively compute the height of each subtree
2. If any tree if already unbalanced, propogate a sentinel (ex: <span class="arithmatex">\(-1\)</span> ) upward immediately.
3. At each node, obtain the leftH and rightH, and if either is <span class="arithmatex">\(-1\)</span> otherwise do the usual check.
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span> <span class="mi">0</span> <span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">is_balanced</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">check_height</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
        <span class="n">left_height</span> <span class="o">=</span> <span class="n">check_height</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">left_height</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">right_height</span> <span class="o">=</span> <span class="n">check_height</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">right_height</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">left_height</span> <span class="o">-</span> <span class="n">right_height</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">left_height</span><span class="p">,</span> <span class="n">right_height</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">check_height</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span>
</code></pre></div></p>
<h2 id="maximum-edge-removal">Maximum Edge Removal<a class="headerlink" href="#maximum-edge-removal" title="Permanent link">&para;</a></h2>
<p>Given an undirected tree, with an even number of nodes A. You may remove as many edges as possible so that each resulting connected component (subtree) has an even number of nodes.</p>
<p>Return the maximum number of edges that can be removed.</p>
<h3 id="how_15">How<a class="headerlink" href="#how_15" title="Permanent link">&para;</a></h3>
<p>Root the tree at node 1, we want to cut as many parent-child edges such that resulting connected components have even size.
1. If a subtree is rooted at u and has even number of nodes, we may cut te edge connecting it to its parent. 
2. If a subtree has odd size, we cannot cut its root to parent edge.</p>
<p>So
1. Compute, for every node <code>u</code>, the size of its subtree.
2. Process nodes in post order, (children first). Whenever a node <span class="arithmatex">\(u\neq\)</span> 1 has an even subtree size, increment the answer by 1, and do not add u's size to its parent. 
3. If it has odd size, add u's size to its parent's running total.
4. Root's final collected size is A, which is even, but we can never cut above the root.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="k">def</span><span class="w"> </span><span class="nf">max_edge_removal_even_tree</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">):</span>
    <span class="c1">#build adj</span>
    <span class="n">adj</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">B</span><span class="p">:</span>
        <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="c1">#post order setup</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">A</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">parent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>
    <span class="n">postorder</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">u</span><span class="p">,</span><span class="n">p</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">postorder</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">p</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="p">,</span><span class="n">u</span><span class="p">))</span>
    <span class="n">subsize</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">A</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#subtree size, default itself (1)</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">postorder</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">u</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">subsize</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">answer</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">p</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">subsize</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">+=</span> <span class="n">u</span>
    <span class="k">return</span> <span class="n">answer</span>
</code></pre></div>
<h2 id="merge-binary-trees">Merge Binary Trees<a class="headerlink" href="#merge-binary-trees" title="Permanent link">&para;</a></h2>
<p>Given two binary trees <code>A</code> and <code>B</code>. merge them into a single binary tree according to this rule
1. if two nodes overlap (both non-null at same position). sum their value to form a new node.
2. otherwise use the non-null node as in the merged tree.
Return a pointer to the root of the merged tree.</p>
<p>Input, ptr to A and B, Output the root ptr to merged binary tree.</p>
<h3 id="how_16">How<a class="headerlink" href="#how_16" title="Permanent link">&para;</a></h3>
<p>We perform a simultaneous pre-order traversal of both trees:
1. if both current nodes u (from A) and v (from B) are non-null, create (or reuse) a node with value <span class="arithmatex">\(u.val + v.val\)</span> 
    1. Recursively merge left children
    2. Recursively merge right children</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">mergeTrees</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">u</span><span class="p">:</span> <span class="k">return</span> <span class="n">v</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span><span class="p">:</span> <span class="k">return</span> <span class="n">u</span>
    <span class="n">u</span><span class="o">.</span><span class="n">val</span> <span class="o">+=</span> <span class="n">v</span><span class="o">.</span><span class="n">val</span>
    <span class="n">u</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">mergeTrees</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">left</span><span class="p">,</span><span class="n">v</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
    <span class="n">u</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">mergeTrees</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">right</span><span class="p">,</span><span class="n">v</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">u</span>
</code></pre></div>
<h2 id="symmetric-binary-tree">Symmetric Binary Tree<a class="headerlink" href="#symmetric-binary-tree" title="Permanent link">&para;</a></h2>
<p>Given the root of binary tree A, determine whether it is symmetric around its center (i.e a mirror of itself). In other words, left and right subtree should be mirror images.</p>
<h3 id="how_17">How<a class="headerlink" href="#how_17" title="Permanent link">&para;</a></h3>
<ol>
<li>If both nodes are null, they match</li>
<li>if one is null and other is not, they dont</li>
<li>otherwise we repeat the top 2 for pair (left.left,right.right) and (left.right, right.left)</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">is_symmetric</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="mi">1</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">))</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">u</span><span class="p">,</span><span class="n">v</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">u</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">v</span><span class="p">:</span> <span class="k">continue</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">u</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">v</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">v</span><span class="o">.</span><span class="n">val</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">u</span><span class="o">.</span><span class="n">left</span><span class="p">,</span><span class="n">v</span><span class="o">.</span><span class="n">right</span><span class="p">))</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">u</span><span class="o">.</span><span class="n">right</span><span class="p">,</span><span class="n">v</span><span class="o">.</span><span class="n">right</span><span class="p">))</span>
    <span class="k">return</span> <span class="mi">1</span> 
</code></pre></div>
<h2 id="identical-binary-tree">Identical Binary Tree<a class="headerlink" href="#identical-binary-tree" title="Permanent link">&para;</a></h2>
<p>Given two trees A and B, return if they are identical, structurally and value vise.</p>
<h3 id="how_18">How<a class="headerlink" href="#how_18" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">is_same_tree</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">u</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">v</span><span class="p">:</span> <span class="k">return</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">u</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">v</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">u</span><span class="o">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">v</span><span class="o">.</span><span class="n">val</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">is_same_tree</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">left</span><span class="p">,</span><span class="n">v</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_same_tree</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">right</span><span class="p">,</span><span class="n">v</span><span class="o">.</span><span class="n">right</span><span class="p">)):</span>
</code></pre></div>
<h2 id="construct-bst-from-preorder">Construct BST from PreOrder<a class="headerlink" href="#construct-bst-from-preorder" title="Permanent link">&para;</a></h2>
<p>Given an int arr of distinct elements representing the preorder traversal of a BST, construct the corresponding BST, and return its root pointer.</p>
<h3 id="how_19">How<a class="headerlink" href="#how_19" title="Permanent link">&para;</a></h3>
<p>In a BST, for a node with val <code>v</code>, all subsequent preorder values less than <code>v</code> belong to the left subtree. Values greater than <code>v</code> belong to the right subtree or higher up.</p>
<p>Simulate insertion using a stack:
1. First element <span class="arithmatex">\(A[0]\)</span> becomes the root.
2. Maintain a stack of nodes representing the path from the root down to the most recently inserted node.
3. For each new value <span class="arithmatex">\(A[i]\)</span> :
    1. If <span class="arithmatex">\(A[i]\)</span> is less than the value at the top of the stack, it must be the left child of that top value. Create a new node and attach it as top.left and push it on to the stack.
    2. Else: pop from stack until you find a node that is greater than <span class="arithmatex">\(A[i]\)</span>. The last popped node is the parent of the new node in its right subtree.  Create the new node as parent.right, then push it onto the stack.
4. Continue until all elements are processed.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">bst_from_preorder</span><span class="p">(</span><span class="n">preorder</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">preorder</span><span class="p">:</span> <span class="k">return</span> <span class="n">Node</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">preorder</span><span class="p">)):</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">preorder</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="c1">#smaller than stack top? left child</span>
        <span class="k">if</span> <span class="n">preorder</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
            <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">curr</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1">#find parent in right chain</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">while</span> <span class="n">stack</span> <span class="ow">and</span> <span class="n">preorder</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">curr</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">root</span>
</code></pre></div>
<h2 id="inorder-traversal-of-a-cartesian-tree">Inorder Traversal Of a Cartesian Tree<a class="headerlink" href="#inorder-traversal-of-a-cartesian-tree" title="Permanent link">&para;</a></h2>
<p>Given arr <code>A</code> on distinct integers, representing inorder traversal of a <strong>cartesian tree.</strong> Return the cartesian tree and its root. </p>
<p>Cartesian Tree:
1. <strong>Heap Property</strong>: every node's value is greater than all values in its subtree.
2. <strong>Inorder property</strong>: an inorder traversal of the tree yields exactly the orignal array <code>A</code>.</p>
<h3 id="how_20">How<a class="headerlink" href="#how_20" title="Permanent link">&para;</a></h3>
<p>To build the cartesian tree in <span class="arithmatex">\(O(n)\)</span> time, we process A from left to right using a stack.
1. Init an empty stack <code>st</code> of TreeNode pointers.
2. For each value x = <code>A[i]</code>
    1. Create a new node <code>curr</code> = TreeNode(x)
    2. Pop nodes from the top of the stack while they have value less than x. Let last be the last node popped (or <code>nullptr</code> if none). Attach last as <code>curr.left</code>. This would maintain the inorder property: everything popped lies to the left of <code>x</code>.
    3. If the stack is nonempty aftert popping, the new top's value is &gt; x, so we attach <code>curr</code> as <code>st.top().right</code>. This would ensure <code>curr</code> becomes the right child of the nearest larger node to its left.
    4. Push <code>curr</code> onto the stack.
3. After processing all elements, bottom of the stack (first el pushed) is the root of cartesian tree.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">def</span><span class="w"> </span><span class="nf">build_cartesian_tree</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="n">st</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)):</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">last</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">while</span> <span class="n">st</span> <span class="ow">and</span> <span class="n">st</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">curr</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">last</span>
        <span class="k">if</span> <span class="n">st</span><span class="p">:</span>
            <span class="n">st</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">curr</span>
        <span class="n">st</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">st</span> <span class="k">else</span> <span class="kc">None</span>
</code></pre></div>
<h2 id="sorted-array-to-balanced-bst">Sorted Array to Balanced BST<a class="headerlink" href="#sorted-array-to-balanced-bst" title="Permanent link">&para;</a></h2>
<p>Given an array <code>A</code> of length <code>n</code> whose elements are sorted in strictly ascending order, convert it into a height balanced BST. </p>
<p>Basically the depth of right and left subtree differ by atmost 1.</p>
<h3 id="how_21">How<a class="headerlink" href="#how_21" title="Permanent link">&para;</a></h3>
<ol>
<li>In a BST, in-order traversal yields the sorted sequence.</li>
<li>To keep it balanced, choose the mid element of the array as root,  and half of the elements go to the left subtree and half to the right.</li>
<li>Recursively apply the same procedure to the left subarray's midpoint and right subarray's midpoint.</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">def</span><span class="w"> </span><span class="nf">sorted_arr_to_bst</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_bst</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span><span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">//</span><span class="mi">2</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span>
        <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">build_bst</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">build_bst</span><span class="p">(</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span>
    <span class="k">return</span> <span class="n">build_bst</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div>
<h2 id="construct-binary-tree-from-inorder-and-preorder">Construct Binary Tree from Inorder and preorder<a class="headerlink" href="#construct-binary-tree-from-inorder-and-preorder" title="Permanent link">&para;</a></h2>
<p>Given 2 int arrays A and B having pre-order and in-order traversal. Construct the binary tree and return its root pointer.</p>
<h3 id="how_22">How<a class="headerlink" href="#how_22" title="Permanent link">&para;</a></h3>
<p>In preorder, first element is always the root. In inorder, the elements to the lest of that root are in left subtree, and els to the right are in right subtree.</p>
<ol>
<li>Maintain a global preIndex into the preorder array.</li>
<li>Define a recursive function <span class="arithmatex">\(build(inL,inR)\)</span> that constructs the subtree whose in-order indices range from <span class="arithmatex">\(inL\)</span> to <span class="arithmatex">\(inR\)</span> .</li>
<li>In <span class="arithmatex">\(build(inL,inR)\)</span>:<ol>
<li>root would be <span class="arithmatex">\(A[preIndex]\)</span> , increment this ptr</li>
<li>look for this value in inOrder array. call this <code>mid</code></li>
<li>Now left subtree would be <span class="arithmatex">\(B[inL...mid-1]\)</span>  and right subtree would be <span class="arithmatex">\(build(mid+1 ... inR)\)</span> </li>
<li>return root
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">=</span>  <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">def</span><span class="w"> </span><span class="nf">build_tree</span><span class="p">(</span><span class="n">preorder</span><span class="p">,</span> <span class="n">inorder</span><span class="p">):</span>
    <span class="n">idx_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">val</span> <span class="p">:</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span><span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inorder</span><span class="p">)}</span>
    <span class="n">pre_index</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#to pass by index</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">:</span> <span class="k">return</span> <span class="kc">None</span>
        <span class="n">root_val</span> <span class="o">=</span> <span class="n">preorder</span><span class="p">[</span><span class="n">pre_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">pre_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">root_val</span><span class="p">)</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="n">idx_map</span><span class="p">[</span><span class="n">root_val</span><span class="p">]</span>
        <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">root</span>
    <span class="k">return</span> <span class="n">build</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">inorder</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></li>
</ol>
</li>
</ol>
<h2 id="binary-tree-from-inorder-and-postorder">Binary Tree from Inorder and PostOrder<a class="headerlink" href="#binary-tree-from-inorder-and-postorder" title="Permanent link">&para;</a></h2>
<p>Given inorder and post-order traversal in an array, construct the binary tree and return the root pointer.</p>
<h3 id="how_23">How<a class="headerlink" href="#how_23" title="Permanent link">&para;</a></h3>
<p>In the post order traversal, last element is always the root of the sub tree.
Like above we use it but backwards.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">def</span><span class="w"> </span><span class="nf">build_tree</span><span class="p">(</span><span class="n">inorder</span><span class="p">,</span> <span class="n">postorder</span><span class="p">):</span>
    <span class="n">idx_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">val</span><span class="p">,</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span><span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inorder</span><span class="p">)}</span>
    <span class="n">post_index</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">postorder</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="c1">#use list for mutable int</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="n">right</span><span class="p">:</span> <span class="k">return</span> <span class="kc">None</span>
        <span class="n">root_val</span> <span class="o">=</span> <span class="n">postorder</span><span class="p">[</span><span class="n">post_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">post_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">root_val</span><span class="p">)</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="n">idx_map</span><span class="p">[</span><span class="n">root_val</span><span class="p">]</span>
        <span class="n">root</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="c1">#make the right first</span>
        <span class="n">root</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">root</span>
    <span class="k">return</span> <span class="n">build</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">inorder</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div>
<h2 id="vertical-order-traversal-of-binary-tree">Vertical Order Traversal of Binary Tree<a class="headerlink" href="#vertical-order-traversal-of-binary-tree" title="Permanent link">&para;</a></h2>
<p>Given a binary tree of <code>N</code> nodes. Return a 2d array denoting its vertical order traversal.
Label the root's column index as <code>0</code>; for any node at column <code>c</code>, its left child at column <code>c-1</code>, and its right child at column <code>c+1</code>.</p>
<p>Group nodes by column. Basically column index is the array index. Give all elements column wise.</p>
<h3 id="how_24">How<a class="headerlink" href="#how_24" title="Permanent link">&para;</a></h3>
<p>Perform a BFS but with node, also carry the current column index. When sending in left child, bas do <code>c-1</code>, and when going right, do <code>c+1</code>.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">deque</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">vertical_order_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="n">result</span>
    <span class="n">col_map</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">min_col</span> <span class="o">=</span> <span class="n">max_col</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([(</span><span class="n">root</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
        <span class="n">node</span> <span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="n">col_map</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">min_col</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">min_col</span><span class="p">,</span><span class="n">col</span><span class="p">)</span>
        <span class="n">max_col</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_col</span><span class="p">,</span><span class="n">col</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span> <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span> <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">total_cols</span> <span class="o">=</span> <span class="n">max_col</span> <span class="o">-</span> <span class="n">min_col</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">total_cols</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_col</span><span class="p">,</span><span class="n">max_col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">result</span><span class="p">[</span><span class="n">col</span> <span class="o">-</span> <span class="n">min_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">col_map</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div>
<h2 id="diagonal-traversal-of-binary-tree">Diagonal Traversal Of Binary Tree<a class="headerlink" href="#diagonal-traversal-of-binary-tree" title="Permanent link">&para;</a></h2>
<p>Given a binary tree A with N nodes, output all nodes in a diagonal order. Where nodes lying on the same line of slope - 1 belong to the same diagonal.
Label the node's diagonal as 0.</p>
<p>Within each diagonal, node must be in preorder. Finally concatenate the diagonals from smallest index to largest. (leftmost to rightmost)</p>
<p>Input: Root of binary tree.
Output: 1D array</p>
<h3 id="how_25">How<a class="headerlink" href="#how_25" title="Permanent link">&para;</a></h3>
<p>A node's diagonal index d is defined as:
$$
d(root) = 0, \space d(node.left) = d(node) + 1, \space d(node.right) = d(node)
$$
Bas bhai map ke saath banate reh.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">diagonal_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span>
    <span class="n">diag_nodes</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#list of lists</span>
    <span class="n">max_diag</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[(</span><span class="n">root</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="c1">#dfs style</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diag_nodes</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">:</span> <span class="c1">#extend if diagonal too big</span>
            <span class="n">diag_nodes</span><span class="o">.</span><span class="n">extend</span><span class="p">([[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">diag_nodes</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
        <span class="n">diag_nodes</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">max_diag</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_diag</span><span class="p">,</span><span class="n">d</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_diag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">diag_nodes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div>
<h2 id="vertical-sum-of-a-binary-tree">Vertical Sum of a Binary Tree<a class="headerlink" href="#vertical-sum-of-a-binary-tree" title="Permanent link">&para;</a></h2>
<p>Given the root pointer of a binary tree. Comput the <em>vertical sum</em> for each vertical line of the tree. Label the root's column as 0; for any node at column c, its left child is at column <code>c-1</code> and right at <code>c+1</code> . The vertical sum for a column is the sum of all node values that lie in that column. Return an array of these sums, ordered from the leftmost column to the rightmost column.</p>
<h3 id="how_26">How<a class="headerlink" href="#how_26" title="Permanent link">&para;</a></h3>
<p>Perform a BFS of the tree while tracking each node's column index. Keep a hasmap as column's sum metric. 
Similar to what we solved above.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">deque</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">vertical_sum</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span>
    <span class="n">col_sum</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">min_col</span> <span class="o">=</span> <span class="n">max_col</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([(</span><span class="n">root</span><span class="p">,</span><span class="mi">0</span><span class="p">)])</span>
    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
        <span class="n">node</span><span class="p">,</span><span class="n">col</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="n">col_sum</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">+=</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span>
        <span class="n">min_col</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">min_col</span><span class="p">,</span><span class="n">col</span><span class="p">)</span>
        <span class="n">max_col</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_col</span><span class="p">,</span><span class="n">col</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
            <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span><span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">total_cols</span> <span class="o">=</span> <span class="n">max_col</span> <span class="o">-</span> <span class="n">min_col</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">total_cols</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_cols</span><span class="p">,</span> <span class="n">max_cols</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">result</span><span class="p">[</span><span class="n">col</span> <span class="o">-</span> <span class="n">min_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">col_sum</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div>
<h2 id="covered-uncovered-nodes">Covered / Uncovered Nodes<a class="headerlink" href="#covered-uncovered-nodes" title="Permanent link">&para;</a></h2>
<p>Given root of a binary tree A.
A node is :
- <strong>Uncovered</strong> if it appears as either the first or the last node on its level.
- Covered otherwise
Compute absolute difference of:
$$
|\text{(sum of covered values) - (sum of uncovered values)}|
$$</p>
<h3 id="how_27">how<a class="headerlink" href="#how_27" title="Permanent link">&para;</a></h3>
<p>Perform BFS, to identfy first or last at each level.
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">covered_minus_uncovered_sum</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="n">covered_sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">uncovered_sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="n">sz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">uncovered_sum</span> <span class="o">+=</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">covered_sum</span> <span class="o">+=</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">covered_sum</span> <span class="o">-</span> <span class="n">uncovered_sum</span>
</code></pre></div></p>
<h2 id="inorder-traversal-of-a-binary-tree">Inorder Traversal of A Binary Tree<a class="headerlink" href="#inorder-traversal-of-a-binary-tree" title="Permanent link">&para;</a></h2>
<p>Given <code>root</code> pointer of a binary tree, return its nodes in inOrder travesal.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">inorder_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="n">res</span><span class="p">,</span> <span class="n">stack</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">root</span> <span class="ow">or</span> <span class="n">stack</span><span class="p">:</span>
        <span class="c1">#go as far left as possible</span>
        <span class="k">while</span> <span class="n">root</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">left</span>
        <span class="c1">#visit node (mid)</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="c1"># then go right</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">right</span>
    <span class="k">return</span> <span class="n">res</span>
</code></pre></div>
<h2 id="preorder-traversal-of-a-binary-tree">Preorder Traversal Of a Binary Tree<a class="headerlink" href="#preorder-traversal-of-a-binary-tree" title="Permanent link">&para;</a></h2>
<p>Given <code>root</code> pointer of a binary tree, return its nodes in preorder traversal.
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">preorder_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="n">res</span><span class="p">,</span> <span class="n">stack</span> <span class="o">=</span> <span class="p">[],[]</span>
    <span class="k">if</span> <span class="n">root</span><span class="p">:</span> <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span> 
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span> <span class="c1">#right first</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="c1">#then left, so left is processed first</span>
    <span class="k">return</span> <span class="n">res</span>
</code></pre></div></p>
<h2 id="postorder-traversal-of-a-binary-tree">PostOrder Traversal Of a binary Tree<a class="headerlink" href="#postorder-traversal-of-a-binary-tree" title="Permanent link">&para;</a></h2>
<p>Given <code>root</code> pointer of a binary tree, return its nodes in postorder traversal
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">postorder_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span>
    <span class="n">toVisit</span><span class="p">,</span> <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">],</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">s1</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">toVisit</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span> <span class="n">toVisit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span> <span class="n">toVisit</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">visited</span><span class="p">)]</span>
</code></pre></div></p>
<h2 id="right-view-of-a-binary-tree">Right view of a binary tree<a class="headerlink" href="#right-view-of-a-binary-tree" title="Permanent link">&para;</a></h2>
<p>Given <code>root</code>, return an <code>array</code> of int representing the right view of the tree.
Basically the nodes that are visible when looked from the right.</p>
<p>Basically the last element in every level order.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span><span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">rightView</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span>
    <span class="n">right_view</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">sz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">right_view</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span> <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span> <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">right_view</span>
</code></pre></div>
<h2 id="cousins-in-a-binary-tree">Cousins in a binary tree<a class="headerlink" href="#cousins-in-a-binary-tree" title="Permanent link">&para;</a></h2>
<p>Given <code>root</code> pointer of a binary tree with <code>N</code> nodes, and a target value <code>B</code> that exists in the tree. Return an <code>array</code> of all the cousins of node whole value is <code>B</code>. </p>
<p>Two nodes are cousins, if they are on the same depth, but have different parents. 
Sibling nodes are not cousins.</p>
<h3 id="how_28">How<a class="headerlink" href="#how_28" title="Permanent link">&para;</a></h3>
<p>Perform a single BFS (level order), that keeps track of each node's parent
1. Record the nodes at the level <code>levelNodes</code>
2. Check if <code>B</code> is in <code>levelNodes</code> along with its parent pointer.
3. Return all other nodes on the level with different parent.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="n">left</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">find_cousins</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="n">B</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span>
    <span class="n">cousins</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
    <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">root</span><span class="p">,</span><span class="kc">None</span><span class="p">))</span> <span class="c1"># (node,parent)</span>
    <span class="k">while</span> <span class="n">q</span><span class="p">:</span> 
        <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="n">level_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">target_parent</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">):</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="n">level_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="p">,</span><span class="n">parent</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">B</span><span class="p">:</span>
                <span class="n">target_parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="k">if</span> <span class="n">target_parent</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">node</span><span class="p">,</span><span class="n">parent</span> <span class="ow">in</span> <span class="n">level_nodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">parent</span> <span class="o">!=</span> <span class="n">target_parent</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span> <span class="o">!=</span> <span class="n">B</span><span class="p">:</span>
                    <span class="n">cousins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="c1">#enqueue children for the next level</span>
        <span class="k">for</span> <span class="n">node</span><span class="p">,</span><span class="n">parent</span> <span class="ow">in</span> <span class="n">level_nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span> <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span><span class="n">node</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span> <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span><span class="n">node</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">cousins</span>
</code></pre></div>
<h2 id="reverse-level-order-traversal-of-a-binary-tree">Reverse Level Order Traversal of a Binary Tree<a class="headerlink" href="#reverse-level-order-traversal-of-a-binary-tree" title="Permanent link">&para;</a></h2>
<p>Given <code>root</code>, return nodes in reverse level order. Like from bottom-most to the top.</p>
<h3 id="how_29">How<a class="headerlink" href="#how_29" title="Permanent link">&para;</a></h3>
<p>Just do a normal BFS (level order) from top to bottom. But store each level's value in a list then prepend it to a <code>deque</code>. 
1. Record current level, and push it to the front of the <code>deque</code>.
2. Now it will have from bottom to top coz we pushed to the front.
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">reverseLevel</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="n">res</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
    <span class="n">levels</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="n">level</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="n">level</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span> <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span> <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="n">levels</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">lvl</span> <span class="ow">in</span> <span class="n">levels</span><span class="p">:</span> <span class="n">res</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">lvl</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>
</code></pre></div></p>
<h2 id="zigzag-level-order">Zigzag Level Order<a class="headerlink" href="#zigzag-level-order" title="Permanent link">&para;</a></h2>
<p>Given <code>root</code> of binary tree, return nodes in zigzag level order.
- level 0, L to R
- level 1, R to L
basically alternating direction every level</p>
<p>just reverse the even level bro i dont even know</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">left</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">zigzag</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="n">res</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
    <span class="n">left_to_right</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="n">level</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="n">level</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">if</span>  <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span> <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span> <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">left_to_right</span><span class="p">:</span> <span class="n">level</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="n">left_to_right</span> <span class="o">=</span> <span class="err">!</span><span class="n">left_to_right</span>
        <span class="n">res</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span>
</code></pre></div>
<h2 id="populate-next-right-pointers-in-a-binary-tree">Populate Next Right Pointers in a Binary Tree<a class="headerlink" href="#populate-next-right-pointers-in-a-binary-tree" title="Permanent link">&para;</a></h2>
<p>Given the root pointer of a binary tree. The struct also has a next pointer. Populate each node's <code>next</code> pointer so that ir points to the node immediately to its right on the same level. If there is no such node, let <code>next</code> be null.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeLinkNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">next</span> <span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="nb">next</span>
<span class="k">def</span><span class="w"> </span><span class="nf">connect</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="n">head</span> <span class="o">=</span> <span class="n">root</span> <span class="c1">#head of current level</span>
    <span class="k">while</span> <span class="n">head</span><span class="p">:</span>
        <span class="n">dummy</span> <span class="o">=</span> <span class="n">TreeLinkNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="n">dummy</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span>

        <span class="k">while</span> <span class="n">cur</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cur</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">tail</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">left</span>
                <span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="n">next</span>
            <span class="k">if</span> <span class="n">cur</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">tail</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">right</span>
                <span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="n">next</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">next</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">.</span><span class="n">next</span>
</code></pre></div>
<h2 id="burn-a-tree">Burn a Tree<a class="headerlink" href="#burn-a-tree" title="Permanent link">&para;</a></h2>
<p>Given <code>root</code> of a binary tree A, and a target leaf <code>B</code>, a fire starts at node B at time = 0. Each second, the fire spreads from any burning node to its directly connected neighbors (left child, right child and parent). Compute minimum time required to burn the entire tree.</p>
<h3 id="how_30">How<a class="headerlink" href="#how_30" title="Permanent link">&para;</a></h3>
<p>Run BFS, and treat the tree like an undirected graph. In BFS, also pass the time, and then check the min time.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span><span class="p">,</span> <span class="n">defaultdict</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">build_parent_map</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="n">parent_map</span><span class="p">):</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
            <span class="n">parent_map</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">parent_map</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">find_target_node</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span> <span class="k">return</span> <span class="n">root</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">find_target_node</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">left</span><span class="p">:</span> <span class="k">return</span> <span class="n">left</span>
    <span class="k">return</span> <span class="n">find_target_node</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">burn_tree</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">target_val</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
    <span class="n">parent_map</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">build_parent_map</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="n">parent_map</span><span class="p">)</span>
    <span class="n">target_node</span> <span class="o">=</span> <span class="n">find_target_node</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="n">target_val</span><span class="p">)</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">target_node</span><span class="p">])</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">target_node</span><span class="p">)</span>
    <span class="n">time</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1">#first level at t = 0</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">parent_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">)]:</span>
                <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">and</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>  
        <span class="n">time</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">time</span>
</code></pre></div>
<h2 id="max-depth-of-a-binary-tree">Max Depth of a Binary Tree<a class="headerlink" href="#max-depth-of-a-binary-tree" title="Permanent link">&para;</a></h2>
<p>Given the <code>root</code> pointer of a binary tree, find its maximum depth.
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
    <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="n">depth</span> <span class="o">++</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sz</span><span class="p">):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span> <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span> <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">depth</span>
</code></pre></div></p>
<h2 id="sum-root-to-leaf-numbers">Sum Root to Leaf Numbers<a class="headerlink" href="#sum-root-to-leaf-numbers" title="Permanent link">&para;</a></h2>
<p>Given <code>root</code> to a binary tree whose node contain 0-9, each root to leaf path represents a number concatenating the digits along the way. Return sum of all sum numbers modulo 1003.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">sum_root_to_leaf_numbers</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
    <span class="n">MOD</span> <span class="o">=</span> <span class="mi">1003</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[(</span><span class="n">root</span><span class="p">,</span><span class="n">root</span><span class="o">.</span><span class="n">val</span> <span class="o">%</span> <span class="n">MOD</span><span class="p">)]</span> <span class="c1">#(node, cur_sum modulo)</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span> <span class="o">+</span> <span class="n">curr</span><span class="p">)</span> <span class="o">%</span> <span class="n">MOD</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">next_val</span> <span class="o">=</span> <span class="p">(</span><span class="n">curr</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="o">%</span> <span class="n">MOD</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">next_val</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
            <span class="n">next_val</span> <span class="o">=</span> <span class="p">(</span><span class="n">curr</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="o">%</span> <span class="n">MOD</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">next_val</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div>
<h2 id="path-sum">Path Sum<a class="headerlink" href="#path-sum" title="Permanent link">&para;</a></h2>
<p>Given <code>root</code> of a binary tree, and an int <code>B</code>, determine whether there exists a root-to-leaf path in A such that sum of node values along that path equals B.</p>
<p>Just DFS and pass cur sum bro</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span>  <span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">has_path_sum</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">target_sum</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[(</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">)]</span> <span class="c1">#(node, cur sum)</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">cur_sum</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cur_sum</span> <span class="o">==</span> <span class="n">target_sum</span><span class="p">:</span> <span class="k">return</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">cur_sum</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">val</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">cur_sum</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">val</span><span class="p">))</span>
    <span class="k">return</span> <span class="mi">0</span>
</code></pre></div>
<h2 id="min-depth-of-a-binary-tree">Min Depth of a Binary Tree<a class="headerlink" href="#min-depth-of-a-binary-tree" title="Permanent link">&para;</a></h2>
<p>Given the <code>root</code> of a binary tree. Find its minimum depth. Basically min root-to-leaf path.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">min_depth</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
    <span class="n">queue</span><span class="o">=</span> <span class="n">deque</span><span class="p">([(</span><span class="n">root</span><span class="p">,</span><span class="mi">1</span><span class="p">)])</span> <span class="c1">#(node, curr depth)</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span> <span class="c1">#return the earliest you reach leaf</span>
            <span class="k">return</span> <span class="n">depth</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span> 
            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="mi">0</span>    
</code></pre></div>
<h2 id="root-to-leaf-paths-with-sum">Root to leaf paths with sum<a class="headerlink" href="#root-to-leaf-paths-with-sum" title="Permanent link">&para;</a></h2>
<p>Given <code>root</code> of a binary tree, and an int <code>B</code>. Find all root-to-leaf paths such that the sum of the node values along each path equals <code>B</code>.
Return a list of these.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">find_paths_with_sum</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">target_sum</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="n">res</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[(</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="p">[</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">])]</span> <span class="c1">#(node, cur sum, path list)</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">node</span><span class="p">,</span> <span class="n">curr_sum</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">curr_sum</span> <span class="o">==</span> <span class="n">target_sum</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">new_path</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">val</span><span class="p">]</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">curr_sum</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">new_path</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
            <span class="n">new_path</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">val</span><span class="p">]</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">curr_sum</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">new_path</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">res</span>
</code></pre></div>
<h2 id="invert-binary-tree">Invert Binary Tree<a class="headerlink" href="#invert-binary-tree" title="Permanent link">&para;</a></h2>
<p>Given <code>root</code> of binary tree, invert the binary tree in place, and return the root of inverted tree. Basically mirror image kar diya.</p>
<p>Left becomes right and right becomes left.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">invert_binary_tree</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="kc">None</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">root</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">root</span>
</code></pre></div>
<h2 id="least-common-ancestor-in-a-binary-tree">Least Common Ancestor in a Binary Tree<a class="headerlink" href="#least-common-ancestor-in-a-binary-tree" title="Permanent link">&para;</a></h2>
<p>Given <code>root</code> of an unordered binary tree, and two int <code>B</code> and <code>C</code>. Find value of LCA of nodes with value <code>B</code> and <code>C</code>. LCA is like deepest node with common descendents.</p>
<h3 id="how_31">How<a class="headerlink" href="#how_31" title="Permanent link">&para;</a></h3>
<ol>
<li>Locate each node and record its parent.<ul>
<li>BFS from root.</li>
<li>Do the parent mapping.</li>
<li>store the <code>nodeB</code> and <code>nodeC</code> when you come across it.</li>
<li>do untill both nodeB and nodeC are not found.</li>
</ul>
</li>
<li>Build the ancestor chain for one node, then walk up from other.<ul>
<li>Visit the ancestor chain of <code>nodeB</code>. Then check nodeC for the deepest ancestor already visited in <code>nodeB</code>'s chain.
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">find_lca</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">root</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">parent</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">parent</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">nodeB</span> <span class="o">=</span> <span class="n">nodeC</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span>
     <span class="n">q</span><span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">root</span><span class="p">])</span>
    <span class="k">while</span> <span class="n">q</span><span class="p">:</span> <span class="c1">#fill the parent map and check if both nodes exist</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">B</span><span class="p">:</span>
            <span class="n">nodeB</span> <span class="o">=</span> <span class="n">node</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">C</span><span class="p">:</span>
            <span class="n">nodeC</span> <span class="o">=</span> <span class="n">node</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
            <span class="n">parent</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
            <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">parent</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
            <span class="n">q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nodeB</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">nodeC</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="n">ancestors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="c1">#find the common parent, from ancestor list</span>
    <span class="n">curr</span> <span class="o">=</span> <span class="n">nodeB</span>
    <span class="k">while</span> <span class="n">curr</span><span class="p">:</span>
        <span class="n">ancestors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">curr</span><span class="p">]</span>
    <span class="n">curr</span> <span class="o">=</span> <span class="n">nodeC</span>
    <span class="k">while</span> <span class="n">curr</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">curr</span> <span class="ow">in</span> <span class="n">ancestors</span><span class="p">:</span> <span class="k">return</span> <span class="n">curr</span><span class="o">.</span><span class="n">val</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">curr</span><span class="p">]</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></li>
</ul>
</li>
</ol>
<h2 id="flatten-binary-tree-to-linked-list">Flatten Binary tree to Linked List<a class="headerlink" href="#flatten-binary-tree-to-linked-list" title="Permanent link">&para;</a></h2>
<p>Given <code>root</code> of a binary tree. Flatten it into a linked list. 
After flattening:
1. Every node's left child is <code>NULL</code>
2. Each node's right child points to the next node in preorder traversal of orignal tree.
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">left</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">=</span>  <span class="n">right</span>
<span class="k">def</span><span class="w"> </span><span class="nf">flatten_binary_tree</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="n">curr</span> <span class="o">=</span> <span class="n">root</span>
    <span class="k">while</span> <span class="n">curr</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">curr</span><span class="o">.</span><span class="n">left</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">right</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#find the rightmost node in left subtree</span>
            <span class="n">pred</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">left</span>
            <span class="k">while</span> <span class="n">pred</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">pred</span> <span class="o">=</span> <span class="n">pred</span><span class="o">.</span><span class="n">right</span>
            <span class="c1">#rewire the connections</span>
            <span class="n">pred</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">right</span>
            <span class="n">curr</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">left</span>
            <span class="n">curr</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">right</span>
    <span class="k">return</span> <span class="n">root</span>
</code></pre></div></p>
<h2 id="order-of-peoples-heights">Order of People's Heights<a class="headerlink" href="#order-of-peoples-heights" title="Permanent link">&para;</a></h2>
<p>Given pos int <code>N</code>. arr <code>Heights</code> of len <code>N</code>, containing distinct heights of N people standing in a queue.</p>
<p>arr <code>infront</code> of len <code>N</code>, where <code>InFronts[i]</code> is the number of people taller than the i-th person, who must stand infront of them.</p>
<p>Return arr of len <code>N</code>, which is the actual ordering of heights from front to back that satisfies all the <code>infront</code> constraints.</p>
<h3 id="how_32">How<a class="headerlink" href="#how_32" title="Permanent link">&para;</a></h3>
<p>Sort all people by asc height. When inserting shortest to tallest, every unpplaced person is strictly taller than the current one.
Hence, if a person of height <code>h</code> has infronts  = <code>k</code>, we need to place them at (<code>k+1</code>)th empty slot, among the remaining positions.</p>
<p>To find k-th empty slot, and mark a slot as occupied, we can use a segment tree. Each leaf holds 1 if that is position is still free, Internal nodes store the sum of their children (count of free slots in that sub range)</p>
<ol>
<li>sort in asc (height, infont), by height</li>
<li>build seg tree <code>[1..N]</code> init all leaf as 1 (all slots are free)</li>
<li>for each pair (h,k) in sorted order:<ul>
<li>Query the segment tree to find the index of (k+1)th free slot.</li>
<li>place height at <span class="arithmatex">\(answer[pos - 1]\)</span> = h</li>
<li>update the segtree at leaf pos to 0.</li>
</ul>
</li>
<li>Return the filled answer.</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">SegmentTree</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">size</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">l</span> <span class="p">,</span><span class="n">r</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="n">r</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span>
        <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>  <span class="n">l</span> <span class="p">,</span><span class="n">m</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">node</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">node</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">node</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">l</span> <span class="p">,</span><span class="n">r</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="n">r</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span>
        <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">node</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">pos</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">node</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">node</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">node</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">kth_free</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">k</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">l</span>
        <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">left_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tree</span><span class="p">[</span><span class="n">node</span><span class="o">*</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">left_count</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">kth_free</span><span class="p">(</span><span class="n">node</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">kth_free</span><span class="p">(</span><span class="n">node</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span> <span class="n">left_count</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">reconstruct_queue</span><span class="p">(</span><span class="n">heights</span><span class="p">,</span> <span class="n">in_fronts</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">height</span><span class="p">)</span>
    <span class="n">people</span> <span class="o">=</span> <span class="p">[(</span><span class="n">heights</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">in_fronts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="n">people</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">seg</span> <span class="o">=</span> <span class="n">SegmentTree</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">seg</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
    <span class="k">for</span> <span class="n">h</span><span class="p">,</span> <span class="n">inf</span> <span class="ow">in</span> <span class="n">people</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">inf</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">sef</span><span class="o">.</span><span class="n">kth_free</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">k</span><span class="p">)</span>
        <span class="n">answer</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span>
        <span class="n">seg</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">pos</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">answer</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
    
      
      <nav class="md-footer__inner md-grid" aria-label="Footer" >
        
          
          <a href="../graph/" class="md-footer__link md-footer__link--prev" aria-label="Previous: Graphs">
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
            </div>
            <div class="md-footer__title">
              <span class="md-footer__direction">
                Previous
              </span>
              <div class="md-ellipsis">
                Graphs
              </div>
            </div>
          </a>
        
        
          
          <a href="../TwoPointers/" class="md-footer__link md-footer__link--next" aria-label="Next: Two Pointers">
            <div class="md-footer__title">
              <span class="md-footer__direction">
                Next
              </span>
              <div class="md-ellipsis">
                Two Pointers
              </div>
            </div>
            <div class="md-footer__button md-icon">
              
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11z"/></svg>
            </div>
          </a>
        
      </nav>
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        <div class="md-social">
  
    
    
    
    
      
      
    
    <a href="https://github.com/your/repo" target="_blank" rel="noopener" title="github.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../..", "features": ["navigation.tabs", "navigation.top", "content.code.copy", "content.code.annotate", "navigation.footer", "navigation.sections", "navigation.instant", "navigation.tracking", "search.highlight", "search.share", "search.suggest"], "search": "../../assets/javascripts/workers/search.d50fe291.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.13a4f30d.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  <script id="init-glightbox">const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});
document$.subscribe(() => { lightbox.reload() });
</script></body>
</html>
{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\udc4b Welcome to SDE Prep A2Z","text":"<p>Ye karne ke baad bhi tu gawar hi rahega</p>"},{"location":"#why-this-site","title":"\ud83d\ude80 Why this site?","text":"<ul> <li>Kyuki lawde unemployed hai tu</li> </ul>"},{"location":"#navigation","title":"\ud83e\udded Navigation","text":"<p>Jaake padle gaandu:</p> <ul> <li>\ud83d\udcc2 Arrays</li> <li>\ud83d\udd01 Dynamic Programming</li> <li>\ud83c\udf10 Graphs</li> <li>\ud83e\udd6c Trees</li> <li>\ud83e\udd48 Two Pointers</li> <li>\ud83d\ude14 Linked Lists</li> <li>\uff08 \u035c.\u4eba \u035c.\uff09Stacks and Queues</li> </ul>"},{"location":"DSAyy/LinkedList/","title":"Linked Lists","text":""},{"location":"DSAyy/LinkedList/#reverse-linkedlist","title":"Reverse LinkedList","text":"<p>Reverse a linkedlist in place</p> <ol> <li>Store the curr's next so we can go ahead in next iteration.</li> <li>just assign the next ptr to prev</li> <li>then prev = curr, and curr is that temp value</li> </ol> <pre><code>class ListNode:\n    def __init__(self, val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef reverseLL(head):\n    prev = None\n    curr = head\n    while curr:\n        next_temp = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_temp\n    return prev\n</code></pre>"},{"location":"DSAyy/LinkedList/#intersection-of-linkedlist","title":"Intersection Of LinkedList","text":"<p>Find the node where two linkedlists intersect. <pre><code>class ListNode:\n    def __init__(self, val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef getIntersectNode(headA, headB):\n    if not headA or not headB: return None\n    pA, pB = headA, headB\n    while pA != pB:\n        pA = pA.next if pA else headB\n        pB = pB.next if pB else headA\n    return pA\n</code></pre></p>"},{"location":"DSAyy/LinkedList/#sort-binary-linkedlist","title":"Sort Binary LinkedList","text":"<p>Do it inplace with \\(O(1)\\) extra space. <pre><code>class ListNode:\n    def __init__(self, val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef sortBinaryLL(head):\n    zeroDummy, oneDummy = ListNode(0), ListNode(0)\n    zeroTail, oneTail = zeroDummy, oneDummy\n    curr = head #link 2 chains for one and zero, then link them at the end\n    while curr:\n        if curr.val == 0:\n            zeroTail.next = curr\n            zeroTail = curr\n        else:\n            oneTail.next = curr\n            oneTail = curr\n        curr = curr.next\n    oneTail.next = None #end the list\n    zeroTail.next = oneDummy.next #link 0chain to 1 chain\n    return zeroDummy.next #first was dummy\n</code></pre></p>"},{"location":"DSAyy/LinkedList/#partition-list","title":"Partition List","text":"<p>Given a LL and a value <code>B</code>. Partition it so that all nodes with val less than B come before B, and all nodes with val greater than B come after it. </p> <p>Preserve the relative order homie. <pre><code>class ListNode:\n    def __init__(self, val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef partition(A,B):\n    leDummy, geDummy = ListNode(0), ListNode(0) #dummy pointers\n    leTail,geTail = leDummy, geDummy\n    curr = A\n    while curr:\n        if curr.val &lt; B:\n            leTail.next = curr\n            leTail = curr\n        else:\n            geTail.next = curr\n            geTail = curr\n        curr = curr.next\n    geTail.next = None\n    leTail.next = geDummy.next\n    return leDummy.next\n</code></pre></p>"},{"location":"DSAyy/LinkedList/#insertion-sort-list","title":"Insertion Sort List","text":"<p>Sort a LL with insertion sort.</p> <p>Just insert new node in the sorted portion in the correct order.</p> <pre><code>class ListNode:\n    def __init__(self,val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef insertionSortList(head):\n    if not head or head.next:\n        return head\n    dummy = ListNode(0)\n    dummy.next = jead\n    lastSorted = head\n    curr = head.next\n    while curr:\n        if lastSorted.val &lt;= curr.val:\n            lastSorted = curr\n        else:\n            prev = dummy\n            while prev.next.val &lt;= curr.val:\n                prev = prev.next\n            #re-link the nodes\n            lastSorted.next = curr.next #so we know where to cont from next iteration\n            curr.next = prev.next\n            prev.next = curr\n        curr = lastSorted.next\n    return dummy.next\n</code></pre>"},{"location":"DSAyy/LinkedList/#sort-list-merge-sort-on-linkedlist","title":"Sort List (Merge Sort on LinkedList)","text":"<p>you already know what it is.</p> <pre><code>class ListNode:\n    def __init__(self, val= 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef length(head):\n    count = 0\n    while head:\n        count += 1\n        head = head.next\n    return count\n#split first n nodes, return head of the rest\ndef split(head,n):\n    for _ in range(n-1):\n        if head: head = head.next\n        else: return None\n    if not head:\n        return None\n    second = head.next\n    head.next = None\n    return second\n#merge l1, l2 after tail, return new tail\ndef merge(l1,l2,tail):\n    curr = tail\n    while l1 and l2:\n        if l1.val &lt; l2.val:\n            curr.next = l1\n            l1 = l1.next\n        else:\n            curr.next= l2\n            l2 = l2.next\n        curr = curr.next\n    curr.next = l1 if l1 else l2\n    while curr.next:\n        curr = curr.next\n    return curr\ndef mergeSortLL(head):\n    dummy = ListNode(0)\n    dummy.next = head\n    n = length(head)\n    step = 1\n    while step &lt; n:\n        prev,curr = dummy, dummy.next\n        while curr:\n            left = curr\n            right = split(left,step)\n            curr = split(right,step)\n            prev = merge(left, right, prev)\n        step &lt;&lt;= 1\n    return dummy.next\n</code></pre>"},{"location":"DSAyy/LinkedList/#palindrome-list","title":"Palindrome List","text":"<p>Determine if the LL is a palindrome.</p> <pre><code>class ListNode:\n    def __init__(self,val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef isPalindromeLL(head):\n    if not head and head.next: return 1\n    #find the mid point\n    slow, fast = head, head\n    while fast.next and fast.next.next:\n        slow = fast.next\n        fast = fast.next.next\n    #reverse the second half\n    prev,curr = None, slow.next\n    while curr:\n        nxt = curr.next\n        curr.next = prev\n        prev = curr\n        curr = nxt\n    p1, p2 = head, prev\n    isPal = True\n    while p2:\n        if p1.val != p2.val:\n            isPal = False\n            break\n        p1 = p1.next\n        p2 = p2.next\n    #we can restore it too\n    curr,prev = slow.next = None\n    while curr:\n        nxt = curr.next\n        curr.next = prev\n        prev = curr\n        curr = nxt\n    slow.next =prev\n    return 1 is isPal else 0\n</code></pre>"},{"location":"DSAyy/LinkedList/#remove-duplicates-from-sorted-list-ii","title":"Remove Duplicates from Sorted List II","text":"<p>Delete all nodes that have duplicate numbers, leaving only distinct numbers from LL.</p> <pre><code>class ListNode:\n    def __init__(self,val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef removeDuplicatesII(head):\n    dummy = ListNode(0)\n    dummy.next = head\n    prev,curr = dummy,head\n    while curr:\n        if curr.next and curr.val == curr.next.val:\n            dupVal = curr.val\n            #skip all nodes with this value\n            while curr and curr.val == dupVal:\n                curr = curr.next\n            prev.next = curr\n        else:\n            prev = curr\n            curr = curr.next\n    return dummy.next\n</code></pre>"},{"location":"DSAyy/LinkedList/#merge-two-sorted-lists","title":"Merge Two Sorted Lists","text":"<p>Merge two sorted linked lists, and return the merged sorted list.</p> <pre><code>class ListNode:\n    def __init__(self,val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef merge(A,B):\n    dummy = ListNode(0)\n    tail = dummy\n    while A and B:\n        if A.val &lt; B.val:\n            tail.next = A\n            A= A.next\n        else:\n            tail.next = B\n            B = B.next\n        tail = tail.next\n    tail.next = A if A else B\n    return dummy.next\n</code></pre>"},{"location":"DSAyy/LinkedList/#remove-duplicates-from-sorted-list","title":"Remove Duplicates from Sorted List","text":"<p>Remove all duplicates so that each element appears only once.</p> <pre><code>class ListNode:\n    def __init__(self,val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef removeDuplicates(A):\n    curr = A\n    while curr and curr.next:\n        if curr.val == curr.next.val:\n            curr.next = curr.next.next\n        else:\n            curr = curr.next\n    return A\n</code></pre>"},{"location":"DSAyy/LinkedList/#remove-nth-node-from-list-end","title":"Remove Nth Node from List End","text":"<p>Given a singly LL, remove <code>B</code>th node from the end and return the head of the linked list.</p> <p>If B is greater than the length, remove the first node.</p>"},{"location":"DSAyy/LinkedList/#how","title":"How","text":"<p>Advance first ptr at Bth Node. Then advance both ptr until the first ptr reaches the end. The second ptr would be at the node just before the one we need to delete.</p> <pre><code>class ListNode:\n    def __init__(self,val = 0, nxt = 0):\n        self.val = val\n        self.next=  nxt\ndef removeEnd(head, B):\n    dummy = ListNode()\n    dummy.next = head\n    first,second = dummy, dummy\n    for _ in range(B):\n        if first.next: first = first.next\n        else:\n            return head.next\n    while first.next:\n        first = first.next\n        second = second.next\n    second.next = second.next.next\n    return dummy.next\n</code></pre>"},{"location":"DSAyy/LinkedList/#k-reverse-linked-list","title":"K-Reverse Linked List","text":"<p>Given a singly linked list, and an int K, reverse the nodes of the list, K at a time, and return the modified list.</p> <p>Note: the length is divisible by K.</p> <pre><code>class ListNode:\n    def __init__(self, val = 0, nxt =None):\n        self.val = val\n        self.next = nxt\ndef reverseKGroup(head, K):\n    if not head and K &lt;= 1:\n        return head\n    dummy = ListNode()\n    dummy.next = head\n    prevGroup = dummy\n    while True:\n        #find the Kth node\n        kth = prevGroup\n        for _ in range(K):\n            kth = kth.next\n            if not kth:\n                return dummy.next\n        groupStart = prevGroup.next\n        nextGroup = kth.next\n        #rev the group\n        prev, curr = nextGroup, groupStart\n        while curr != nextGroup:\n            tmp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = tmp\n        #connect the prev group\n        prevGroup.next = kth\n        prevGroup = groupStart\n    return dummy.next\n</code></pre>"},{"location":"DSAyy/LinkedList/#even-reverse","title":"Even Reverse","text":"<p>Given a LL, reverse the order of all nodes at even position.</p> <p>Before: 1 -&gt; 2 -&gt; 3 -&gt; 4 Output: 1 -&gt; 4 -&gt; 3 -&gt; 2</p> <ol> <li>Extract even pos nodes into a separate list.</li> <li>Reverse this even list</li> <li>Merge the reverse even list into the orignal list.</li> </ol> <pre><code>class ListNode:\n    def __init__(self, val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef evenReverse(head):\n    if not head or not head.next:\n        return head\n    odd, even = head, head.next\n    evenHead = even\n    while even and even.next: #extracting even list\n        odd.next = even.next\n        odd = odd.next\n        even.next = odd.next\n        even = even.next\n    #rev the even list\n    prev, curr = None, evenHead\n    while curr:\n        nxt = curr.next\n        curr.next = prev\n        prev = curr\n        curr = nxt\n    revEven = prev\n    #merge back even nodes\n    odd,even = head,revEven\n    while even:\n        tmp = odd.next\n        odd.next= even\n        even = even.next\n        odd.next.next = tmp\n        odd = tmp\n</code></pre>"},{"location":"DSAyy/LinkedList/#swap-list-nodes-in-pair","title":"Swap List Nodes in Pair","text":"<p>Given a LL A, swap every two adjacent nodes and return its head.</p> <pre><code>class ListNode:\n    def __init__(self, val = 0, nxt =  None):\n        self.val = val\n        self.next = nxt\ndef swapPair(head):\n    dummy = ListNode()\n    dummy.next = head\n    prev = dummy\n    while prev.next and prev.next.next:\n        first = prev.next\n        second = first.next\n        #swap pair\n        first.next = second.next\n        second.next = first\n        prev.next = second\n        #move prev two steps ahead\n        prev = first\n    return dummy.next\n</code></pre>"},{"location":"DSAyy/LinkedList/#rotate-list","title":"Rotate List","text":"<p>Given a linked list, rotate it by k places.</p> <p>Just connect the linked list in a cycle. Then break at the right spot.</p> <p>Find the length, then move to the new tail (\\(n-B\\) th node)</p> <pre><code>class ListNode:\n    def __init__(self, val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef rotateLL(head, k):\n    if not head or not head.next or k == 0:\n        return head\n    #find len and tail\n    length = 1\n    tail = head\n    while tail.next:\n        tail = tail.next\n        length += 1\n    #normalize k\n    k = k % length\n    tail.next  = head #make it circular\n    #find new tail (len - k)th node\n    newTail = head\n    for _ in range(length - k - 1):\n        newTail = newTail.next\n    newHead = newTail.next #break at the len-k - 1th node\n    newTail.next = None\n    return newHead# len - kth node is the new head\n</code></pre>"},{"location":"DSAyy/LinkedList/#kth-node-from-the-middle","title":"Kth node from the middle","text":"<p>Given a LL, find the value of kth node from the middle towards the head of the linkedlist.</p> <p>If no such node exists, return -1</p>"},{"location":"DSAyy/LinkedList/#how_1","title":"How","text":"<p>Find length, find the middle. To get the Bth node from middle, move B steps backwards from middle.</p> <pre><code>class ListNode:\n    def __init__(self, val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef kFromMid(head, k):\n    N = 0 #find len to get the mid\n    p = head\n    while p:\n        N += 1\n        p = p.next\n    #find mid\n    mid = N//2 + 1\n    target = mid - B\n    if target &lt; 1: return -1\n    # go to the target\n    p = head\n    for i in range(1, target):\n        p = p.next\n    return p\n</code></pre>"},{"location":"DSAyy/LinkedList/#reverse-alternate-k-nodes","title":"Reverse Alternate K nodes","text":"<p>Given a singly LL, reverse every alternate B nodes in the list.</p> <p>3-&gt;4-&gt;7-&gt;8-&gt;10-&gt;12, output: 4-&gt;3-&gt;7-&gt;8-&gt;12-&gt;10</p>"},{"location":"DSAyy/LinkedList/#how_2","title":"How","text":"<ol> <li>reverse first <code>B</code> nodes.</li> <li>skip the next <code>B</code> nodes.</li> <li>Continue reversing and skipping</li> </ol> <pre><code>class ListNode:\n    def __init__(self,val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef revAltK(head,k):\n    if not head or k &lt;= 1: return head\n    dummy = ListNode()\n    dummy.next = head\n    prevGroup = dummy\n    curr = head\n    doReverse = True\n    while curr:\n        #check if there are B nodes ahead\n        node = curr\n        count = 0\n        while node and count &lt; k:\n            node = node.next\n            count += 1\n        if count &lt; B: break\n        if doReverse:\n            prev,p = node, curr\n            for _ in range(k):\n                nxt = p.next\n                p.next = prev\n                prev = p\n                p = nxt\n            prevGroup.next = prev\n            prevGroup = curr\n            curr = node\n        else:\n            for _ in range(k):\n                prevGroup = curr\n                curr = curr.next\n        doReverse = not doReverse\n    return dummy.next\n</code></pre>"},{"location":"DSAyy/LinkedList/#reverse-linkedlist-ii","title":"Reverse LinkedList II","text":"<p>Given singly LL, reverse nodes from pos <code>m</code> to <code>n</code> in one pass and in-place.</p>"},{"location":"DSAyy/LinkedList/#how_3","title":"How","text":"<ol> <li>Traverse to the node just before m (call it <code>prev</code>)</li> <li>Reverse the next \\((n - m + 1)\\) nodes.</li> <li>Carefully reconnect: before m, reversed seg, after n</li> </ol> <pre><code>class ListNode:\n    def __init__(self, val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef revII(head, m, n):\n    if not head or m == n: return head\n    dummy = new ListNode()\n    dummy.next = head\n    prev = dummy\n    for _ in range(1,m): #move to node just before m\n        prev = prev.next\n    reverse_start = prev.next\n    curr = reverse_start.next\n    #reverse nodes [m,n]\n    for _ in range(n - m):\n        reverse_start.next = curr.next\n        curr.next = prev.next\n        prev.next = curr\n        curr = reverse_start.next\n    return dummy.next\n</code></pre>"},{"location":"DSAyy/LinkedList/#reorder-list","title":"Reorder List","text":"<p>Given a singly LL, re order it to $$ L_0 L_nL_1L_{n-1} ... L_xL_{n-x} $$ 1 -&gt;2 -&gt; 3 -&gt; 4, output is 1-&gt;4-&gt;2-&gt;3</p>"},{"location":"DSAyy/LinkedList/#how_4","title":"How","text":"<ol> <li>Reverse the second half.</li> <li>Zip first and reversed second half</li> </ol> <pre><code>class ListNode:\n    def __init__(self, val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef reorder(head):\n    if not head or not head.next: return head\n    #find the middle\n    slow, fast = head, head\n    while fast.next and fast.next.next:\n        slow = slow.next\n        fast = fast.next.next\n    #rev the second half\n    prev,curr = None, slow.next\n    while curr:\n        nxt = curr.next\n        curr.next = prev\n        prev = curr\n        curr = nxt\n    slow.next = None\n    #merge the two halves\n    p1,p2 = head, prev\n    while p2:\n        n1,n2 = p1.next, p2.next\n        p1.next = p2\n        p2.next = n1\n        p1,p2 = n1,n2\n    return head\n</code></pre>"},{"location":"DSAyy/LinkedList/#add-two-numbers-as-lists","title":"Add two numbers as Lists","text":"<p>Given two non-neg numbers as linkedlists, add them. Each list stores digits in reverse order.</p>"},{"location":"DSAyy/LinkedList/#how_5","title":"How","text":"<ol> <li>Trav both digit by digit</li> <li>maintain the carry</li> </ol> <pre><code>class ListNode:\n    def __init__(self,val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef addLL(A,B):\n    carry = 0\n    dummy = ListNode()\n    dummy.next = head\n    tail = dummy\n    while A or B or carry:\n        sum = carry\n        if A:\n            sum += A.val\n            A = A.next\n        if B:\n            sum += B.val\n            B = B.next\n        carry = sum//10\n        tail.next = ListNode(sum % 10)\n        tail = tail.next\n    return dummy.next\n</code></pre>"},{"location":"DSAyy/LinkedList/#list-cycle","title":"List Cycle","text":"<p>Given a LL, return the node where the cycle begins. If there is no cycle, return null.</p>"},{"location":"DSAyy/LinkedList/#how_6","title":"How","text":"<p>Tortoise Hare. 1. To find cycle's entry point, move one pointer to head, and advance both pointers one at a time, the node where they meet is the cycle's start.</p> <pre><code>class ListNode:\n    def __init__(self, val = 0, nxt =None):\n        self.val = val\n        self.next = None\ndef cycle(head):\n    if not head: return None\n    slow,fast = head,head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            #cycle mil gaya\n            ptr = head\n            while ptr != slow:\n                ptr = ptr.next\n                slow = slow.next\n            return ptr\n    return None\n</code></pre>"},{"location":"DSAyy/TwoPointers/","title":"Two Pointers","text":""},{"location":"DSAyy/TwoPointers/#pair-with-given-difference","title":"Pair with Given Difference","text":"<p>Given 1D arr <code>A</code> of <code>N</code> integers, and an int <code>B</code>, determine if there is a pair of elements whose difference in B. </p> <p>A = 5 10 3 2 50 80, B = 78. Ans? Yes</p> <p>Keep a hash set, just \\(O(n)\\) time complexity.</p> <pre><code>def pairSum(A,B):\n    seen = set()\n    for x in A:\n        if (x-B) in seen or (x+B) in seen:\n            return 1\n        seen.insert(x)\n    return 0\n</code></pre>"},{"location":"DSAyy/TwoPointers/#3-sum-closest","title":"3 Sum closest.","text":"<p>Given an arr <code>A</code>, find 3 int in A such that their sum is the closest to a given num <code>B</code>. Return sum of those 3 int.</p> <p>A = -1 2 1 -4, B = 1. Output = 2</p>"},{"location":"DSAyy/TwoPointers/#how","title":"How","text":"<p>Sort the arr and use 2 pointers method. Iterate one pointer, <code>l</code> and <code>r</code> the other 2 to moderate.</p> <pre><code>def threeSumClosest(A,B):\n    sort(A)\n    N = len(A)\n    best = A[0] + A[1] + A[2]\n    for i in range(0,N-2):\n        l = i+1, r = N-1\n        while l &lt; r:\n            sm = A[i] + A[l] + A[r]\n            if sm == B: return B\n            if abs(sm - B) &lt; abs(best - B): best = sm\n            if sm &lt; B: l += 1\n            if sm &gt; B: r -= 1\n    return best\n</code></pre>"},{"location":"DSAyy/TwoPointers/#counting-triangles","title":"Counting Triangles","text":"<p>Given arr <code>A</code> of non-neg numbers. Each \\(A_i\\) represents length of a line segment. Count num of distinct triangles that can be formed from these edge lengths.</p> <p>A = 1 1 1 2 2 Output: 4</p>"},{"location":"DSAyy/TwoPointers/#how_1","title":"How","text":"<p>$$ a + b &gt; c $$ We just have to find all values that satisfy this. - Sort the arr - For each pos largest side \\(A_k\\) , use two pointers     - i starts from 0, j from k-1     - for each k, count pairs (\\(A_i,A_j\\)) such that \\(A_i + A_j  &gt; A_k\\)      - if thats true, all ind from i to j-1 also satisfy the condition. <pre><code>def nTriang(A):\n    sort(A)\n    count = 0\n    for k in range(N-1,1,-1): #n-1 down to 2\n        i,j = 0, k-1\n        while i &lt; j:\n            if A[i] + A[j] &gt; A[k]:\n                count += (j-i)\n                j -= 1\n            else:\n                i += 1\n    return count % (10**9 + 7)\n</code></pre></p>"},{"location":"DSAyy/TwoPointers/#diffk-find-pair-with-given-diff-in-a-sorted-arr","title":"Diffk (Find pair with given diff in a sorted arr)","text":"<p>Given a sorted arr A of int, and non neg <code>B</code>. Find whether there exists two indices sucht that their el diff is B $$ A[j] - A[i] = B,\\space i \\neq j $$ Return 1 if exists warna 0</p> <pre><code>def diffPossible(A,B):\n    i, j = 0 , 1\n    N = len(A)\n    while i &lt; N and j &lt; N:\n        if i != j:\n            diff = A[j] - A[i]\n            if diff == B: return 1\n            if diff &lt; B: j += 1\n            else : i += 1\n        else:\n            j += 1\n    return 0\n</code></pre>"},{"location":"DSAyy/TwoPointers/#max-1s-after-modification-sliding-window","title":"Max 1's after modification. (sliding window)","text":"<p>Given bin arr <code>A</code>, and an int <code>B</code>. Find length of longest subseg of consec 1's you can obtain, by changing at most B zeroes in A to ones.</p> <pre><code>def maxOnes(A,B):\n    N = len(A)\n    l = 0\n    zeroes = 0\n    best = 0\n    for right in range(N):\n        if A[right] == 0:\n            zeroes += 1\n        while zeroes &gt; B:\n            if A[left] == 0:\n                zeroes -= 1\n            left += 1\n        best = max(best, right - left + 1)\n    return best\n</code></pre>"},{"location":"DSAyy/TwoPointers/#counting-subarrays","title":"Counting Subarrays","text":"<p>Given array of non-neg arr, and a non-neg int <code>B</code>, find num of subarrs whose sum \\(&lt;\\) B</p> <p>A = 2 5 6, B = 10  Ans = 4 (2 5 6 (2 5) )</p>"},{"location":"DSAyy/TwoPointers/#how_2","title":"How","text":"<p>Sliding window baby If the window is valid, count += (right - left + 1)</p> <pre><code>def countSubarrs(A,B):\n    left,sm,count = 0\n    for right in range(N):\n        sm += A[right]\n        while left &lt;= right and sm &gt;= B:\n            sm -= B\n            left += 1\n        count += (right - left + 1)\n    return count\n</code></pre>"},{"location":"DSAyy/TwoPointers/#subarrs-with-distinct-int","title":"Subarrs with Distinct Int","text":"<p>Given an arr with pos int, count subarrays (continuous) which are good. Good meaning num of distinct int is exactly <code>B</code>. Return the number of good subarrays.</p> <pre><code>from collections import defaultdict\ndef subarrays_with_k_distinct(A,K):\n    return countAtMostK(A,K) - countAtMostK(A,K-1)\ndef countAtMostK(A,K):\n    freq = defaultdict(int)\n    left,count,distinct = 0\n    for right in range(len(A)):\n        if freq[A[right]] == 0:\n            distinct += 1\n        freq[A[right]] += 1\n        while distinct &gt; K:\n            freq[A[left]] -= 1\n            if freq[A[left]] == 0:\n                distinct -= 1\n            left += 1\n        count += right - left + 1\n    return count\n</code></pre>"},{"location":"DSAyy/TwoPointers/#max-cont-series-of-1s","title":"Max Cont Series of 1s","text":"<p>Given binary array, find max sequence of continuous 1s, that can be formed by replacing atmost <code>B</code> zeroes with ones.</p> <p>Return the indices of max cont series of 1s in order. If multiple soln exists, return the sequence with min starting index.</p> <p>A = 1 1 0 1 1 0 0 1 1 1, B = 1, Output = (0,1,2,3,4)</p>"},{"location":"DSAyy/TwoPointers/#how_3","title":"How","text":"<p>Sliding window. Window is valid is zero_count &gt; B <pre><code>def maxone(A,B):\n    left = zeroes = 0\n    bestLen = bestLeft = 0\n    for right in range(len(A)):\n        if A[right] == 0:\n            zeros += 1\n        while zeros &gt; B:\n            if A[left] == 0:\n                zeros -= 1\n            left += 1\n        if right - left + 1 &gt; bestLen:\n            bestLen = right - left + 1\n            bestLeft = left\n    ans = [bestLeft + i for i in range(bestLen)]\n    return ans\n</code></pre></p>"},{"location":"DSAyy/TwoPointers/#array-3-pointers","title":"Array 3 Pointers","text":"<p>Given 3 sorted arrays, A, B, C. Find indices i,j,k such that $$ max(|A[i] - B[j]|, |B[j] - C[k]|, |C[k] - A[i]|) $$ is minimized.</p> <p>Return the min value.</p>"},{"location":"DSAyy/TwoPointers/#how_4","title":"How?","text":"<p>take i,j,k = 0, then calc the curMax - curMin, of all elements.</p> <p>Advance the ptr to the min element, since we need to decrease the gap.</p> <pre><code>def minimize(A,B,C):\n    i = j = k = 0\n    ans = 10**18\n    while i &lt; len(A) and j &lt; len(B) and k &lt; len(C):\n        x,y,z = A[i], B[j], C[k]\n        curMax = max(x,y,z)\n        curMin = min(x,y,z)\n        ans = min(ans, curMax - curMin)\n        if curMin == x: i += 1\n        else if curMin == y: j +=1 \n        else: k += 1\n    return ans\n</code></pre>"},{"location":"DSAyy/TwoPointers/#container-with-most-water-trapping-rain-water","title":"Container With Most Water (Trapping rain water)","text":"<p>Given arr of non-neg int <code>A</code>, where  \\(A_i\\) is a wall's height. Find the area of most water you can contain in this.</p> <p>A = 1 5 4 3, Output = 6 (trap between 5 and 3)</p>"},{"location":"DSAyy/TwoPointers/#how_5","title":"How","text":"<ol> <li>left = 0, right = n-1</li> <li>Area between left and right is: height =  \\(min(a_{left},a_{right})\\), width = right - left.</li> <li>Move pointer of the shorter wall inwards, since it is holding us back.</li> <li>Repeat until left \\(\\leq\\) right.</li> </ol> <pre><code>def maxArea(A):\n    left,right = 0, len(A) - 1\n    maxAr = 0\n    while left &lt; right:\n        height = min(A[left],A[right])\n        width = right - left\n        maxAr = max(maxAr, height * width)\n        if A[left] &lt; A[right]: left += 1\n        else: right -= 1\n    return maxAr\n</code></pre>"},{"location":"DSAyy/TwoPointers/#merge-two-sorted-lists-ii","title":"Merge Two Sorted Lists II","text":"<p>Given two sorted arrs, modify first one inplace to contain the merged sorted arr of both.</p>"},{"location":"DSAyy/TwoPointers/#how_6","title":"How","text":"<ol> <li>Expand A to size \\(m + n\\) </li> <li>Merge from the end, to avoid overwriting in A that hasn't been moved.</li> <li>Use 3 pointers:<ol> <li>i = m-1 (end of old A)</li> <li>j = n-1 (end of B)</li> <li>k = m+n -1 (end of expanded A)</li> </ol> </li> <li>Compare <code>A[i]</code> and <code>B[j]</code>, put the larger at <code>A[k]</code>.</li> <li>If B has more elements left, just copy them over. <pre><code>def merge(A,B):\n    m,n = len(A), len(B)\n    i,j,k = m-1,n-1,m+n - 1\n    while i&gt;= 0 and j &gt;= 0:\n        if A[i] &gt; B[j]:\n            A[k] = A[i]\n            i -= 1\n        else:\n            A[k] = B[j]:\n            j -= 1\n        k -= 1\n    while j &gt;= 0:\n        A[k] = B[j]\n        k -= 1\n        j -= 1\n</code></pre></li> </ol>"},{"location":"DSAyy/TwoPointers/#intersection-of-sorted-arrays","title":"Intersection of Sorted Arrays","text":"<p>Given two sorted arrays A and B, Find their intersection and preserve element's frequencies.</p>"},{"location":"DSAyy/TwoPointers/#how_7","title":"How","text":"<ol> <li>i = 0, j = 0</li> <li>if <code>A[i]</code> &lt; <code>B[j]</code>: incr i</li> <li><code>A[i]</code> &gt; <code>B[j]</code>, incr j</li> <li>equal? add to the res <pre><code>def intersect(A,B):\n    i=j=0\n    res = []\n    while i &lt; len(A) and j &lt; len(B):\n        if A[i] &lt; B[j]:\n            i += 1\n        elif A[i] &gt; B[j]:\n            j += 1\n        else: \n            res.append(A[i])\n            i += 1\n            j += 1\n    return res\n</code></pre></li> </ol>"},{"location":"DSAyy/TwoPointers/#remove-duplicated-from-sorted-array","title":"Remove Duplicated From Sorted Array","text":"<p>Remove all duplicates inplace from the sorted array, and return the length of sorted array with only distinct elements. Also update A inplace.</p>"},{"location":"DSAyy/TwoPointers/#how_8","title":"How","text":"<p>Use 2 pointers, read and write. First read then write.</p> <pre><code>def removeDuplicates(A):\n    if not A: return 0\n    write = 1 #where we write next unique\n    for read in range(1,n):\n        if A[read] != A[read -1]: #whenever we see new value\n            A[write] = A[read]\n            write += 1\n    return write\n</code></pre>"},{"location":"DSAyy/TwoPointers/#remove-duplicates-from-sorted-array-ii","title":"Remove Duplicates From Sorted Array II","text":"<p>Remove duplicates from sorted array in-place, so that each element appears atmost twice. Return the new length. Update A in-place and return the new length.</p> <p>A = 1 1 1 2, it becomes A = 1 1 2, and output is 3</p>"},{"location":"DSAyy/TwoPointers/#how_9","title":"How","text":"<ol> <li>Duplicates are adjacent.</li> <li>Use a write ptr</li> <li>For every \\(A[read] \\neq A[write - 2]\\) (current el is not equal to two elements before it), copy it to \\(A[write]\\) <pre><code>def removeDuplicatesII(A):\n    n = len(A)\n    if n &lt;= 2: return n\n    write = 2\n    for read in range(2,n):\n        if A[read] != A[write -2]:\n            A[write] = A[read]\n            write += 1\n    return write\n</code></pre></li> </ol>"},{"location":"DSAyy/TwoPointers/#remove-element-from-array","title":"Remove Element From Array","text":"<p>Remove all instances of <code>B</code> from <code>A</code>. Update array in place, and return the num of elements left after operation.</p> <p>if \\(A[read] \\neq B\\) , then \\(A[write] = A[read]\\) <pre><code>def removeElement(A,B):\n    write = 0\n    for read in range(len(A)):\n        if A[read] != B:\n            A[write] = A[read]\n            write += 1\n    return write\n</code></pre></p>"},{"location":"DSAyy/TwoPointers/#sort-by-color-dutch-national-flag-problem","title":"Sort by Color (dutch national flag problem)","text":"<p>Sort the array, consisting only of 0 1 2. </p> <p>Let <code>low</code> be boundary between 0 and 1, let mid be cur el, right be boundary between 1 and 2</p> <pre><code>def sortColors(A):\n    low = mid = 0\n    high = len(A) - 1\n    while mid &lt;= high:\n        if A[mid] == 0:\n            A[low],A[mid] = A[mid],A[low]\n            low += 1\n            mid += 1\n        elif A[mid] == 1:\n            mid += 1\n        else:\n            A[mid],A[high] = A[high],A[mid]\n            high -= 1\n</code></pre>"},{"location":"DSAyy/arrays/","title":"Array Simulation","text":""},{"location":"DSAyy/arrays/#spiral-order-matrix","title":"Spiral Order Matrix","text":""},{"location":"DSAyy/arrays/#question-kya-hai","title":"Question kya hai","text":"<p>Matrix A: Size M x N, return all elements in the spiral order. (clockwise starting from top-left)</p> <p>$$ \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \\end{bmatrix} $$ the output would be \\(1,2,3,6,9,8,7,4,5\\)</p>"},{"location":"DSAyy/arrays/#how-to-do-this","title":"How to do this","text":"<p>Take 4 pointers and continuously run for loops on that bitch.  Bas run top first, then right, then down, then left</p> <pre><code>vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt; &amp;A){\n    int M = A.size(), N = A[0].size();\n    int u = 0, d = M-1, l = 0, r = N-1;\n    vector&lt;int&gt; spiral;\n    while (l &lt;= r &amp;&amp; u &lt;= d){\n        for (int i = l; i &lt;= r; ++i)\n            spiral.push_back(A[u][i]);\n        ++u;\n        for (int i = u; i &lt;= d; ++i)\n            spiral.push_back(A[i][r]);\n        --r;\n        if (u &lt;= d){\n            for (int i = r; i &gt;= l; --i)\n                spiral.push_back(A[d][i]);\n            --d;\n        }\n        if (l &lt;= r){\n            for (int i = d; i &gt;= u; --i)\n                spiral.push_back(A[i][l]);\n            ++l;\n        }\n    }\n    return spiral;\n}\n</code></pre> <p>Iski time complexity is \\(O(n \\times m)\\) Space complexity bhi same</p>"},{"location":"DSAyy/arrays/#large-factorial","title":"Large Factorial","text":""},{"location":"DSAyy/arrays/#question","title":"Question","text":"<p>Given integer A, compute A ! as a string, coz kuch zyaada hi bada number hai.</p>"},{"location":"DSAyy/arrays/#kaise-karna-hai-ye","title":"Kaise karna hai ye","text":"<p>Dekh bro as a string return karna hai answer toh legit make a multiply function for strings and karle solve. Kya hi dumb shit hai ye. Just know ki digits would be reversed for the convenience of the carry shit.  Toh reverse pointer se string meh add kariyo.</p> <pre><code>string factorial(int A){\n    vector&lt;int&gt; digits {1}; // har factorial meh 1 toh hota hi hai\n\n    auto multiply = [&amp;](int i) {\n        int carry = 0;\n        for (int &amp;d : digits){\n            long long prod = (long long)d * i + carry;\n            d = prod % 10; // same time digit update kar diya\n            carry = prod / 10;\n        }\n        while (carry){\n            digits.push_back(carry % 10);\n            carry /= 10;\n        }\n    };\n\n    for (int i = 2; i &lt;= A; ++i) // multiply sabkuch from 2 to A\n    {\n        multiply(i); // multiple every number into 2\n    }\n    string s;\n    // put all the digits into a string\n    for (auto it = digits.rbegin(); it != digits.rend(); ++it){\n        s.push_back('0' + *it); \n    }\n    return s;\n}\n</code></pre>"},{"location":"DSAyy/arrays/#max-non-negative-subarray","title":"Max Non-Negative Subarray","text":""},{"location":"DSAyy/arrays/#question-kya-hai_1","title":"Question kya hai","text":"<p>Array A of N integers, find the subarray with max sum. agar tied, choose the longer one. still tied? smallest starting index</p> <p>Sunn BEHENCHOD, Subarray means continuous, sab kuch subsequence nahi hota</p>"},{"location":"DSAyy/arrays/#karna-kaise-hai","title":"Karna kaise hai","text":"<p>kadane kadane khelenge agar negative number mila, that is where we stop and process the answer. By process i mean, bas compare karke check karlenge if its max</p> <p>End meh bhi ek baar check kar lena coz when the loop ends, ek baar remaining computation bhi toh update karni hai.</p> <pre><code>vector&lt;int&gt; maxSet(vector&lt;int&gt; &amp;A){\n    int n = A.size();\n    long long bestSum = -1, curSum = 0;\n    int bestStart = 0, bestEnd = -1, bestLen = 0;\n    int curStart = 0;\n    for (int i = 0; i &lt; n; ++i){\n        if (A[i] &gt;= 0)\n            curSum += A[i];\n        else {\n            int curLen = i - curStart;\n            if (curSum &gt; bestSum || (curSum == bestSum &amp;&amp; curLen &gt; bestLen)){\n                bestSum = curSum;\n                bestStart = curStart;\n                bestEnd = i - 1;\n                bestLen = curLen;\n            }\n            curSum = 0;\n            curStart = i+1;\n        }\n    }\n    if (curStart &lt; n){\n        int curLen = n - curStart;\n        if (curSum &gt; bestSum || (curSum == bestSum &amp;&amp; curLen &gt; bestLen)){\n            bestSum = curSum;\n            bestStart = curStart;\n            bestEnd = n - 1;\n            bestLen = curLen;\n        }\n    }\n    if (bestEnd &lt; bestStart) return {};\n    return vector&lt;int&gt;(A.begin()+bestStart, A.begin()+bestEnd + 1);\n}\n</code></pre> <p>Time complexity is O(n), space complexity is O(1)</p>"},{"location":"DSAyy/arrays/#pick-from-both-sides","title":"Pick from Both Sides","text":"<p>Array A of N elements. Pick exactly B elements from either left ya right end, and just get the max sum.</p>"},{"location":"DSAyy/arrays/#karna-kaise-hai_1","title":"Karna kaise hai","text":"<p>Imagine kar ek sexy sa sliding window, but instead on inside the array, ye saala bahar se aa raha hai. like the right pointer is left meh and left wala is right meh. ye leke bas max sum with B elements karle. Start the right pointer at B - i, and keep the left wala at n - i, and baaju baaju shift and update karte ja. Keep a sum of first B elements, and fir middle se ek hata and right end wala ek daal.</p> <pre><code>int pickBothSides(vector&lt;int&gt; &amp;A, int B){\n    int n = A.size();\n    int window = accumulate(A.begin(), A.begin() + B, 0);\n    int ans = window;\n    for (int i = 1; i &lt;= B; ++i){\n        window = window - A[B-i] + A[n-i];\n        ans = max(ans, window);\n    }\n    return ans;\n}\n</code></pre> <p>Time complexity is O(n) and space complexity is O(1)</p>"},{"location":"DSAyy/dp/","title":"Dynamic Programming","text":""},{"location":"DSAyy/dp/#longest-common-subsequence","title":"Longest Common Subsequence","text":""},{"location":"DSAyy/dp/#question-statement","title":"Question Statement","text":"<p>Given 2 strings, find the length of uska longest common subsequence. Note subsequence does not have to be continuous.</p> <p>Example: A = \\(abbcdgf\\) and B = \\(bbadcgf\\)  toh the output would be 5 (bbcgf is the lcs)</p>"},{"location":"DSAyy/dp/#kaise-karna-hai","title":"Kaise karna hai","text":"<p>Thode subproblems meh divide karte hai isse. Let \\(\\text{LCS[i][j] be LCS of substrings A[0...i] and B[0....j]}\\) . Toh the obvious relation we can find is if \\(\\text{A[i-1] == B[j-1] fir LCS[i][j] is just LCS[i-1][j-1] + 1}\\)  which means ki humme ek element same mil gaya, toh length would be 1 + the substrings removing those used indexes dono strings se. else \\(\\text{take max of LCS[i-1][j] and LCS[i][j-1]}\\) coz wahi dono possibilities are left.  which means dono string se ek element skip karke check karlo Humhe continuity bhi maintain karni hai. Thats it literally.</p> <p><pre><code>int LCS(string A, string B){\n    int n = A.size(), m = B.size();\n    vector&lt;vector&lt;int&gt;&gt; lcs(n+1, vector&lt;int&gt;(m+1,0));\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= m; ++j){\n            if (A[i-1] == B[j-1]) lcs[i][j] = 1 + lcs[i-1][j-1];\n            else lcs[i][j] = max(lcs[i-1][j], lcs[i][j-1]); \n        }\n    return lcs[n][m];\n}\n</code></pre> Time complexity \\(O(n \\times m)\\)  and and same with space Now the sexy part is hum isse aur optimize kar sakte hai</p> <p>Abhi let \\(\\text{prev}\\) be the results of the i-1 row, and \\(curr\\) be the result of the current row i</p> <p>\\(\\text{LCS[i-1][j-1] = previous row ka j-1}\\) \\(\\text{LCS[i-1][j] = previous row ka j}\\) \\(\\text{LCS[i][j-1] = cur row ka j-1}\\)</p> <pre><code>int LCS(string A, string B){\n    int n = A.size(), m = B.size();\n    if (m &gt; n){\n        // keeping the rows as the bigger one, since lcs ka upper limit toh chotta wala hi hoga\n        swap(A,B);\n        swap(m,n);\n    }\n    vector&lt;int&gt; prev(m+1, 0), cur(m+1,0);\n    for (int row = 1; row &lt;= n; ++row){\n        for (int j = 1; j &lt;= m; ++j){\n            if (A[i-1] == B[j-1])\n                cur[j] = prev[j-1] + 1; \n                // we found a similar el, toh prev row ke result se ek zyada hoga\n            else \n                cur[j] = max(prev[j], cur[j-1]);\n        }\n        swap(prev,cur)\n    }\n    return prev[M]\n}\n</code></pre> <p>Isme the space complexity changed from \\(O(n\\times m)\\) se \\(O(min(n,m))\\) </p>"},{"location":"DSAyy/dp/#longest-palindromic-subsequence","title":"Longest Palindromic Subsequence","text":""},{"location":"DSAyy/dp/#question-statement_1","title":"Question Statement","text":"<p>Given a string A, find length of the longest palindromic subsequence. Example: \\(A = beebeeed\\)  the output would be 4 coz LPS is \\(eeee\\)</p>"},{"location":"DSAyy/dp/#karna-kaise-hai","title":"Karna kaise hai","text":"<p>Abe chutiye, Longest palindromic substring is just the LCS of A and reversed(A)</p> <p>I am not even gonna waste my time fuck off. $$ LPS(A) = LCS(A, reverse(A)) $$</p>"},{"location":"DSAyy/dp/#edit-distance","title":"Edit Distance","text":""},{"location":"DSAyy/dp/#problem-statement","title":"Problem Statement","text":"<p>Given 2 strings, find min steps required to convert A to B given in one step we can - Insert a char - Delete a char - Replace a char Example: - A = abad, B = abac. The output is 1 coz sirf c ko d se replace karna</p>"},{"location":"DSAyy/dp/#kaise-karna","title":"Kaise karna","text":"<p>Let \\(edit[i][j]\\) be the minimum dist to convert \\(A[0...i-1] \\space and \\space B[0...j-1]\\)  Toh iska rishta is  $$ edit[i][j] = edit[i-1][j-1] \\space \\text{if A[i-1] and B[j-1] same hai} $$ $$ \\text{else if its different, edit[i][j] is gonna be 1 + min(edit[i-1][j], edit[i-1][j-1], edit[i-1][j-1])} $$ \\(edit[i-1][j]\\) means hum \\(A[i-1]\\) delete kar rahe hai same with \\(edit[i][j-1]\\) meaning \\(B[j-1]\\) delete \\(edit[i-1][j-1]\\) matlab bro humne dono ko replace kar diya ek dusre se and both are updated</p>"},{"location":"DSAyy/dp/#base-cases","title":"Base Cases","text":"<p>Kuch baate sacch hoti hai Jaise, \\(edit[0][j] = j\\) -&gt; means \\(B[0..j]\\) ko empty karne ke liye j operations are needed. Similarly. \\(edit[i][0] = i\\)</p> <p>Bas bhai ab chalao for loop, sabke level nikalenge.</p> <pre><code>int editDistance(string A, string B){\n    int n = A.size(), B = B.size();\n    vector&lt;vector&lt;int&gt;&gt; edit(n+1, vector&lt;int&gt; (m+1, 0));\n    // sach baate\n    for (int i = 1; i &lt;= n; ++i) edit[i][0] = i;\n    for (int j = 1; j &lt;= m; ++j) edit[0][j] = j;\n\n    for (int i = 1; i &lt;= n; ++i){\n        for (int j = 1; j &lt;= m; ++j){\n            if (A[i-1] == B[j-1]) \n                edit[i][j] = edit[i-1][j-1];\n                // no extra edits needed\n            else {\n                edit[i][j] = 1 + min({\n                    edit[i-1][j], edit[i][j-1], edit[i-1][j-1]\n                });\n            }\n        }\n    }\n    return dp[n][m];\n}\n</code></pre> <p>Time and Space dono in this are \\(O(n\\times m)\\)</p>"},{"location":"DSAyy/dp/#repeating-subsequence","title":"Repeating Subsequence","text":""},{"location":"DSAyy/dp/#problem-kya-yap-kar-raha","title":"Problem kya yap kar raha","text":"<p>String A, check kar if its longest repeating subsequence is \\(\\geq\\) 2.  Repeating subsequence is basically repeating subsequence.</p> <p>Example: A = \\(abab\\), Output is 1 (subseq \\(ab\\) repeats)</p>"},{"location":"DSAyy/dp/#how-to-solve","title":"How to solve?","text":"<p>$$ \\text{Repeating subsequence (A) is LCS(A,A) but i } \\neq  j $$   Aur kuch bhi nahi.</p> <p>bas  $$ \\text{return dp[n][n] } \\geq 2 $$</p>"},{"location":"DSAyy/dp/#distinct-subsequences","title":"Distinct Subsequences","text":""},{"location":"DSAyy/dp/#problem-statement_1","title":"Problem Statement","text":"<p>Given 2 sequences A and B, count ways to form B as a subseq of A.</p> <p>Example: - A = rabbbit, B = rabbit, Output 3     - Basically all 3 <code>b</code> can be removed.</p>"},{"location":"DSAyy/dp/#karu-kaise","title":"Karu kaise?","text":"<p>Let \\(ways[j]\\) be ways to form \\(B[0...j]\\)  as a subseq of first <code>i</code> elements of A.  Isse 1D meh fit kar sakte if we update j from right to left, toh \\(ways[j-1]\\) hoga from previous <code>i</code> </p> <p>Toh the rishta would be  $$ ways[j] = ways[j] + ways[j-1] \\text{      if A[i-1] == B[j-1]} $$ warna \\(ways[j]\\) would remain 0, coz agar element hi same nai toh string kaise banega with those indexes. Note ki \\(ways[j-1]\\) humare previous i ke iteration se hoga, so we have already computed pehle ka.</p> <pre><code>int distSubseq(string A, string B){\n    int n = A.size(), m = B.size();\n    vector&lt;long long&gt; ways(m+1,0);\n    ways[0] = 1; //empty banane ke liye kya hi chahiye\n    for (int i = 1; i &lt;= n; ++i){\n        for (int j = m; j &gt;= 1; --j){\n            if (A[i-1] == B[j-1]){\n                ways[j] += ways[j-1];\n            }\n        }\n    }\n    return (int)ways[m];\n}\n</code></pre>"},{"location":"DSAyy/dp/#scramble-string","title":"Scramble String","text":""},{"location":"DSAyy/dp/#what-does-the-dog-say","title":"What does the dog say?","text":"<p>Given 2 strings, bata if the other string can be made by scrambling A. Now what the fuck is scrambling? B is scramble(A) if -&gt; A can be represented as a binary tree by recursively partitioninng into two non-substrings, and by swapping left and right children any number of times, we can get B. What the helly?</p> <p>Input: A= <code>we</code> and B = <code>we</code>  Ans = 1.</p>"},{"location":"DSAyy/dp/#bhai-mar-jau-meh","title":"Bhai mar jau meh?","text":"<p>Iske liye we use 3D dp. Whether  <code>A[i...i+len - 1]</code> can be scrambled into <code>B[j....j+len - 1]</code> Let <code>scramble[i][j][len]</code> be true if <code>A.substr(i,len)</code> can be scrambled into <code>B.substr(j,len</code></p>"},{"location":"DSAyy/dp/#hard-truth","title":"Hard Truth","text":"<p>Bhai pata nahi yaar ye scrambling shit kya hai Base Case: For length 1, <code>scramble[i][j][1] = (A[i] == B[j])</code>      Like bhai ek hi toh length hai, same string hi hogaya ye toh For each length \\(l\\) from 2 to n, for all <code>A.substr(i,l)</code> and <code>B.substr(j,l)</code> har ek split <code>k</code> try kar le - No swap: <code>scramble[i][j][l]</code> is true if \\(scramble[i][j][k] \\space \\&amp; \\space scramble[i][j][l-k]\\) meaning dono continuous partitions valid hai. - Swap: <code>scramble[i][j][l]</code> is true if <code>scramble[i][j+l-k][k]</code> and <code>scramble[i+k][j][l-k]</code> dono true hai Also quick check: If dono sorted are different, tab toh they cant scramble.</p> <p><pre><code>bool isScramble(string A, string B){\n    int n = A.size();\n    if (n != B.length()) return 0;\n    //quick sorted check\n    {\n        array&lt;int,256&gt; freq = {0};\n        for (char c : A) freq[(unsigned char)c]++;\n        for (char c : B) freq[(unsigned char)c]--;\n        for (int x : freq) if (x != 0) return 0;\n    }\n    static bool scramble[51][51][51];\n    memset(dp,false, sizeof(scramble));\n    // base case\n    for (int i = 0; i &lt; n; ++i)\n        for (int j = 0; j &lt; n; ++j)\n            scramlbe[i][j][1] = (A[i] == B[i]);\n    for (int len = 2; len &lt;= n; ++len){\n        for (int i = 0; i + len &lt;= n; ++i){\n            for (int j = 0; j + len &lt;= n; ++j){\n                for (int k = 1; k &lt; len; k++){\n                    if ((scramble[i][j][k] &amp;&amp; scramble[i+k][j+k][len-k]) || \n                        (scramble[i][j+len - k][k] &amp;&amp; scramble[i+k][j][len - k]){\n                        scramble[i][j][len] = 1;\n                        break;\n                        }\n                    )\n                }\n            }\n        }\n    }\n    return scramble[0][0][n] ? 1 : 0;\n}\n</code></pre> Time Complexity: \\(O(n^4)\\)</p>"},{"location":"DSAyy/dp/#wildcard-pattern-matching","title":"WildCard Pattern Matching","text":""},{"location":"DSAyy/dp/#problem-kya-hai","title":"Problem kya hai","text":"<p>Given 2 strings, find the wildcard pattern between them - <code>?</code> matches any single character - <code>*</code> matches any sequence of character This match must cover the entire string</p> <p>Return if A can be formed with the B pattern - A = <code>aa</code> and B = <code>a*</code> , then ans is 1 - A = <code>aab</code> and B = <code>c*a*b</code>, then output 0 hai</p>"},{"location":"DSAyy/dp/#karna-kaise-hai_1","title":"Karna kaise hai","text":"<p>Iske liye 2 pointer greedy karna padega with some backtracking for the <code>*</code> wala part. - If the character at B is <code>*</code>, remember uska position and current index in A, and try to match it with 0 chars first. - If there is a mismatch, then look for the previous <code>*</code>, since that can save us, and then advance the A pointer and try to match with more. - If the current pointer in B is <code>?</code> ya fir it matches A, then advance both the pointers - If A khatam hogaya, then skip the trailing <code>*</code> in B - If dono khatam, then ans is 1</p> <pre><code>bool isMatch(string A, string B){\n    int n = A.size(), m = B.size();\n    int i = 0, j = 0;\n    int last_star = -1, match_i = 0;\n    while (i &lt; n){\n        if (j &lt; m &amp;&amp; (B[j] == A[i] || B[i] == '?')) \n            i++,j++;\n        else if (j &lt; m &amp;&amp; B[j] == '*'){\n            last_star = j;\n            match_i = i;\n            j++;\n        }\n        else if (last_star != -1){\n            j = last_star + 1;\n            match_i++;\n            i = match_i;\n        }\n        else \n            return 0;\n    }\n    while (j &lt; m &amp;&amp; B[j] == '*') j++;\n    return (j == m)? 1: 0;\n}\n</code></pre>"},{"location":"DSAyy/dp/#pattern-matching-and","title":"Pattern Matching . and *","text":""},{"location":"DSAyy/dp/#problem-kya-hai_1","title":"Problem kya hai","text":"<p>Again pattern matching but, - <code>.</code> means atleast ek element hai here - <code>*</code> ek element nahi bhi hoga toh chalega Example: match(<code>aa</code>, <code>.*</code>) is 1, but match(<code>aa</code>,<code>.</code>) is 0.</p>"},{"location":"DSAyy/dp/#kaise-karna-hai_1","title":"Kaise karna hai","text":"<p>Yaha we finally use dynamic programming. <code>match[i][j]</code> means <code>a[0...i-1]</code> matches <code>b[0..j-1]</code> But isse bhi optimize karenge for only two rows.</p>"},{"location":"DSAyy/dp/#rishte","title":"Rishte","text":"<ul> <li>If <code>B[j-1]</code> is <code>.</code> or <code>a[i-1]</code> matches one character, tab <code>match[i][j] = match[i-1][j-1]</code></li> <li>If <code>B[j-1]</code> is <code>*</code>, tab it can match zero or more previous element:<ul> <li>Zero occurence: \\(match[i][j] \\space | \\space  match[i][j-2]\\)</li> <li>One or more: If <code>A[i-1]</code> matched <code>B[j-2]</code> or <code>B[j-2]</code> is <code>.</code>, then <code>match[i][j]</code> |= <code>match[i-1][j]</code></li> </ul> </li> <li>else <code>match[i][j] = 0</code></li> </ul>"},{"location":"DSAyy/dp/#truth","title":"Truth","text":"<ul> <li><code>match[0][0]</code> = 1 (empty toh match hoga hi)</li> <li><code>match[0][j]</code> = 1 if <code>B[0...j-1]</code> can represent empty </li> <li><code>match[i][0] = 0</code> for i &gt; 0 coz non-empty match nahi kar sakta empty se</li> </ul> <p>The less optimized one but easier to understand: <pre><code>/*\n   Regex-like pattern match for\n     .  = exactly one arbitrary character\n     *  = zero or more copies of the PREVIOUS pattern symbol\n   dp[i][j]  == true  \u21d4   A[0 .. i-1] matches  B[0 .. j-1]\n   (so the table has   (n+1) \u00d7 (m+1)   entries)\n*/\nbool isMatch2D(const string&amp; A, const string&amp; B)\n{\n    int n = A.size(), m = B.size();\n    vector&lt;vector&lt;bool&gt;&gt; dp(n + 1, vector&lt;bool&gt;(m + 1, false));\n    // \u278a empty pattern vs. empty text\n    dp[0][0] = true;\n    // \u278b first row: empty text vs. longer &amp; longer pattern\n    //    Only a chain like  x* y* z*  can match emptiness\n    for (int j = 2; j &lt;= m; ++j)\n        if (B[j - 1] == '*')\n            dp[0][j] = dp[0][j - 2];\n    // \u278c fill the whole grid\n    for (int i = 1; i &lt;= n; ++i)\n    {\n        for (int j = 1; j &lt;= m; ++j)\n        {\n            char pc = B[j - 1];          // current pattern symbol\n            if (pc != '*')               // case 1: normal char or '.'\n            {\n                bool same = (pc == '.' || pc == A[i - 1]);\n                dp[i][j] = same &amp;&amp; dp[i - 1][j - 1];\n            }\n            else                         // case 2: we\u2019re at a '*'\n            {\n                //   pc == '*'  \u2190 it always modifies B[j-2]\n                //   let prev = B[j - 2]\n                // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                // zero copies of prev*\n                bool zero      = dp[i][j - 2];\n                // one-or-more copies  \u21d2  prev must match A[i-1]\n                bool oneOrMore = false;\n                char prevPat   = B[j - 2];\n                if (prevPat == '.' || prevPat == A[i - 1])\n                    oneOrMore = dp[i - 1][j];\n                dp[i][j] = zero || oneOrMore;\n            }\n        }\n    }\n    return dp[n][m];\n}\n</code></pre> The optimized one: <pre><code>bool isMatch(string A, string B){\n    int n = A.size(), m = B.size();\n    vector&lt;bool&gt; prev(m+1, false), cur(m+1, false);\n    prev[0] = true;\n    for (int j = 1; j &lt;= m; ++j){\n        if (B[j-1] == '*' &amp;&amp; j &gt;= 2)\n            prev[j] = prev[j-2];\n        else \n            prev[j] = false;\n    }\n    for (int i = 1; i &lt;= n; ++i){\n        cur[0] = false;\n        for (int j = 1; j &lt;= m; ++j){\n            if (B[j-1] == '.' || B[j-1] == A[i-1])\n                cur[j] = prev[j-1];\n            else if (B[j-1] == '*'){\n                bool matchZero = (j &gt;= 2) ? cur[j-2] : false;\n                bool matchOneOrMore = (j &gt;= 2 &amp;&amp; \n                    (B[j-2] == '.' || B[j-2] == A[i-1])\n                    )? \n                    prev[j] : false;\n                cur[j] = matchZero || matchOneOrMore;\n            }\n            else cur[j] = false;\n        }\n        swap(cur,prev);\n    }\n    return prev[m] ? 1 : 0;\n}\n</code></pre></p>"},{"location":"DSAyy/dp/#length-of-longest-subsequence","title":"Length of Longest Subsequence","text":""},{"location":"DSAyy/dp/#problem-yap","title":"Problem yap","text":"<p>Given array A, find length of longest sequence whihc is strictly increasing  then strictly decreasing. (mountain peak type shit)</p> <p>Example: - A = <code>[1,11,2,10,4,5,2,1]</code>, output is 6 (<code>1,2,10,4,2,1</code>)</p>"},{"location":"DSAyy/dp/#how","title":"How????","text":"<p>So this mountain thing is called bitonic subsequence. - For each i, compute <code>lis[i]</code> which is the length of longest increasing subsequence ending at i. - then also compute <code>lds[i]</code> which is length of longest decreasing subsequence starting at i - Ab bas har ek index pe compute dono ka sum  \\(lis[i] + lds[i] - 1\\)</p> <pre><code>int longSubseq(vector&lt;int&gt; &amp;A){\n    int n = A.size();\n    if (n == 0) return 0;\n    vector&lt;int&gt; lis(n,1);\n    for (int i = 0; i &lt; n; ++i)\n        for (int j = 0; j &lt; i; ++j)\n            if (A[j] &lt; A[j])\n                lis[i] = max(lis[i], lis[j] + 1);\n    vector&lt;int&gt; lds(n,1);\n    for (int i = n-1; i &gt;= 0; --i)\n        for (int j = i+1; j &lt; n; ++j)\n            if (A[j] &lt; A[i])\n                lds[i] = max(lds[i], lds[j] + 1);\n    int ans = 0;\n    for (int i = 0; i &lt; n; ++i) \n        ans = max(ans, lis[i] + lds[i] - 1);\n    return ans;\n}\n</code></pre>"},{"location":"DSAyy/dp/#smallest-subsequence-given-the-primes","title":"Smallest subsequence given the primes.","text":""},{"location":"DSAyy/dp/#sexy-ass-statement","title":"Sexy ass statement","text":"<p>Given 3 prime numbers, and an integer D, find the first smallest D positive numbers which only have A,B,C, or a combination of them as their prime factors.</p> <p>Input: A,B,C,D, Output: Array of size D</p> <ul> <li>A= 2, B = 3, C = 5, D = 5<ul> <li>the output is <code>2,3,4,5,6</code></li> </ul> </li> </ul>"},{"location":"DSAyy/dp/#how-to-do-this-shit","title":"How to do this shit.","text":"<p>What they ask is <code>Ugly Numbers</code> (numbers with only prime as their factors) We use 3 pointers, with a min-merge approach - Maintain an array <code>res</code> initialized with the sequence {1} - For each index, multiple previous seq elements by A,B,C and pick the smallest new candidate. - Increment pointers which produced the candidate to avoid duplicates. $$ res[next] = min(res[i_1]\\times A,res[i_2]\\times B, res[i_3]\\times C) $$</p> <pre><code>vector&lt;int&gt; subseq(int A, int B, int C, int D){\n    vector&lt;long long&gt; primes = {(long long)A,(long long)B, (long long)C};\n    sort(primes.begin(),primes.end());\n    long long p1 = primes[0], p2 = primes[1], p3 = primes[2];\n    vector&lt;unsigned long long&gt; res(D+1);\n    res[0] = 1ull;\n    int i1 = 0, i2 =0, i3 = 0;\n    for (int idx = 1; idx &lt;= D; idx++){\n        unsigned long long \n            nextA = res[i1] * p1,\n            nextB = res[i2] * p2,\n            nextC = res[i3] * p3;\n        unsigned long long val = min({nextA, nextB, nextC});\n        res[idx] = val;\n        if (val == nextA) i1++;\n        if (val == nextB) i2++;\n        if (val == nextC) i3++;\n    }\n    vector&lt;int&gt; ans;\n    for (int k = 1; k &lt;= D; ++k){\n        ans.push_back((int)res[k]);\n    }\n    return ans;\n}\n</code></pre>"},{"location":"DSAyy/dp/#largest-area-of-rectangle-with-permutations","title":"Largest Area of Rectangle with Permutations","text":""},{"location":"DSAyy/dp/#what-does-this-bitch-yap","title":"What does this bitch yap","text":"<p>Given a binary grid A of \\(N \\times M\\), find the area of the largest rectangle containing only 1s.  We are allowed to permute the columns of the matrix in any order.</p> <p>Example $$ A = [[1,0,1],[0,1,0],[1,0,0]] $$ The output is 2</p>"},{"location":"DSAyy/dp/#how-to-do-this","title":"How to do this?","text":"<ul> <li>For each cell (i,j), compute <code>H[i][j]</code> = number of consecutive 1's ending at (i,j) upto row i.</li> <li>For each row, treat <code>H[i]</code> as histogram of column heights, and since <code>H[i]</code> can be permuted, sort <code>H[i]</code> in descending order.</li> <li>For each width k (the k largest column heights), the maximal rectangle is \\(height \\times width = H[i][k-1] \\times k\\) </li> <li>Take the best over all i and k. Example dry run: <pre><code>A\nrow0  1 0 1 1 0 1\nrow1  1 1 1 1 1 1\nrow2  1 1 1 0 1 1\nrow3  0 1 1 1 1 0\nrow4  1 1 1 1 1 1\n</code></pre></li> </ul> row i formula per column j H[i] 0 first row \u2192 copy <code>A</code> 1 0 1 1 0 1 1 if <code>A[1][j]==1</code> then <code>1+H[0][j]</code> else 0 2 1 2 2 1 2 2 same rule 3 2 3 0 2 3 3 same rule 0 3 4 1 3 0 4 same rule 1 4 5 2 4 1 row original H[i] after sort \u2193 <code>k</code> height \u00b7 width 0 1 0 1 1 0 1 1 1 1 0 0 0 1 \u2192 1 2 \u2192 2 3 \u2192 3 3 1 2 1 2 2 1 2 2 2 2 2 1 1 1 \u2192 2 2 \u2192 4 3 \u2192 6 4 \u2192 8 5 \u2192 5 6 \u2192 6 8 2 3 2 3 0 2 3 3 3 3 2 2 0 1 \u2192 3 2 \u2192 6 3 \u2192 9 4 \u2192 8 5 \u2192 10 10 3 0 3 4 1 3 0 4 3 3 1 0 0 1 \u2192 4 2 \u2192 6 3 \u2192 9 4 \u2192 4 9 4 1 4 5 2 4 1 5 4 4 2 1 1 1 \u2192 5 2 \u2192 8 3 \u2192 12 4 \u2192 8 12 <p>Hence the largest we find is \\(4 \\times 3 = 12\\) <pre><code>int maximalRectangle(vector&lt;vector&lt;int&gt;&gt; &amp; A){\n    int N = A.size();\n    if (N == 0) return 0;\n    int M = A[0].size();\n    // building H matrix\n    vector&lt;vector&lt;int&gt;&gt; H(N, vector&lt;int&gt; (M,0));\n    for (int j = 0; j &lt; M; ++j){\n        H[0][j] = A[0][j];\n        // starting meh consecutive ones is the 1 if the value at that ind is 1\n    }\n    for (int i = 1; i &lt; N; ++i)\n        for (int j = 0; j &lt; M; ++j){\n            if (A[i][j] == 1)\n                H[i][j] = H[i-1][j] + 1;\n            else H[i][j] = 0;\n        }\n    int ans = 0;\n    for (int i = 0; i &lt; N; ++i){\n        vector&lt;int&gt; row = H[i];\n        sort(row.rbegin(),row.rend());\n        for (int k = 1; k &lt;= M; ++k){\n            int height = row[k-1];\n            int area = height * k;\n            ans = max(ans, area);\n        }\n    }\n    return ans;\n}\n</code></pre></p>"},{"location":"DSAyy/dp/#tiling-with-dominoes","title":"Tiling with Dominoes","text":""},{"location":"DSAyy/dp/#problem-statement_2","title":"Problem Statement","text":"<p>Given integer A, find total ways to tile a \\(3 \\times A\\) board with \\(2 \\times 1\\) dominoes. Return answer % \\(10^9 + 7\\).</p> <p>Example:  - A = 2, Output = 3 - A = 1, Output = 0</p>"},{"location":"DSAyy/dp/#maths-behind-this","title":"Maths behind this","text":"<p>Let <code>f(n)</code> be the number of ways to tile a \\(3 \\times n\\) board. - <code>f[0]</code> = 1. (empty board) - <code>f[1]</code> = 0 (cannot be completely tiled) - <code>f[2]</code> = 3 - <code>f[3]</code> = 0. (odd ke liye toh impossible hai completely tile karna, always some remainder) - For n \\(\\geq\\) 4, even n, \\(f[n] = 4 \\times f[n-2] - f[n-4]\\) - For odd n, <code>f[n]</code> = 0</p> <pre><code>int domino(int A){\n    const int MOD = 1e9 + 7;\n    vector&lt;int&gt; f(A+1,0);\n    if (A &gt;= 0) f[0] = 1;\n    if (A &gt;= 1) f[1] = 0;\n    if (A &gt;= 2) f[2] = 1;\n    if (A &gt;= 3) f[3] = 0;\n    for (int n = 4; n &lt;= A; ++n){\n        if (n &amp; 1) f[n] = 0;\n        else {\n            long long x = (4LL * f[n-2]) % MOD;\n            x = (x - f[n-4] + MOD) % MOD;\n            f[n] = (int)x;\n        }\n    }\n    return f[A];\n}\n</code></pre>"},{"location":"DSAyy/dp/#paint-house","title":"Paint House","text":"<p>N houses in a row, each can be painted with RGB.  Painting each house with a certain color has a given cost, represented by \\(n \\times 3\\) matrix A, where <code>A[i][j]</code> is the cost to paint the house <code>i</code> with cost <code>j</code>  (0 -&gt; red, 1-&gt; blue, 2-&gt; green). Paint such that - No two adjacent houses have the same color. - Minimize the total painting cost. Input \\(N\\times 3\\) matrix, output -&gt; min cost to paint all. Example: $$     A = \\begin{matrix} 1 &amp;&amp; 2  &amp;&amp; 3\\ 10 &amp;&amp; 11 &amp;&amp; 12 \\end{matrix} $$ Output: 12 Paint 0 with R, 1 with G: 1 + 11 = 12</p>"},{"location":"DSAyy/dp/#how-to-do-this-painting","title":"How to do this painting","text":"<p>Let <code>cost[i][c]</code> be the min cost to paint houses 0 to i with house i painted color c. But since each row only depends on the previous,, we can just use 2 arrays.</p> <p>$$ cost[i][0] = A[i][0] + min(cost[i-1][1], cost[i-1][2]) $$ $$ cost[i][1] = A[i][1] + min(cost[i-1][0], cost[i-1][2]) $$ $$ cost[i][2] = A[i][2] + min(cost[i-1][0], cost[i-1][1]) $$ Iss se simple dp ho nahi sakta Thoda simple karne ke liye let <code>prev_cost[c]</code> be cost of painting the previous house with color c. <code>prev_cost[c] = cost[i-1][c]</code></p> <pre><code>int minCost(vector&lt;vector&lt;int&gt;&gt; &amp;A){\n    int N = A.size();\n    if (N == 0) return 0;\n    long long prev_cost[3];\n    for (int c = 0; c &lt; 3; ++c) \n        prev_cost[c] = A[0][c];\n    for (int i = 1; i &lt; N; ++i){\n        long long cost[3];\n        cost[0] = A[i][0] + min(prev_cost[1], prev_cost[2]);\n        cost[1] = A[i][1] + min(prev_cost[0], prev_cost[2]);\n        cost[2] = A[i][2] + min(prev_cost[0], prev_cost[1]);\n        for (int c = 0; c &lt; 3; ++c) prev_cost[c] = cost[c];\n    }\n    long long ans = min({prev_cost[0], prev_cost[1], prev_cost[2]});\n    return (int)ans;\n}\n</code></pre>"},{"location":"DSAyy/dp/#ways-to-decode","title":"Ways to decode","text":"<p>Given an encoded string <code>A</code> consisting of digits. - 'A' = 1, 'B' = 2 ... 'Z' = 26 find the total number of ways of decoding A modulo \\(10^9 + 7\\).</p> <p>Input: String A, Output: total number of decoding ways.</p> <p>Example: - A = '8', Output = 1 (\"H\") - B = '12', Output = 2 (\"AB\", \"L\")</p>"},{"location":"DSAyy/dp/#karna-kaise-hai_2","title":"Karna kaise hai","text":"<p>Let <code>ways[i]</code> be number of ways to decode <code>A[0...i]</code> (first i characters)</p> <p>Toh iss ke rishte kuch aise honge: - If \\(A[0] = '0'\\), single digit is valid, add <code>ways[i-1]</code> - If <code>A[i-2,i-1]</code> form a valid 2 digit number between 10 and 26, add <code>ways[i-2]</code></p> <p>Base cases: - \\(ways[0] = 1\\) (empty string banane ka there is only one way) - \\(ways[1] = 1 \\text{ if A[0] } \\neq '0', \\text{ else 0}\\)</p> <pre><code>int numDecodings(string A){\n    int n = A.length();\n    const int MOD = 1e9 + 7;\n    if (n == 0) return 0;\n    vector&lt;int&gt; ways(n+1,0);\n    ways[0] = 1;\n    ways[1] = (A[0] != '0')? 1 : 0;\n    for (int i = 2; i &lt;= n; ++i){\n        char c1 = A[i-1], c0 = A[i-2];\n        if (c1 != '0')\n            ways[i] = (ways[i] + ways[i-1]) % MOD;\n        if (c0 == '1' || (c0 == '2' &amp;&amp; c1 &lt;= '6'))\n            ways[i] = (ways[i] + ways[i-2]) % MOD;\n    }\n    return ways[n];\n}\n</code></pre>"},{"location":"DSAyy/dp/#stairs","title":"Stairs","text":""},{"location":"DSAyy/dp/#legendary-beginner-problem","title":"Legendary beginner problem","text":"<p>You are climbing a staircase with A steps. You can climb either 1 or 2 steps; How many distinct ways can you reach the top?</p> <p>Input: A = 2, Output = 2 (<code>[1,1],[2]</code>)</p>"},{"location":"DSAyy/dp/#karna-kaise-hai_3","title":"Karna kaise hai","text":"<p>Let \\(waysToStep[n]\\) be the number of ways to reach step n</p> <p>$$     waysToStep[i] = waysToStep[i-1] + waysToStep[i-2] $$ Some facts: \\(waysToStep[0] = 1\\) (1 way to stay at the bottom) \\(waysToStep[1] = 1\\) (climb one step)</p> <pre><code>int climbStairs(int A){\n    if (A &lt;= 1) return 1;;\n    int prev = 1, curr = 2;\n    for (int i = 3; i &lt;= A; ++i) {\n        int next = prev + curr;\n        prev = curr;\n        curr = next;\n    }\n    return curr;\n}\n</code></pre>"},{"location":"DSAyy/dp/#longest-increasing-subsequence","title":"Longest Increasing Subsequence","text":""},{"location":"DSAyy/dp/#problem-kya-hai_2","title":"Problem kya hai","text":"<p>Given array of integers A, find the length of Longest Increasing Subsequence.</p> <p>Example: - <code>A = [1,2,1,5]</code> Output: 3 (LIS = <code>[1,2,5]</code> )</p>"},{"location":"DSAyy/dp/#karna-kaise-hai_4","title":"Karna kaise hai","text":"<p>BINARY SEARCH BITCH - Maintain a list <code>tail</code> where <code>tail[i]</code> is the smallest possible tail value of an increasing subsequence of length <code>i+1</code> - <code>tail[i]</code> is the smallest possible value that can end a increasing subsequence of length <code>i+1</code>  - For each x in A:     - Use lower_bound to find the first element in tail \\(\\geq\\) x.     - If none, append x (increase the LIS length)     - Otherwise, replace it. (keep tail as small as possible for future extensions)         - the older value was bigger than x, and it wouldn't be a valid increasing subsequence ending at <code>i</code> so we replace the bigger value withh this new pookie. Length of the tail at the end is the ans</p> <pre><code>int lis(vector&lt;int&gt; &amp;A){\n    vector&lt;int&gt; tail;\n    for (int x : A){\n        auto it = lower_bound(tail.begin(),tail.end(), x);\n        // find first el &gt;= x\n        if (it == tail.end())\n            tail.push_back(x);\n        else \n            *it = x;\n    }\n    return tails.size();\n}\n</code></pre>"},{"location":"DSAyy/dp/#intersecting-chords-in-a-circle","title":"Intersecting chords in a circle","text":"<p>Given an integer \\(A\\) return the number of ways to draw A chords in a circle with \\(2A\\) points, such that no two chords intersect. Two ways are different if atleast one chord is present in one way but not the other. Return modulo \\(10^9 + 7\\)</p> <p>Example: - A = 1, Output = 1 - A = 2, Output = 2</p>"},{"location":"DSAyy/dp/#how-tho","title":"How tho","text":"<p>The number of ways to draw A non-intersecting chords on 2A points on a circle is the A-th Catalan number. $$ C_0 = 1, \\space \\space C_n = \\sum_{i=0}^{n-1} C_i \\times C_{n-1 - i} $$ where \\(C_n\\) is the number of valid chord drawings with n chords.</p> <pre><code>int chordCut(int A){\n    const int MOD = 1e9 + 7;\n    vector&lt;long long&gt; C(A+1, 0);\n    C[0] = 1;\n    for (int n = 1; n &lt;= A; ++n){\n        long long ways = 0;\n        for (int i = 0; i &lt; n; ++i){\n            ways = (ways + C[i] * C[n-1-i]) % MOD;\n        }\n        C[n] = ways;\n    }\n    return (int)C[A];\n}\n</code></pre>"},{"location":"DSAyy/dp/#birthday-bombs","title":"Birthday Bombs","text":""},{"location":"DSAyy/dp/#problem","title":"Problem","text":"<p>Tengu has N friends. Each friend \\(i\\) has a positive strength \\(B[i]\\) and can kick tengu any number of times. Tengu has pain resistance limit A. Find lexicographically smallest array of max pos length of friend indices, where each friend index can appear any number of times, such that their sum of strengths is \\(\\leq\\) A.</p>"},{"location":"DSAyy/dp/#how_1","title":"How","text":"<ul> <li>Max num of kicks: \\(M = \\frac{A}{w_{min}}\\)   where \\(w_{min}\\) is the min val in B.</li> <li>At each kick pos, to keep ans smallest, try each friend in asc order and pick the lowest index friend whose cost allows enough resistance for remaining M-1 kicks, all possibly using the cheapest friend.</li> <li>After choosing, subtract from capacity and continue.</li> </ul> <pre><code>vector&lt;int&gt; smallKicks(int A, vector&lt;int&gt;&amp; B){\n    int N = B.size();\n    int w_min = *min_element(B.begin(),B.end());\n    int M = A/w_min;\n    if (M == 0) return {};\n    vector&lt;int&gt; ans;\n    long long cap = A; // remaining capacity\n    for (int pos = 0; pos &lt; M; ++pos){\n        int rem = M - pos - 1;\n        for (int i = 0; i &lt; N; ++i){\n            long long cost_i = B[i];\n            long long needed_for_rest = 1LL* rem * w_min;\n            if (cost_i + needed_for_rest &lt;= cap){\n                ans.push_back(i);\n                cap -= cost_i;\n                break;\n            }   \n        }\n    }\n    return ans;\n}\n</code></pre>"},{"location":"DSAyy/dp/#jump-game-array","title":"Jump Game Array","text":""},{"location":"DSAyy/dp/#problem_1","title":"Problem","text":"<p>Given array A with non-neg int, you are at index 0. Each element <code>A[i]</code> is the max jump len from pos i. Determine if you can reach the last index.</p> <p>Example - \\(A = [2,3,1,1,4]\\) , Output = 1 - \\(A = [3,2,1,0,4]\\) , Output = 0</p>"},{"location":"DSAyy/dp/#how_2","title":"How:","text":"<p>Keep track of <code>maxReach</code> index, like the farthest we can reach - for each index i, if i &gt; maxReach, we are stuck, return 0 - warna update maxReach and move on</p> <pre><code>int canJump(vector&lt;int&gt; &amp;A){\n    int n = A.size();\n    long long maxReach = 0;\n    for (int i = 0; i &lt; n; ++i){\n        if (i &gt; maxReach) return 0;\n        maxReach = max(maxReach, (long long i) + A[i]);\n        if (maxReach &gt;= n-1) return 1;\n    }\n    return 1;\n}\n</code></pre>"},{"location":"DSAyy/dp/#min-jumps-array","title":"Min Jumps Array","text":""},{"location":"DSAyy/dp/#problem_2","title":"Problem","text":"<p>Given array A with non-neg int, you are at index 0. Each <code>A[i]</code> represents the max jump length from that pos. Return the min number of jumps required to reach the last index. If not pos, return -1.</p>"},{"location":"DSAyy/dp/#how_3","title":"How","text":"<p>Use a greedy BFS - <code>current_end</code> : the farthest index we can reach with current jumps - <code>furthest</code> : farthest we can reach with one more jump - for every i in \\([0,current\\_end]\\) , update furthest to the farthest you can go. - when i reaches current_end, increment jump count, and extend curr_end to furthest. - if current_end cannot be extended, return -1 <pre><code>int jump(vector&lt;int&gt; $A){\n    int n = A.size();\n    if (n &lt;= 1) return 0;\n    if (A[0] == 0) return -1;\n    int jumps = 0, current_end = 0, furthest = 0;\n    for (int i = 0; i+1 &lt; n; ++i){\n        furthest = max(furthest, i + A[i]);\n        if (i == current_end){\n            jumps++;\n            current_end = furthest;\n            if (current_end &gt;= n-1) return jumps;\n            if (current_end == i) return -1;\n        }\n    }\n    return (current_end &gt;= n -1)? jumps : -1;\n}\n</code></pre></p>"},{"location":"DSAyy/dp/#longest-arithmetic-progression","title":"Longest Arithmetic Progression","text":""},{"location":"DSAyy/dp/#problem-statement-ass","title":"Problem statement (ass)","text":"<p>Given int arr A of size N, find len of longest AP in A. AP is a seq where consec elements ka diff is same.</p> <p>Example: - <code>A = [3,6,9,12]</code> Output: 4 - <code>A = [9,4,7,2,10]</code> Output: 3 (4,7,10)</p>"},{"location":"DSAyy/dp/#kya-kyu-kaise","title":"Kya Kyu Kaise","text":"<ul> <li>Let <code>ap[i][j]</code> be the len of longest AP ending at i,j</li> <li>For each j &gt; i, try to find a pehle ka index <code>k</code> such that <code>A[k]</code> , <code>A[i]</code>, <code>A[j]</code> form an AP.</li> <li>Agar waise kuch exists, se<code>ap[i][j]</code> = <code>ap[k][i] + 1</code> (matlab AP goes on), warna <code>ap[i][j] = 2</code> (atleast 2 number toh hai ye dono bhai)</li> <li>Use hashmap for finding last occurence</li> </ul> <pre><code>int longestAP(vector&lt;int&gt; &amp;A){\n    int n = A.size();\n    if (n &lt;= 2) return n;\n    map&lt;int,int&gt; occ;\n    vector&lt;vector&lt;int&gt;&gt; ap(n+1, vector&lt;int&gt;(n+1,0));\n    for (int i = 0; i &lt; n; ++i){\n        for (int j = i+1; j &lt; n; ++j){\n            int x = 2*A[i] - A[j]; // aise we find prev element\n            if (occ.find(x) != occ.end()){\n                // ap ki legacy goes on\n                ap[i][j] = max(ap[i][j], 1 + ap[mp[x]][i]);\n            }\n            else {\n                ap[i][j] = 2;\n            }\n            ans = max(ans,ap[i][j]);\n        }\n        mp[A[i]] = i;\n    }\n    return ans;\n}\n</code></pre>"},{"location":"DSAyy/dp/#n-digit-numbers-with-digit-sum-s","title":"N digit numbers with digit sum S","text":""},{"location":"DSAyy/dp/#problem-statement_3","title":"Problem Statement","text":"<p>Given 2 integers N and S, find out the num of N-digit numbers whose digit sum to S.  Note valid num dont have leading zeroes. Return ans \\(modulo \\space 10^9 + 7\\)</p> <p>Example: N = 2, S = 4, Output = 4 (numbers = 13,22,31,40)</p>"},{"location":"DSAyy/dp/#kaise","title":"Kaise?","text":"<p>Let \\(dp[sum]\\) be the num of ways to get sum <code>sum</code> with a fixed number of digits so far. First digit ke liye we can only put 1-9. Uske aage we can put 0-9 For each pos, update all possible digit sum using the prev position ka possibilities.</p> <pre><code>int digitSum(int N, int S){\n    const int MOD = 1e9 + 7;\n    vector&lt;int&gt; dp(S+1,0), next_dp(S+1,0);\n    // first digit wala base case\n    for (int d=  1; d &lt;= 9; ++d) \n        if (d &lt;= S) dp[d] = 1;\n    for (int pos = 2; pos &lt;= N; ++pos){\n        fill(next_dp.begin(),next_dp.end(), 0);\n        for (int sum = 0; sum &lt;= S; ++sum){\n            if (dp[sum] == 0) continue; // we have nothing to add\n            for (int d = 0; d &lt;= 9; ++d){\n                if (sum + d &gt; S) break;\n                // jitne bhi next sum possible hai, sab ke ways add karde\n                next_dp[sum + d] = (next_dp[sum + d] + dp[sum]) % MOD; \n            }\n        }\n        // calculations update kar de\n        dp.swap(next_dp);\n    }\n    return dp[S];\n}\n</code></pre>"},{"location":"DSAyy/dp/#shortest-common-superstring","title":"Shortest Common Superstring","text":""},{"location":"DSAyy/dp/#problem-kya-yap-kar-raha_1","title":"Problem kya yap kar raha","text":"<p>Given a set of strings A of len N, return len of shortest string that contains all string in A as substrings.</p> <p>Example: - \\(A = ['aaaa', 'aa'],\\space  Output = 4\\)  (superstring : \"aaaa\") - <code>A = [abcd,cdef,fgh,de]</code> Output: 8 (superstring : \"abcdefgh\")</p>"},{"location":"DSAyy/dp/#how-the-fuck","title":"How the fuck","text":"<p>Pehle toh remove any string that is a substring of another For all pairs <code>i,j</code> precompute maximum suffix-prefix ka overlap between <code>A[i]</code> and <code>A[j]</code>. Ab let <code>dp[mask][last]</code> be the min len superstring for set of strings mask, ending at string <code>last</code>. Transition: For every mask, for every mask, try adding any <code>nxt</code> not in the mask The cost to add <code>A[nxt]</code> after <code>A[last]</code> is  $$ |A[nxt]| - overlap[last][nxt] $$ Matlab length of <code>A[nxt]</code> - overlap between <code>A[last]</code> and <code>A[nxt]</code> Then the answer would be min of <code>dp[all-used][last]</code></p> <p>Iska code thoda heavy hai <pre><code>int computeOverlap(string a, string b){\n    int maxLen = min(a.size(),b.size());\n    for (int k = maxLen, k &gt; 0; --k){\n        if (a.substr(a.size()-k,k) == b.substr(0,k)){\n            return k;\n            // agar a ke last k matches b ke first k, toh its better to join them\n        }\n    }\n}\n\nint minComSups(vector&lt;string&gt; &amp;A){\n    int n = A.size();\n    if (n == 0) return 0;\n    // remove substrings coz time na waste kar yaar\n    vector&lt;bool&gt; keep(n,true);\n    for (int i = 0; i &lt; n; ++i){\n        if (!keep[i]) continue;\n        for (int j = 0; j &lt; n; ++j){\n            if (i == j || !keep[j]) continue;\n            if (A[i].find(A[j]) != string::npos)\n                keep[j] = 0;\n            else if (A[j].find(A[i]) != string::npos){\n                keep[i] = false;\n                break;\n            }\n        }\n    }\n    vector&lt;string&gt; strs;\n    for (int i = 0; i &lt; n; ++i) if (keep[i]) strs.push_back(A[i]);\n    A.swap(strs); // cleaned A by removing faaltu ke subtrs\n    // precompute overlap\n    vector&lt;vector&lt;int&gt;&gt; overlap(n, vector&lt;int&gt;(n,0));\n    for (int i = 0; i &lt; n; ++i){\n        for (int j = 0; j &lt; n; ++j){\n            if (i == j) continue;\n            overlap[i][j] = computeOverlap(A[i],A[j]);\n        }\n    }\n    // ab finally dp\n    int FULL = 1 &lt;&lt; n, INF = 1e9;\n    vector&lt;vector&lt;int&gt;&gt; dp(FULL, vector&lt;int&gt;(n,INF));\n    // min com supstr of A[i] ending at i is A[i] bhai duh\n    for (int i = 0; i &lt; n; ++i) dp[i &lt;&lt; i][i] = A[i].length();\n\n    for (int mask = 0; mask &lt; FULL; ++mask){\n        for (int last = 0; last &lt; n; ++last){\n            if (!(mask &amp; (1 &lt;&lt; last))) continue;\n            // agar last pehle compute kar rakha then continue\n            int curLen = dp[mask][last];\n            if (curLen == INF) continue; // not computed, abhi bhi default value hai\n            int rem = (~mask) &amp; (FULL - 1);\n            for (int nxt = 0; nxt &lt; n; ++nxt){\n                if (!(rem &amp; (1 &lt;&lt; nxt))) continue; // nxt already in mask\n                int add = (int)A[nxt].size() - overlap[last][nxt];\n                int newMask = mask | (1 &lt;&lt; nxt);\n                dp[newMask][nxt] = min(dp[newMask][nxt],curLen + add);\n            }\n        }\n    }\n    int ans = INF, finalMask = FULL - 1;\n    for (int last = 0; last &lt; n; ++last)\n        ans = min(ans, dp[finalMask][last]);\n    return ansl\n}\n</code></pre></p>"},{"location":"DSAyy/dp/#ways-to-color-a-3-x-n-board","title":"Ways to color a 3 x N Board.","text":""},{"location":"DSAyy/dp/#problem_3","title":"Problem","text":"<p>Given 3xA board, find ways to color it using atmost 4 colors such that no two baaju wala cells have the same color. Return ans modulo \\(10^9 + 7\\)</p> <p>Example:  - A = 1, ans = 36 - A = 2, ans = 588</p>"},{"location":"DSAyy/dp/#how-the-fuck_1","title":"How the fuck","text":"<p>DP with State Compression Each column can be colored in \\(4 \\times 3 \\times 3 = 36\\) ways. Choose colors for top, middle, and bottom. All different from adjacent vertically. Let <code>patterns[i]</code> mean i-th valid color pattern for a column. Let <code>compatList[i]</code> as the set of prev column patterns compatible with i (no color repeats in any row) Let <code>dp[i]</code> be the number of ways so far if the rightmost column uses the pattern i. So the transition would be: $$ nextDP[i] = \\sum_{j \\in compatList[i]} dp[j] $$ So pehle, Gemerate all 36 valid column colorings  Now for each pattern, build a list of compatible previous patterns Then bas ways add karde of all that are compatible</p> <pre><code>const int MOD = 1e9 + 7;\nvector&lt;array&lt;int,3&gt;&gt; buildAllPatterns(){\n    vector&lt;array&lt;int,3&gt;&gt; patterns;\n    for (int c0 = 0; c0 &lt; 4; ++c0){\n        for (int c1 = 0; c1 &lt; 4: ++c1){\n            if (c1 == c0) continue; // valid nahi hai\n            for (int c2 = 0; c2 &lt; 4: ++c2){\n                if (c2 == c1) continue;\n                patterns.push_back({c0,c1,c2});\n            }\n        }\n    }\n}\n\nvector&lt;vector&lt;int&gt;&gt; buildCompat(vector&lt;array&lt;int,3&gt;&gt; &amp;patterns){\n    int M = patterns.size();\n    vector&lt;vector&lt;int&gt;&gt; compatList(M);\n    for (int i = 0; i &lt; M; ++i){\n        for (int j = 0; j &lt; M; ++j){\n            bool ok = 1;\n            for (int r = 0; r &lt; 3; ++r){\n                //check the rows incase adj nikale toh not okk\n                if (patterns[i][c] == patterns[j][c]){\n                    ok = 0;\n                    break;\n                }\n            }\n            if (ok) compatList[i].push_back(j);\n        }\n    }\n    return compatList;\n}\n\nint color(int A){\n    int N = A:\n    if (N &lt;= 0) return 0;\n    vector&lt;array&lt;int,3&gt;&gt; patterns = buildAllTriples();\n    vector&lt;vector&lt;int&gt;&gt; compatList = buildCompat(patterns);\n    // ways of coloring i columns is dp[i]\n    vector&lt;int&gt; dp(36,1), next_dp(36,0);\n    for (int col = 2; col &lt;= N; ++col){\n        for (int i = 0; i &lt; 36; ++i) nextDP[i] = 0;\n        for (int i = 0; i &lt; 36; ++i){\n            long long sumWays = 0;\n            for (int j : compatList[i]){\n                sumWays += dp[j];\n                if (sumWays &gt;= MOD) sumWays -= MOD;\n            }\n            nextDP[i] = (int)sumWays;\n        }\n        dp.swap(nextDP);\n    }\n    long long answer = 0;\n    for (int i = 0; i &lt; 36; ++i){\n        answer += dp[i];\n        if (answer &gt;= MOD) answer -= MOD;\n    }\n    return (int)answer;\n}\n</code></pre>"},{"location":"DSAyy/dp/#kth-manhattan-distance-neighbourhood","title":"Kth Manhattan Distance Neighbourhood","text":""},{"location":"DSAyy/dp/#what-does-the-problem-say","title":"What does the problem say...","text":"<p>Given a Matrix \\(n \\times m\\) and int K, for every el <code>M[i][j]</code>, find the max el in K-Manhattan distance neighborhood.</p> <p>$$ \\text{For each  (i,j), compute }  max{M[p][q] \\space | \\space |i-p| + |j-q| \\leq K }</p> <p>$$ Example:  - M = \\(\\begin{bmatrix} 1 &amp; 2 &amp; 4 \\\\ 4 &amp; 5 &amp; 8 \\end{bmatrix}\\) , K = 2, The output would be \\(\\begin{bmatrix} 5 &amp; 8 &amp; 8 \\\\ 8 &amp; 8 &amp; 8 \\end{bmatrix}\\) </p>"},{"location":"DSAyy/dp/#how-to-look-at-neighbors","title":"How to look at neighbors?","text":"<p>We use K rounds of DP. At each round d, for every cell (i,j), we compute the max amongst itself and 4 neighbors {up down left right} from the previous round. This way after K rounds, we would have max val within manhattan distance K.</p> <pre><code>vector&lt;vector&lt;int&gt;&gt; KMan(int A, vector&lt;vector&lt;int&gt;&gt; &amp;B){\n    int n = B.size();\n    if (n == 0) return {};\n    int m = B[0].size(), K = A;\n    vector&lt;vector&lt;int&gt;&gt; dp_prev(n, vector&lt;int&gt;(m)), curr(n, vector&lt;int&gt;(m));\n    // prev would have the max comparisons from the last round\n    for (int i = 0; i &lt; n; ++i) \n        for (int j = 0; j &lt; m; ++j) dp_prev[i][j] = B[i][j];\n    const int dir[4][2] = {{-1,0}, {1,0}, {0,-1}, {0,1}};\n    for (int d = 1; d &lt;= K; ++d){\n        for (int i = 0; i &lt; n; ++i) {   \n            for (int j = 0; j &lt; m; ++j){\n                int best = dp_prev[i][j];\n                for (auto [x,y] : dir){\n                    int ni = i + x, nj = j + y;\n                    if (ni &gt;= 0 &amp;&amp; ni &lt; n &amp;&amp; nj &gt;= 0 &amp;&amp; nj &lt; m)\n                        best = max(best, dp_prev[ni][nj]);\n                }\n                dp_curr[i][j] = best;\n            }\n        }\n        dp_prev.swap(dp_curr);\n    }\n    return dp_prev;\n}\n</code></pre>"},{"location":"DSAyy/dp/#best-time-to-buy-and-sell-stocks-at-most-b-times","title":"Best time to buy and sell stocks at most B times.","text":""},{"location":"DSAyy/dp/#problem-statement_4","title":"Problem statement","text":"<p>Given an array A of size N, where <code>A[i]</code> is the price of the stock on day i, and an integer B, find the maximum profit possible with atmost B transactions.  A transaction consists of buying and selling stocks.</p> <p>Example: - \\(A[i] = [2,4,1]\\)  B = 2 =&gt; Output = 2</p>"},{"location":"DSAyy/dp/#how_4","title":"How","text":"<p>If \\(B \\geq N/2\\) , you can trade kitna bhi. So the ans is just the sum of all the upward movements. If \\(B &lt; N/2\\) , USE DP.      Let \\(dp[k][i]\\) be the max profit with at index i with atmost k transactions.     $$     dp[k][i] = max(dp[k][i], A[i] + max_{j &lt; i}(dp[k-1][j] - A[j]))     $$     But instead of looping purra, we can just maintain the best price.     $$     bestPrice = max(dp[k-1][j] - A[j])      $$     Maintain this as we move ahead with i.</p> <pre><code>int BuySellB(vector&lt;int&gt; &amp;A, int B){\n    int N = A.size();\n    if (N &lt; 2 || B == 0) return 0;\n    if (B &gt;= N/2){\n        // as many transactions as we want\n        int profit = 0;\n        for (int i = 1; i &lt; N; ++i)\n            if (A[i] &gt; A[i-1]) \n                profit += A[i] - A[i-1];\n        return profit;\n    }\n    // otherwise we use normal dp\n    vector&lt;vector&lt;int&gt;&gt; dp(B+1, vector&lt;int&gt;(N,0));\n    for (int k = 1; k &lt;= B; ++k){\n        int bestPrev = dp[k-1][0] - A[0];\n        for (int i = 1; i &lt; N; ++i){\n            dp[k][i] = max(dp[k][i-1], A[i] + bestPrev);\n            bestPrev = max(bestPrev, dp[k-1][i] - A[i]);\n        }\n    }\n    return dp[B][N-1];\n}\n</code></pre>"},{"location":"DSAyy/dp/#coins-in-a-line","title":"Coins in a Line","text":""},{"location":"DSAyy/dp/#problem_4","title":"Problem","text":"<p>Array A of coins in a line (len n is even). Two players take turns picking either leftmost or the rightmost coin. Each want to maximise their total. Assume you go first. Return max money you can win.</p> <p>Example - \\(A = [1,2,3,4]\\) =&gt; Output = 6 - \\(A = [5,4,8,10]\\) =&gt; Output = 15</p>"},{"location":"DSAyy/dp/#explanation","title":"Explanation","text":"<p>Let \\(dp[i][j]\\) be the max money you can get from \\(A[i...j]\\) if its your turn. - If you pick \\(A[i]\\), your opponent faces \\(A[i+1...j]\\) and will min your future gain     - You get \\(A[i] + min(dp[i+2][j],dp[i+1][j-1] )\\)  - If you pick \\(A[j]\\) , you get \\(A[j] + min(dp[i][j-2], dp[i+1][j-1])\\)  - Take max of both</p> <pre><code>int maxCoin(vector&lt;int&gt; &amp;A){\n    int n = A.size();\n    if (n == 0) return 0;\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 0));\n    for (int i = 0; i &lt; n; ++i) dp[i][i] = A[i];\n    for (int i = 0; i +1 &lt; n; ++i) dp[i][i+1] = max(A[i],A[i+1]);\n\n    for (int len = 3; len &lt;= n; ++len){\n        for (int i = 0; i + len &lt; n; ++i){\n            int j = i + len - 1;\n            int pickLeft = A[i] + min(\n                (i+2 &lt;= j ? dp[i+2][j] : 0),\n                (i + 1 &lt;= j-1 ? dp[i+1][j-1] : 0);\n            );\n            int pickRight = A[i] + min(\n                (i &lt;= j-2 ? dp[i][j-2] : 0),\n                (i+1 &lt;= j-1 ? dp[i+1][j-1] : 0)\n            );\n            dp[i][j] = max(pickLeft, pickRight);\n        }\n    }\n    return dp[0][n-1];\n}\n</code></pre>"},{"location":"DSAyy/dp/#evaluate-expression-to-true","title":"Evaluate Expression To True","text":""},{"location":"DSAyy/dp/#problem_5","title":"Problem","text":"<p>Boolean expression de rakha, count ways to parenthesize A such that it evaluates to true. Return ans modulo 1003. Example: - A = \"T|F\" =&gt; 1 - A = \"T^TF\" =&gt; 0</p>"},{"location":"DSAyy/dp/#how_5","title":"How","text":"<p>Let n be len of A. There are (n+1)/2 operands (at even pos). Let <code>dp_t[i][j]</code> be the number of ways to evaluate operands i to j to true. Let <code>dp_f[i][j]</code> be the number of ways to eval operands i to j to false. - Part at k: <code>[i..k]</code> and <code>[k+1..j]</code>, operator <code>A[2k + 1]</code> - For each operator, count ways to get T/F by comb results from L and R subprobs.</p> <pre><code>int cntTrue(string A){\n    const int MOD = 1003;\n    int n = A.size();\n    int m = (n+1)/2;\n    vector&lt;vector&lt;int&gt;&gt; dp_t(m, vector&lt;int&gt; (m,0));\n    vector&lt;vector&lt;int&gt;&gt; dp_f(m, vector&lt;int&gt; (m,0));\n    // initialize single characters\n    for (int k = 0; k &lt; m; ++k){\n        char c = A[2*k]; // every operand is at even index\n        if (c == 'T') dp_t[k][k] = 1;\n        else dp_f[k][k] = 1;\n    } \n    // fill dp for substr of increasing len\n    for (int len = 2; len &lt;= m; ++len){\n        for (int i = 0; i &lt; len -1 &lt; m; ++i){\n            int j = i + len - 1;\n            int waysT = 0, waysF= 0;\n            for (int k = i; k &lt; j; ++k){\n                char op = A[2*k + 1]; //operator between the operands\n                int lt = dp_t[i][k], lf = dp_f[i][k];\n                int rt = dp_t[k+1][j], rf = dp_f[k+1][j];\n                int totL = (lt + rt) % MOD;\n                int totR = (rt +rf) % MOD;\n                if (op == '&amp;'){\n                    waysT += lt*rt;\n                    waysF += totL*totR - lt*rt;\n                }\n                else if (op == '|'){\n                    waysF += lf * rf;\n                    waysT += totL*totR - lt*rt;\n                }\n                else if (op == '^'){\n                    waysT += lt*rf + lf*rt;\n                    waysF += lt*rt + lf*rf;\n                }\n            }\n            dp_t[i][j] = waysT;\n            dp_f[i][j] = waysF;\n        }\n    }\n    return dp_t[0][m-1];\n}\n</code></pre>"},{"location":"DSAyy/dp/#egg-drop-problem","title":"Egg Drop Problem","text":""},{"location":"DSAyy/dp/#problem-toh-zindagi-meh-hai","title":"Problem toh zindagi meh hai","text":"<p>Given A Eggs, and building with B floors. Find min moves reqd to find the critical floor C (such that any egg dropped above C would break, and at or below C would not). Each move, you may drop egg from any floor. An egg that breaks cannot be used again.</p> <p>Input : 2 integers, A and B. Example: - A = 1, B = 2, output = 2 - A = 2, B = 10, output = 4</p>"},{"location":"DSAyy/dp/#_1","title":"????","text":"<p>Let <code>dp[k]</code> be max num of floors you can test k eggs and m moves. $$ dp[k] = 1 + dp[k] + dp[k-1] $$ Drop an egg - If it breaks, you have <code>k-1</code> eggs, <code>m-1</code> moves left. (<code>dp[k-1]</code>) - if it doesn't, you have k eggs and m-1 moves left. <code>dp[k]</code> floors +1 for current floor being tested.</p> <pre><code>int eggDrop(int A, int B){\n    vector&lt;int&gt; dp(A+1,0); // dp[k] = max floor with k eggs\n    int moves = 0;\n    while (dp[A] &lt; B){ // we have to test atleast all the floors to be certain\n        moves ++;\n        for (int k = A; k &gt;= 1; --k)\n            dp[k] += dp[k-1] + 1;\n    }\n    return moves;\n}\n</code></pre>"},{"location":"DSAyy/dp/#best-time-to-buy-and-sell-stocks-3","title":"Best time to buy and sell stocks 3","text":"<p><code>A[i]</code> is the price of stock on day <code>i</code>. Find the max possible profit by making atmost 2 interactions. You must sell before you buy again.</p> <p>Example - \\(A = [1,2,1,2]\\) Output is 2 - \\(A = [7,2,4,8,7]\\) Output is 6</p>"},{"location":"DSAyy/dp/#kaise_1","title":"Kaise","text":"<ul> <li>Let <code>firstBuy</code> be max profit after first buy (-ve )</li> <li>let <code>firstSell</code> be the max profit after first sell.</li> <li>let <code>secondBuy</code> be max prof after second buy (= profit after first sell - price)</li> <li>let <code>secondSell</code> max prof after second sell. On each day we update thse</li> </ul> <pre><code>int buySell3(vector&lt;int&gt;&amp; A){\n    int n = A.size();\n    if (n &lt; 2) return 0;\n    int firstBuy = INT_MIN, secondBuy = INT_MIN;\n    int firstSell = 0, secondSell = 0;\n    for (int price : A){\n        firstBuy = max(firstBuy, -price);\n        firstSell = max(firstSell, firstBuy + price);\n        secondBuy = max(secondBuy, firstSell - price);\n        secondSell = max(secondSell,secondBuy + price);\n    }\n    return secondSell;\n}\n</code></pre>"},{"location":"DSAyy/dp/#longest-valid-parentheses","title":"Longest Valid Parentheses","text":""},{"location":"DSAyy/dp/#problem-statement_5","title":"Problem Statement","text":"<p>Given a string A, having bracket sequence, find the len of longest valid bracket substring.</p> <p>Example - A = \"(()\" -&gt; 2 - A = \")()())\" -&gt; 4</p>"},{"location":"DSAyy/dp/#how_6","title":"How","text":"<p>Let <code>dp[i]</code> be the len of longest val substring ending at i If <code>A[i]</code> = ), then     <code>A[i-1]</code> = (: tab \\(dp[i] = 2 + dp[i-2]\\) <code>A[i-1]</code> = ): tab try to match with pehle ka (. if <code>A[i]</code> = (: <code>dp[i]</code> = 0</p> <pre><code>int longValBra(string A){\n    int A = A.size();\n    if (n &lt; 2) return 0;\n    vector&lt;int&gt; dp(n,0);\n    int ans = 0;\n    for (int i = 1; i &lt; n; ++i){\n        if (A[i] == ')'){\n            if (A[i-1] == '(')\n                dp[i] = 2 + (i &gt;= 2? dp[i-2] : 0);\n            else {\n                int prevLen = dp[i-1];\n                int openIndex = i - prevLen - 1;\n                if (openIndex &gt;= 0 &amp;&amp; A[openIndex] == '('){\n                    dp[i] = prevLen + 2;\n                    if (openIndex &gt;= 1){\n                        dp[i] += dp[openIndex - 1];\n                    }\n                }\n            }\n            ans = max(ans,dp[i]);\n        }\n    }\n    return ans;\n}\n</code></pre>"},{"location":"DSAyy/dp/#max-edge-queries","title":"Max Edge Queries","text":""},{"location":"DSAyy/dp/#problem_6","title":"Problem","text":"<p>Given a tree with N nodes, and N-1 edges with weight. Answer Q queries in the form of (u,v). For each query, return the maximum weight of any edge on the simple path from U to V Input: Array A of \\(N-1 \\times 3\\) dimension. Contains \\([u,v,w]\\)  B = \\(Q \\times 2\\) array, containing queries \\([u,v]\\)</p>"},{"location":"DSAyy/dp/#how_7","title":"How","text":"<p>This is the classic Lowest Common Ancestor query with path maximum edge using binary lifting.</p> <p>For each node v, and for each \\(2^k\\) th ancestor of v:     \\(up[k][v]\\) : \\(2^k\\) th ancestor of v     \\(maxEdgeUp[k][v]\\) : max edge wt from v up to its \\(2^k\\) ancestor To answer a query (u,v):     Lift u and v to the same height, tracking maxEdge     if \\(u \\neq v\\) , keep lifting until their parents match (to make a path)     Compare max edges on both path</p> <pre><code>const int MAXN = 100000, LOGN = 17;\nvector&lt;pair&lt;int,int&gt;&gt; adj[MAXN + 1];\nint up[LOGN+1][MAXN+1];\nint maxEdgeUp[LOGN+1][MAXN+1];\nint depth[MAXN+1];\n\nint lca_maxEdge(int u, int v){\n    int ans = 0;\n    if (depth[u] &lt; depth[v]) swap(u,v);\n    int diff = depth[u] - depth[v];\n    for (int k = 0; k &lt;= LOGN; ++k){\n        if (diff &amp; (1 &lt;&lt; k)){\n            ans = max(ans, maxEdgeUp[k][u]);\n            u = up[k][u];\n        }\n    }\n    if (u == v) return ans;\n    for (int k = LOGN; k &gt;= 0; --k){\n        if (up[k][u] != 0 &amp;&amp; up[k][u] != up[k][v]){\n            ans = max(ans, maxEdgeUp[k][u]);\n            ans = max(ans, maxEdgeUp[k][v]);\n            u = up[k][u];\n            v = up[k][v];\n        }\n    }\n    ans = max(ans,maxEdgeUp[0][u]);\n    ans = max(ans,maxEdgeUp[0][v]);\n    return ans;\n}\n\nvector&lt;int&gt; mxEdgeQueries(vector&lt;vector&lt;int&gt;&gt; &amp;A, vector&lt;vector&lt;int&gt;&gt; &amp;B){\n    int N = A.size() + 1;\n    for (int i = 1; i &lt;= N; ++i) adj[i].clear();\n    for (&amp;e : A){\n        auto [u,v,w] = e;\n        adj[u].push_back({v,w});\n        adj[v].push_back({u,w});\n    }\n    function&lt;void(int,int,int,int)&gt; dfs = [&amp;](int u, int p, int w, int ht){\n        depth[u] = ht;\n        up[0][u] = p;\n        maxEdgeUp[0][u] = w;\n        for (auto [v,wt] : adj[u]){\n            if (v == p) continue;\n            dfs(v,u,wt,ht+1);\n        }\n    };\n    dfs(1,0,0,0);\n    for (int k = 1; k &lt;= LOGN; ++k){\n        for (int v = 1; v &lt;= N; ++V){\n            int mid = up[k-1][v];\n            up[k][v] = up[k-1][mid];\n            maxEdgeUp[k][v] = max(maxEdgeUp[k-1][v], maxEdgeUp[k-1][mid]);\n        }\n    }\n    vector&lt;int&gt; ans;\n    for (auto [u,v] : B)\n        ans.push_back(lca_maxEdge(u,v));\n    return ans;\n}\n</code></pre>"},{"location":"DSAyy/dp/#max-sum-path-in-a-binary-tree","title":"Max Sum Path in a binary tree","text":""},{"location":"DSAyy/dp/#problem-statement_6","title":"Problem statement","text":"<p>Given a bin tree, find max path sum. A path can start and end at any node, and must be continuous. Inp: root ptr, output: Integer</p>"},{"location":"DSAyy/dp/#how_8","title":"How","text":"<p>For each node: best path is current node + max gain from left + max gain from right for parent, you only only pass along either left or right (not both)</p> <p>Approach: DFS keeping a global max at each node:     compute left and right gain     update global max : node-&gt;val + leftGain + rightGain     return to parent : node-&gt;val + max(leftGain, rightGain)</p> <pre><code>static int globalMax;\nint dfsMaxGain(TreeNode* node){\n    int (!node) return 0;\n    int leftGain = max(0,dfsMaxGain(node-&gt;left));\n    int rightGain = max(0,dfsMaxGain(node-&gt;right));\n    int currentSum = node -&gt;val + leftGain + rightGain;\n    globalMax = max(globalMax, currentSum);\n    return node-&gt;val + max(leftGain, rightGain);\n}\nint solve(TreeNode*A){\n    globalMax = INT_MIN;\n    dfsMaxGain(A);\n    return globalMax;\n}\n</code></pre>"},{"location":"DSAyy/dp/#kingdom-war","title":"Kingdom War","text":""},{"location":"DSAyy/dp/#problem_7","title":"Problem","text":"<p>Given \\(N \\times M\\) grid A const of strength (can be -ve) of a village. Grid is non-decreasing both row-wise and col-wise, find max sum of any rectangular submatrix.</p> <p>Input: <pre><code>3 3\n-5 -4 -1\n-3  2  4\n 2  5  8\n</code></pre> Output -&gt; 19</p>"},{"location":"DSAyy/dp/#how_9","title":"How","text":"<p>Since each cell is \\(\\geq\\) cells above and left, the largest sum always would be from top left (i,j) and bottom-right (N,M) So just 2d prefix sum $$ sum = S_{N,M} - S_{i-1,M} - S_{N,j-1} + S_{i-1, j-1} $$ <pre><code>int maxSm(vector&lt;vector&lt;int&gt;&gt; &amp;A){\n    int N = A.size(), M = A[0].size();\n    vector&lt;vector&lt;int&gt;&gt; S(N+1, vector&lt;int&gt;(M+1,0));\n    for (int i = 1; i &lt;= N; ++i){\n        int rowSum = 0;\n        for (int j = 1; j &lt;= M; ++j){\n            rowSum += A[i-1][j-1];\n            S[i][j] = S[i-1][j] + rowSum;\n        }\n    }\n    int ans = INT_MIN;\n    for (int i = 1; i &lt;= N; ++i){\n        for (int j = 1; j &lt;= M; ++j){\n            int sm = S[N][M] - S[i-1][M] - S[N][j-1] + S[i-1][j-1];\n            ans = max(ans,sm);\n        }\n    }\n    return ans;\n}\n</code></pre></p>"},{"location":"DSAyy/dp/#max-path-in-triangle","title":"Max Path in Triangle","text":""},{"location":"DSAyy/dp/#problem-statement_7","title":"Problem Statement","text":"<p>Given a triang arr A, of size \\(N \\times N\\). find the max path sum from top to bottom. Where each step you move down to an adjacent num on the row below.</p> <p><pre><code>A = [ \n[3, 0, 0, 0]\n[7, 4, 0, 0] \n[2, 4, 6, 0] \n[8, 5, 9, 3] \n]\n</code></pre> Output = 23</p>"},{"location":"DSAyy/dp/#how_10","title":"How","text":"<p>Classic triangle DP Let <code>dp[j]</code> be max path sum to pos j of current row. update dp inplace from left to right</p> <p>$$ dp[j] = max(dp[j-1],dp[j]) + A[i][j] $$ handle leftmost and rightmost separately.</p> <pre><code>int plinko(vector&lt;vector&lt;int&gt;&gt; &amp;A){\n    int N = A.size();\n    if (N == 0) return 0;\n    vector&lt;int&gt; dp(N,0);\n    dp[0] = A[0][0];\n    for (int i = 1; i &lt; N; ++i){\n        dp[i] = dp[i-1] + A[i][i];\n        for (int j = i-1; j &gt; 0; --j){\n            dp[j] = max(dp[j], dp[j-1]) + A[i][j];\n        }\n        dp[0] = dp[0] + A[i][0];\n    }\n    return *max_element(dp.begin(),dp.end());\n}\n</code></pre>"},{"location":"DSAyy/dp/#max-size-square-submatrix","title":"Max size square submatrix","text":""},{"location":"DSAyy/dp/#problem-statement_8","title":"Problem Statement","text":"<p>Matrix A, \\(N \\times M\\). find the area of largest square sub-matrix that contains only 1s. <pre><code>    A = [0, 1, 1, 0, 1],\n        [1, 1, 0, 1, 0], \n        [0, 1, 1, 1, 0], \n        [1, 1, 1, 1, 0], \n        [1, 1, 1, 1, 1], \n        [0, 0, 0, 0, 0] ]\n</code></pre> Output 9</p>"},{"location":"DSAyy/dp/#how_11","title":"How","text":"<p>DP to compute for each cell (i,j) largest size of a square ending at (i,j) Let <code>dp[i][j]</code> be max side len of a square whose bot right corner is at (i,j) if i == 0 or j == 0:     if <code>A[i][j]</code> is 1, <code>dp[i][j]</code> is 1     else 0 warna if <code>A[i][j]</code> is 1 $$ dp[i][j] = 1 + min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])</p> <p>$$</p> <pre><code>int maxArea(vector&lt;vector&lt;int&gt;&gt;&amp; A){\n    int N = A.size();\n    if (N == 0) return 0;\n    int M = A[0].size(), maxSide = 0;\n    vector&lt;int&gt; prev(M,0), curr(M,0);\n    for (int i = 0; i &lt; N; ++i){\n        for (int j = 0; j &lt; M; ++j){\n            if (A[i][j] == 1){\n                if (i == 0 || j == 0)\n                    curr[j] = 1;\n                else \n                    curr[j] = 1 + min({prev[j],prev[j-1],curr[j-1]});\n                maxSide = max(maxSide, curr[j]);\n            }\n            else \n                curr[j] = 0;\n        }\n        prev.swap(curr);\n    }\n    return maxSide*maxSide;\n}\n</code></pre>"},{"location":"DSAyy/dp/#increasing-path-in-matrix","title":"Increasing path in Matrix","text":""},{"location":"DSAyy/dp/#problem_8","title":"Problem","text":"<p>Given a \\(N \\times M\\) matrix A. You can move:     Down: (i,j) to (i+1,j) if <code>A[i+1][j] &gt; A[i][j]</code>     Right: (i,j) to (i,j+1) if <code>A[i][j+1] &gt; A[i][j]</code> Find the len of longest increasing path from (0,0) ending at (N-1,M-1) if no path exists, ret -1;</p> <pre><code>A = [\n    [1, 2, 3, 4], \n    [2, 2, 3, 4], \n    [3, 2, 3, 4], \n    [4, 5, 6, 7] ] \n    Output: 7 // 1\u21922\u21923\u21924\u21925\u21926\u21927\n</code></pre>"},{"location":"DSAyy/dp/#how_12","title":"How","text":"<p>Let <code>dp[i][j]</code> be len of longst val path from (0,0) to (i,j) <code>dp[0][0]</code> = 1 (only itself) Now for every new, just take max path up and left and add 1</p> <pre><code>int maxPath(vector&lt;vector&lt;int&gt;&gt; &amp;A){\n    int N = A.size();\n    if (N == 0) return -1;\n    int M = A[0].size();\n    if (M == 0) return -1;\n    vector&lt;vector&lt;int&gt;&gt; dp(N, vector&lt;int&gt; (M,0));\n    dp[0][0] = 1;\n    for (int i = 0; i &lt; N; ++i){\n        for (int j = 0; j &lt; M; ++j){\n            if (i == 0 &amp;&amp; j == 0) continue;\n            int best = 0;\n            if (i &gt; 0 &amp;&amp; A[i][j] &gt; A[i-1][j] &amp;&amp; dp[i-1][j] &gt; 0)\n                best = max(best, dp[i-1][j] + 1);\n            if (j &gt; 0 &amp;&amp; A[i][j] &gt; A[i][j-1] &amp;&amp; dp[i][j-1] &gt; 0)\n                best = max(best, dp[i][j-1] + 1);\n            dp[i][j] = best;\n        }\n    }\n    return dp[N-1][M-1] &gt; 0? dp[N-1][M-1] : -1;\n}\n</code></pre>"},{"location":"DSAyy/dp/#min-difference-subsets","title":"Min difference subsets","text":""},{"location":"DSAyy/dp/#problem_9","title":"Problem","text":"<p>Int array A, partition it into two subsets S1, and S2, so that abs diff between their sum is minimized. Return the min possible difference.</p> <p>Example</p> <p>\\(A = [1, 6, 11, 5]\\) Output: 1</p>"},{"location":"DSAyy/dp/#explanation_1","title":"Explanation","text":"<p>Let total sum be S best we can dop is find a subset with sum <code>s</code> as close as S/2. then the other sum is S - s and abs diff is |S - 2s| Use dp to track which sums s s \\(\\leq\\) S/2 are possible.</p> <pre><code>int minDifSub(vector&lt;int&gt; &amp;A){\n    int N = A.size();\n    int tot = accumulate(A.begin(),A.end(),0);\n    int targ = tot / 2;\n    vector&lt;bool&gt; dp(targ + 1, false);\n    dp[0] = true;\n    for (int x : A{\n        for (int s = target; s &gt;= x; --s){\n            if (dp[s-x]) dp[s] = true;\n        }\n    }\n    for (int s = target; s &gt;= 0; --s)\n        if (dp[s])\n            return (tot - 2*s);\n    return tot;\n}\n</code></pre>"},{"location":"DSAyy/dp/#subset-sum-problem","title":"Subset sum problem","text":""},{"location":"DSAyy/dp/#problem_10","title":"Problem","text":"<p>Given int arr A, and int B. Is there a subset of A whose sum is B? \\(A = [3, 34, 4, 12, 5, 2]\\), B = 9 Output: 1 (Because 4 + 5 = 9)  \\(A = [3, 34, 4, 12, 5, 2]\\), B = 30 Output: 0 (No subset sums to 30)</p>"},{"location":"DSAyy/dp/#how_13","title":"How","text":"<p>Classic subset DP \\(dp[s]\\) is true if some subset of A sums to s \\(dp[0]\\) = true for each x     now for each s from B down to x         \\(dp[s] = dp[s] \\space | \\space dp[s-x]\\) </p> <pre><code>int isPoss(vector&lt;int&gt;&amp; A, int B){\n    int N = A.size();\n    vector&lt;bool&gt; dp(B+1, false);\n    dp[0] = 1;\n    for (int x :  A){\n        for (int s = B; s &gt;= x; --s)\n            if (dp[s-x]) dp[s] = true;\n    }\n    return dp[B] ? 1 : 0;\n}\n</code></pre>"},{"location":"DSAyy/dp/#unique-paths-in-a-grid-with-obstacles","title":"Unique Paths in a Grid with Obstacles","text":""},{"location":"DSAyy/dp/#problem_11","title":"Problem","text":"<p>\\(M \\times N\\) Grid, start at (1,1) , reach (m,n). Movement only R or D. Grid has obstacles, marked as blocked (1) or empty (0). Count the number of unique paths fomr top left to bot right, avoid obstacles.</p>"},{"location":"DSAyy/dp/#how_14","title":"How","text":"<p>Let <code>dp[j]</code> be ways to reach j in current row. Let <code>dp[0]</code> = 1. Start jaane ka only one  way For each cell (i,j):     if <code>A[i][j]]</code> = 1, set <code>dp[j]</code> = 0. (cant reach here)     else <code>dp[j] += dp[j-1]</code> (add ways from left if j &gt; 0)     upar ke ways would already be here (magical type shit)</p> <pre><code>int uniquePaths(vector&lt;vector&lt;int&gt;&gt; &amp;A){\n    int m = A.size();\n    if (m == 0) return 0;\n    int n = A[0].size();\n    if (A[0][0] || A[m-1][n-1]) return 0; // entry/exit blocked\n    vector&lt;int&gt; dp(n,0);\n    dp[0] = 1;\n    for (int i = 0; i &lt; m; ++i){\n        for (int j = 0; j &lt; n; ++j){\n            if (A[i][j] == 1)\n                dp[j] = 0;\n            else if (j &gt; 0)\n                dp[j] += dp[j-1];\n        }\n    }\n    return dp[n-1];\n}\n</code></pre>"},{"location":"DSAyy/dp/#yaha-se-down-to-up-dp-kinda-starts","title":"Yaha se down to up dp kinda starts","text":""},{"location":"DSAyy/dp/#dungeon-princess-minimum-initial-health-in-a-grid","title":"Dungeon Princess (Minimum Initial Health in a grid)","text":""},{"location":"DSAyy/dp/#problem-statement_9","title":"Problem Statement","text":"<p>Knight at top left, \\(M \\times N\\) dungeon grid, must reach bot right to the princess. Each cell has int. -ve for demons (damage), zero = empty, +ve health Movement: right and down. Find min initial health for knight to reach princess.</p> <p><pre><code>A = [ \n    [-2, -3, 3]\n    [-5, -10, 1]\n    [10, 30, -5] ]\n</code></pre>  Output: 7</p>"},{"location":"DSAyy/dp/#how_15","title":"How","text":"<p>We go from princess to knight. Its just max path from source to dist. let <code>dp[i][j]</code> be min HP upon entering cell (i,j) so that knight can reach the end.     always keeping HP \\(\\geq\\) 1 Base:     <code>dp[m-1][n-1]</code> = max(1, 1 - <code>A[m-1]][n-1]</code>)  Protection from negatives Fill last row and col, and Reverse DP     <code>dp[i][j]</code> = max(1,min(<code>dp[i+1][j]</code>,<code>dp[i][j+1]</code> - <code>A[i][j]</code>))</p> <pre><code>int calcminHP(vector&lt;vector&lt;int&gt;&gt; &amp;A){\n    int m = A.size();\n    if (m == 0) return 0;\n    int n = A[0].size();\n    vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n,0));\n    dp[m-1][n-1] = max(1, 1 - A[m-1][n-1]);\n    for (int i = m-2; i &gt;= 0; --i)\n        dp[i][n-1] = max(1, dp[i+1][n-1] - A[i][n-1]); // health we need down + this\n    for (int j = n-2; j &gt;= 0; --j)\n        dp[m-1][j] = max(1,dp[m-1][j+1] - A[m-1][j]); // health we need on right + this\n    for (int i = m-2; i &gt;= 0; --i){\n        for (int j = n-2; j &gt;= 0; --j){\n            int needNext = min(dp[i+1][j], dp[i][j+1]);\n            dp[i][j] = max(1, needNext - A[i][j]);\n        }\n    }\n    return dp[0][0];\n}\n</code></pre>"},{"location":"DSAyy/dp/#min-sum-path-in-a-matrix","title":"Min sum path in a matrix","text":""},{"location":"DSAyy/dp/#problem-statement_10","title":"Problem Statement","text":"<p>Given a \\(M \\times N\\) int grid. Find path from top left to bot right with min path sum. You can go Down or Right.</p>"},{"location":"DSAyy/dp/#how_16","title":"How","text":"<p>Basic DP Just keep adding elements and comparing top and left. In the first row, elements can only come from left. In the first col, elements can only come from top. Baaki normally \\(dp[i][j] = A[i][j] + min(dp[i-1][j], dp[i][j-1])\\)</p> <pre><code>int minPathSum(vector&lt;vector&lt;int&gt;&gt; &amp;A){\n    int m = A.size();\n    if (m == 0) return 0;\n    int n = A[0].size();\n    vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt; (n,0));\n    dp[0][0] = A[0][0];\n    // first row, only from left\n    for (int j = 1; j &lt; n; ++j)\n        dp[0][j] = dp[0][j-1] + A[0][j];\n    // first col\n    for (int i = 1; i &lt; m; ++i)\n        dp[i][0] = dp[i-1][0] + A[i][0];\n    for (int i = 1; i &lt; m; ++i){\n        for (int j = 1; j &lt; n; ++j){\n            dp[i][j] = A[i][j] + min(dp[i-1][j], dp[i][j-1]);       \n    return dp[m-1][n-1];\n}\n</code></pre>"},{"location":"DSAyy/dp/#min-path-sum-in-triangle","title":"Min Path Sum in Triangle","text":""},{"location":"DSAyy/dp/#problem_12","title":"Problem","text":"<p>Triangle arr de rakha, min path sum top to bot nikal. Movement, adjacent numbers on the row below.  $$     A[i][j] \\text{ can go to A[i+1][j] and A[i+1][j+1]} $$</p>"},{"location":"DSAyy/dp/#how_17","title":"How","text":"<p>Let \\(dp[j]\\) be min path sum to reach pos j in the current row. We start from bot and move up Let dp = last row of the triangle. Now for each row, update <code>dp[j]</code> as \\(A[i][j] + min(dp[j],dp[j+1])\\) Ans: \\(dp[0]\\) is the min path sum</p> <pre><code>int minTot(vector&lt;vector&lt;int&gt;&gt; &amp;A){\n    int n = A.size();\n    if (n == 0) return 0;\n    vector&lt;int&gt; dp = A[n-1];\n    for (int i = n-2; i &gt;= 0l --i)\n        for (int j = 0; j &lt;= i; ++j)\n            dp[j] = A[i][j] + min(dp[j], dp[j+1]);\n    return dp[0];\n}\n</code></pre>"},{"location":"DSAyy/dp/#max-rectangle-in-binary-matrix","title":"Max Rectangle in Binary Matrix","text":""},{"location":"DSAyy/dp/#problem_13","title":"Problem","text":"<p>Given a 2D bin matrix. Find largest rectangle with all 1s. return its area</p> <p><pre><code>A = [1 1 1]\n    [0 1 1]\n    [1 0 0]\n</code></pre> Ans = 4</p>"},{"location":"DSAyy/dp/#explanation_2","title":"Explanation","text":"<p>Largest rectangle in histogram I see. For each row, build a histogram of consec 1s. For each row, use a stack to compute largest area in \\(O(m)\\) time. Return max found over all.</p> <pre><code>int maximalRect(vector&lt;vector&lt;int&gt;&gt; &amp;A){\n    int n = A.size();\n    if (n == 0) return 0;\n    int m = A[0].size();\n    vector&lt;int&gt; heights(m,0);\n    int maxArea = 0;\n    for (int i = 0; i &lt; n; ++i){\n        // update the height list.\n        for (int j = 0; j &lt; m; ++j){\n            if (A[i][j] == 1) heights[j]++;\n            else heights[j] = 0;\n        }\n        // largest rect\n        stack&lt;int&gt; st;\n        for (int j = 0; j &lt;= m; ++k){\n            int h = (j == m? 0: heights[j]);\n            while (!st.empty() &amp;&amp; h &lt; heights[st.top()]){\n                int height = heights[st.top()];\n                st.pop();\n                int width = st.empty() ? j : (j - st.top() - 1);\n                maxArea = max(maxArea, height * width);\n            }\n            st.push(j);\n        }\n    }\n    return maxArea;\n}\n</code></pre>"},{"location":"DSAyy/dp/#rod-cutting-dp-and-reconstruction","title":"Rod Cutting -- DP and reconstruction","text":""},{"location":"DSAyy/dp/#problem_14","title":"Problem","text":"<p>Rod len A, int arr B of M weak points (cut locations). We must cut at every weak point. Each cut splits a segment into two smaller rods. cost of cut = length of segment in which the cut is made.  Order is up to us.  Return the sequence of curs that achieves the min total cost. If there are many, return the lexicographically smallest.</p> <p>Example: A = 6, B = \\([1,2,5]\\)  Best ans -&gt; 2 1 5 : gives cost 6 + 2 + 4 = 12</p>"},{"location":"DSAyy/dp/#how_18","title":"How","text":"<p>Add 0 and A to the cut positions, and sort. P = \\([0,sorted(B),A]\\)  Let M be the new len = len(B) + 2</p> <p>Let <code>dp[i][j]</code> be the min cost to cut the segment (\\(P_i, P_j)\\) . That is making a cut between the positions \\(P_i\\) and \\(P_j\\)  if (j = i+1), <code>dp[i][j]</code> = 0, coz then we can have no cuts. (kuch hai hi nahi beech meh) else  <code>dp[i][j]</code> = \\(min_{i&lt;k&lt;j} ((P_j - P_i) + dp[i][k] + d[k][j])\\) So basically len of the segment + baaki dono subproblems.</p> <p>Ab bhai lexicographical order check karna. Let <code>cutpos[i][j]</code> be the index k of the first cut that jisne min cost diya. Bas isse compare karke minimum select karle</p> <p>Now for reconstruction Rec(i,j) = {} if j = i+1, coz kuch hai hi nahi beech me     and {\\(P_k\\)} + merge(Rec(i,k),Rec(k,j)) otherwise Basic recursion</p> <pre><code>#python coz this code is hella big\ndef rod_cutting(A,B):\n    B.sort()\n    P = [0] + B + [A]\n    n = len(P)\n    dp = [[0]*n for _ in range(n)]\n    cutpos = [[-1]*n for _ in range(n)]\n    #fill the dp table\n    for length in range(2,n):\n        for i in range(n - length):\n            j = i + length\n            min_cost = float('inf')\n            best_k = -1\n            for k in range(i+1,j):\n                cost = P[j] - [i] + dp[i][k] + dp[k][j]\n                if cost &lt; min_cost  or (cost == min_cost and P[k] &lt; P[best_k]):\n                    min_cost = cost\n                    best_k = k\n            dp[i][j] = min_cost\n            cutpos[i][j] = best_k\n    result = [] #to be reconstructed\n    def reconstruct(i,j):\n        k = cutpos[i][j]\n        if (k == -1): return\n        result.append(P[k])\n        reconstruct(i,k)\n        reconstruct(k,j)\n    reconstruct(0,n-1)\n    return result\n</code></pre>"},{"location":"DSAyy/dp/#queen-attack-grid-scan-technique","title":"Queen Attack (Grid Scan Technique)","text":""},{"location":"DSAyy/dp/#problem_15","title":"Problem","text":"<p>\\(N \\times M\\) chessboard, with some cells having queens. For each cell (i,j) compute how many queens can attack it (assuming no queen at (i,j)). No queens can jump over other queens.</p>"},{"location":"DSAyy/dp/#how_19","title":"How","text":"<p>Normal 8D traversal For each direction, sweep through the board and record if a queen has already been encountered in that direction. Sum up the result for all 8 directions for each cell.</p> <pre><code>def queen_attack(grid):\n    n = len(grid)\n    m = len(grid[0])\n    dirs = [(-1,0),(1,0), (0,-1), (0,1),\n            (-1,-1), (-1,1), (1,-1), (1,1)]\n    attack_count = [[0]*m for _ in range(n)]\n    for dx, dy in range(dirs):\n        seen = [[0]*m for _ in range(n)] #queen already seen in this direction\n        x_range = range(n) if dx &gt;= 0 else range(n-1,-1,-1)\n        y_range = range(n) if dy &gt;= 0 else range(m-1,-1,-1)\n\n        for x in x_range:\n            for y in y_range:\n                nx, ny = x-dx, y - dy\n                if 0 &lt;= nx &lt; n and 0 &lt;= ny &lt; m:\n                    seen[x][y] = seen[nx][ny]\n                if grid[x][y] == '1':\n                    seen[x][y] = 1\n                elif seen[x][y]:\n                    attack_count[x][y] += 1\n    return attack_count\n</code></pre>"},{"location":"DSAyy/dp/#dice-throw-num-of-ways-to-get-a-given-sum","title":"Dice Throw: Num of ways to get a given sum","text":""},{"location":"DSAyy/dp/#problem_16","title":"Problem","text":"<p>Given A num of dice, each with face 1 to B. Find num of ways to roll these dice such that the sum of the numbers shown on the dice is exactly C. Return modulo 1e9  + 7</p>"},{"location":"DSAyy/dp/#how_20","title":"How","text":"<p>Counting DP Let <code>dp[a][s]</code> be num of ways to roll <code>a</code> dice such that their sum is s. We know <code>dp[0][0]</code> = 1 (1 way to get sum 0 with 0 dice) and <code>dp[0][s]</code> = 0 for s &gt; 0</p> <p>Transition $$ dp[a][s] = \\sum_{k = 1}^{B} dp[a-1][s-k] \\text{ for s } \\geq k $$ <pre><code>def num_ways_to_sum(A,B,C):\n    MOD = 10**9 + 7\n    if C &lt; A or C &gt; A*B:\n        return 0\n    prev = [0]*(C+1)\n    prev[0] = 1\n    for a in range(1,A+1):\n        prefix = [0]*(C+1)\n        prefix[0] = prev[0]\n        for s in range(1,C+1):\n            prefix[s] = (prefix[s-1] + prev[s]) % MOD\n        curr = [0]*(C+1)\n        for s in range(0,C+1):\n            if s == 0:\n                curr[s] = 0\n            else:\n                right = prefix[s-1]\n                left = prefix[s-B-1] if s - B -1 &gt;= 0 else 0\n                curr[s] = (right - left + MOD) % MOD\n        prev = curr\n    return prev[c]\n</code></pre></p>"},{"location":"DSAyy/dp/#submatrices-with-sum-zero","title":"Submatrices with Sum Zero","text":"<p>2D Matrix of int. Count num of non-empty submatrices with sum 0. Example</p> <p>-8  5  7  3  7  -8  5 -8  9</p> <p>Output = 2</p>"},{"location":"DSAyy/dp/#how_21","title":"How","text":"<p>KADANE!!! (and prefix sum)</p> <p>Fix 2 rows, top and bottom. For each column, compute sum of elements betweem these two rows inclusive. Now just count zero-sum subarrays in the collapsed column sums array.</p> <pre><code>def countZeroSumSubmatrics(matrix):\n    if not matrix or not matrix[0]:\n        return 0\n    rows,cols = len(matrix), len(matrix[0])\n    total = 0\n    for top in range(rows):\n        col_sums = [0]* cols\n        for bottom in range(top,rows):\n            for c in range(cols):\n                col_sums[c] += matrix[bottom][c]\n            # count 0 sum subarrs in col_sums\n            prefix_freq = {0:1} #psum to freq\n            prefix = 0\n            for val in col_sums:\n                prefix += val\n                total += prefix_val.get(prefix,0) # get freq of psum 0\n                prefix_freq[prefix] = prefix_freq.get(prefix,0) + 1\n    return total\n</code></pre>"},{"location":"DSAyy/dp/#coin-sum-infinite","title":"Coin sum infinite","text":"<p>Given a set of unique coins. Find diff ways to get sum B using infinite supply of these coins. A = 1 2 3 B = 4 Output = 4</p>"},{"location":"DSAyy/dp/#how_22","title":"How","text":"<p>Unbounded knapsack let dp(s) store num of ways to get sum s dp(0) = 1 (one way to make 0 sum) for each coin in A, iterate through all pos sum s from c to B and dp(s) = (dp(s) + dp(s-c)) mod</p> <pre><code>def coinChange2(A,B):\n    MOD = 10**9 + 7\n    n = len(A)\n    dp = [0]*(B+1)\n    dp[0] = 1\n    for coin in A:\n        for s in range(coin,B+1):\n            dp[s] = (dp[s] + dp[s-coin]) % MOD\n    return dp[B]\n</code></pre>"},{"location":"DSAyy/dp/#max-prod-subarray","title":"Max prod subarray","text":""},{"location":"DSAyy/dp/#problem_17","title":"Problem","text":"<p>int arr A, find a contig subarray which has largest prod. return the prod.</p> <p>Example A = 2 3 -2 4 Output = 6</p>"},{"location":"DSAyy/dp/#how_23","title":"How","text":"<p>Unlike normal kadane, we have to track both max and min prod at each step, due to presence of -ve nums A -ve num can turn the smallest into the largest <code>maxEnding</code> = max prod ending at cur index <code>minEnding</code> = min prod ending at cur index</p> <p>if el is -ve, swap maxEnding and minEnding then update     maxEnding = \\(max(x,maxEnding \\times x)\\)     minEnding = \\(min(x,minEnding \\times x)\\)</p> <pre><code>def maxProdSubarr(A):\n    maxEnding = A[0]\n    minEnding = A[0]\n    ans = A[0]\n    for i in range(1,n):\n        x = A[i]\n        if x &lt; 0:\n            maxEnding,minEnding = minEnding,maxEnding\n        maxEnding = max(x,maxEnding * x)\n        minEnding = min(x,minEnding * x)\n        ans = max(ans, maxEnding)\n    return ans\n</code></pre>"},{"location":"DSAyy/dp/#best-time-to-buy-and-sell-stock-1","title":"Best time to buy and sell stock 1","text":""},{"location":"DSAyy/dp/#problem_18","title":"Problem","text":"<p>int arr A, <code>A[i]</code> is price of stock on day i Allowed one transaction, buy and sell once. Find max poss profit. </p> <p>Example A = 1 2 Output = 1 Input 1 4 5 2 4 Output: 4</p> <p>How: <code>minPrice</code> Min price seen so far maxProfit = <code>A[i]</code> - minPrice then update then price</p> <pre><code>def buySell(A):\n    minPrice = A[0]\n    maxProfit = 0\n    for i in (1,len(A)):\n        maxProfit = max(maxProfit, A[i] - minPrice)\n        minPrice= min(minPrice, A[i])\n    return maxProfit\n</code></pre>"},{"location":"DSAyy/dp/#arrange-ii","title":"Arrange II","text":""},{"location":"DSAyy/dp/#problem_19","title":"Problem","text":"<p>Given a seq of horses, B means black, W means White and K num of stables. YOu have to assign all horses to stables Each horse is assigned to only one stable Cost of stable = num(White horses) \\(\\times\\) num(Black horses) Total cost is sum of all stable cost Stables cannot be non empty If not possible to assign, return -1</p> <p>Example A = <code>WWWB</code>, K = 2 Output = 0 Arrangement: {WWW}, {B}</p>"},{"location":"DSAyy/dp/#how_24","title":"How","text":"<p>We have to DP with partition Let DP state be min cost of placing first i horses into k stables     dp(i,k): min cost to place first i horses into k stables     cost(j+1,i): cost of placing horses from index j+1 to i in one stable So we build psum fopr white and black horses so we can compute cost(j+1,i) in constant time.</p> <p>Transition will look like $$ dp[i][k] = min_{j = k-1}^{i-1} (dp[j][k-1] + cost(j+1,i)) $$ so min cost to place first i horses into k stables is min cost to place any first k horses in k-1 stables and rest of them in a new stable</p> <p>dp(0,0) = 1 if i &lt; k: we cannot have k non-empty stables.</p> <pre><code>def arrange(A,B):\n    N = len(A)\n    if N &lt; B:\n        return -1\n    w = [0]*(N+1) #psum for white and black horses\n    b= [0]*(N+1)\n    for i in range(1,N+1):\n        w[i] = w[i-1] + (A[i-1] == 'W')\n        b[i] = b[i-1] + (A[i-1]=='B')\n    def cost(i,j):\n        return (w[j]-w[i-1])*(b[j] - b[i-1])\n    INF = 10**15\n    dp = [[INF]* (B+1) for _ in range(N+1)]\n    dp[0][0] = 1\n    for i in range(1,N+1):\n        for k in range(1,B+1):\n            for j in range(k-1,i):\n                if dp[j][k-1] == INF:\n                    continue\n                c = cost(j+1,i)\n                dp[i][k] = min(dp[i][k], dp[j][k-1] + c)\n    return dp[N][B] if dp[N][B] &gt;= INF else -1\n</code></pre>"},{"location":"DSAyy/dp/#chain-of-pairs","title":"Chain of Pairs","text":""},{"location":"DSAyy/dp/#problem_20","title":"Problem","text":"<p>Given list of pairs A, where pair (a,b) has a &lt; b. pair (c,d) can follow (a,b) in a chain if b &lt; c. Find max len of chain of such pairs preserving relative order. Pairs can be skipped but not rearranged</p> <p>Exampkle A = (5,24) (39,60) (15,28) (27,40) (50,90) Output = 3</p>"},{"location":"DSAyy/dp/#how_25","title":"How","text":"<p>Its like longest increasing subsequence but with custom comparator First sort pairs by first element Let dp(i) be longest chain ending at i for each pair i, check previous pairs and if A(j,1) &lt; A(i,0):     update dp(i) = max(dp(i), dp(j) + 1)</p> <pre><code>def pairLIS(A):\n    N = len(A)\n    dp = [1]*(N)\n    ans = 1\n    for i in range(0,N):\n        for j in range(0,i):\n            if A[j][1] &lt; A[i][0]:\n                dp[i] = max(dp[i], dp[j] + 1)\n        ans = max(ans, dp[i])\n    return ans\n</code></pre>"},{"location":"DSAyy/dp/#max-sum-without-adjacent-elements","title":"Max Sum without adjacent elements","text":""},{"location":"DSAyy/dp/#problem-statement_11","title":"Problem Statement","text":"<p>Given a \\(2 \\times N\\) grid A, select subsets of elements such that:     sum of selected nums is maximised     no two selected elements are adjacent horizontally vertically or diagonally</p> <p>Example: </p> <pre><code>1 2 3 4\n2 3 4 5\n</code></pre> <p>Output = 8</p>"},{"location":"DSAyy/dp/#how_26","title":"How","text":"<p>This is a variation of classical house robber problem extended to two rows</p> <p>maintain 3 dp states dp0 be maxsum picking nothing in this column dp1 be maxsi, picking the top cell dp2 be maxsum picking the bottom cell</p> <p>Transitions: dp0 = max(dp0, dp1,dp2) dp1 = dp0 + top(k) dp2 = dp0 + bottom(k)</p> <pre><code>def adjacent(A)\n    N = len(A[0])\n    T,B = A[0],A[1]\n    dp0,dp1,dp2 = 0, T[0], B[0]\n    for k in range(1,N):\n        dp0_n = max([dp0,dp1,dp2])\n        dp1_n = dp0 + T[k]\n        dp2_n = dp0 + B[k]\n        dp0,dp1,dp2 = dp0_n,dp1_n,dp2_n\n    return max([dp0,dp1,dp2])\n</code></pre>"},{"location":"DSAyy/dp/#merge-elements","title":"Merge Elements","text":""},{"location":"DSAyy/dp/#problem_21","title":"Problem","text":"<p>Given int arr, merge all elements into one by repeatedly merging 2 adjacent elements. Rule: merging X and Y, cost is X+Y, val is also X+Y return min total cost.</p> <p>Example:</p> <p>A =  1 3 7 Output 15</p> <p>costs : 4 + 11 = 15</p>"},{"location":"DSAyy/dp/#how_27","title":"How","text":"<p>This is a variation of Matrix Chain Multiplication let  <code>dp(i,j)</code> be min cost to merge <code>A(i to j)</code> sum <code>(i,j)</code> be sum of el from <code>A(i)</code> to <code>A(j)</code></p> <p>For each subarr A(i..j), try every split point k and compute $$ dp[i][j] = min_{k=i}^{j-1} (dp[i][k] + dp[k+1][j] + sum(i,j)) $$ sum(i,j) is ofc prefix sum</p> <pre><code>def mergeElement(A):\n    N = len(A)\n    psum = [0]*(N+1)\n    for i in range(1,N+1):\n        psum[i+1] = psum[i] + A[i]\n    def rangeSum(i,j):\n        return psum[j+1] - psum[i]\n    INF = 10**15\n    dp = [[INF]*(N+1) for _ in range(N+1)]\n    for i in range(N+1):\n        dp[i][i] = 0\n    for length in range(2,N+1):\n        for i in range(0,N - length):\n            j = i + len -1\n            best = INF\n            for k in range(i,j):\n                cost = dp[i][k] + dp[k+1][j] + rangeSum(i,j)\n                best = min(best, cost)\n            dp[i][j] = best\n    return dp[0][N-1]\n</code></pre>"},{"location":"DSAyy/dp/#flip-array","title":"Flip Array","text":""},{"location":"DSAyy/dp/#problem_22","title":"Problem","text":"<p>Array A of +ve int, flip sign of some elements such that resultant sum is as close to 0 as possible We need to minimize the number of elemnts flipped to achieve this.</p> <p>Return the numbers flipped.</p> <p>Example</p> <pre><code>A = 15 10 6\nOutput = 1\nWe just flip 15\n</code></pre>"},{"location":"DSAyy/dp/#how_28","title":"How","text":"<p>Variation of subset sum problem</p> <p>Let total be the arr sum Find a subset of element such that sum is close to total / 2</p> <p>Let dp(s) be the min num of el flipped to get subset sum s</p> <p>dp(0) = 0</p> <p>update from top to down to avoid using same el twice</p> <pre><code>def flip(A):\n    total = sum(A)\n    cap = total/2\n    N = len(A)\n    INF = 10**15\n    dp = [INF]*(N+1)\n    dp[0] = 0\n    for x in A:\n        for s in range(cap,x-1,-1):\n            dp[s] = min(dp[s], dp[s-x] + 1)\n    return min(dp)\n</code></pre>"},{"location":"DSAyy/dp/#tengu-bday-party-unbounded-knapsack","title":"Tengu Bday Party (Unbounded Knapsack)","text":""},{"location":"DSAyy/dp/#problem_23","title":"Problem","text":"<p>Tengu has to feed all his friends. Each friend has an eating capacity. Objective: Satisfy all friends by selecting dishes (each friend eats separately, and can use dishes any number of times). such that total cost is minimized.</p> <p>Example</p> <p>Friends A = 4 6</p> <p>Dish Fillings B = 1 3</p> <p>Dish Cost C = 5 3</p> <p>Output 14</p> <pre><code>Friend 1 eats dish 1  2 : cost: 5 + 3 = 8\nFriend 2 eats dish 2 twice: cost: 3 + 3 = 6\nTotal cost = 8 + 6 = 14\n</code></pre>"},{"location":"DSAyy/dp/#how_29","title":"How","text":"<p>This is a bounded knapsack applied for each friend. But we optimize by precomputing minimum cost to fill any capacity up to max (friend's need), using unbounded knapsack (since dishes can be reused)</p> <p>Let \\(dp[s]\\) be min cost to eat <code>s</code> fill of food.</p> <p>Now for each capacity s, try all dishes and  $$     dp[s] = min_{all\\space dishes}(dp[s], dp[s-fill(dish)] + cost(dish)) $$ Once computed the whole thing, sum up <code>dp[A[i]]</code> for each friend.</p> <pre><code>def unbounded_knapsack(A,B,C):\n    maxFill = max(A)\n    num_dishes = len(B)\n    INF = 10**15\n    dp = [INF]*(maxFill + 1)\n    dp[0] = 1\n    for fill in range(1,maxFill):\n        for j in range(num_dishes):\n            if B[j] &lt;= fill:\n                dp[fill] = min(dp[fill], dp[fill - B[j]] + C[j])\n    totalCost = 0\n    for f in A:\n        totalCost += dp[f]\n    return totalCost\n</code></pre>"},{"location":"DSAyy/dp/#0-1-knapsack","title":"0 - 1 Knapsack","text":"<p>Given A values, B weights, C as the capacity of our knapsack.</p> <p>Select a subset of items such that:     weight does not exceed C     total value is maximised     Either take the whole item or dont take at all</p> <p>Ex:</p> <pre><code>A = 60 100 120\nB = 10 20 30\nC - 50\n</code></pre> <p>Ans is 220 (pick 2 and 3)</p>"},{"location":"DSAyy/dp/#how_30","title":"How","text":"<p>Let \\(dp[w]\\) be max value achievable for capacity \\(w\\)</p> <p>Now the relation is</p> <p>$$ dp[w] = max(dp[w], dp[w - B[i]] + A[i]) $$ Since we can pick each el exactly once, loop backwards.</p> <pre><code>def knapsack_normal(A,B,C):\n    n = len(A)\n    dp = [0]*(C+1)\n    for i in range(n):\n        val,wt = A[i],B[i]\n        for w in range(C,wt-1,-1):\n            dp[w] = max(dp[w], dp[w - wt] + val)\n    return dp[C]\n</code></pre>"},{"location":"DSAyy/dp/#equal-average-partition-subset-sum-wt-avg-equality","title":"Equal Average Partition (subset sum wt avg equality)","text":"<p>Given an int arr A. Partition it into two non-empty subsets \\(A_1\\) and \\(A_2\\) such that:     \\(average(A_1) == average(A_2)\\) \\(|A_1| \\leq |A_2|\\)     even if equal, \\(A_1\\) must be lexicographically smaller Return the two subsets as a 2D array. If nothing, return an empty list.</p> <p>Example:     A = 1 7 15 29 11 9     Output: 9 15 and 1 7 11 29     Both have average 12</p>"},{"location":"DSAyy/dp/#how_31","title":"How","text":"<p>Let S be total sum of arr and n be the size</p> <p>We try all subset sizes k from 1 to \\(n/2\\) </p> <p>For each k, if a subset exists such that \\(\\(sum = \\frac{S\\cdot k}{n}\\)\\) and this sum is an int, then its valid candidate.</p> <p>Use dp with bitset to check reachability: $$ reachable[i][c][s] = true \\iff \\text{we can pick c elements from A[i..n-1] to sum to s}$$ Once it is reachable, reconstruct smallest subset</p> <pre><code>from collections import defaultdict\nfrom functools import lru_cache\n\ndef eq_avg_partition(A):\n    A.sort()\n    n = len(A)\n    total_sum = len(A)\n    @lru_cache(None) # memoise for checking subset existence of size k\n    def is_possible(i,k,target):\n        if k == 0:\n            return target == 0\n        if i &gt;= n or k &lt; 0 or target &lt; 0:\n            return False\n        #pick not pick for A[i]\n        return is_possible(i+1,k,target) or is_possible(i+1,k-1,target-A[i])\n    # reconstruct the actual target\n    def find_subset(i,k,target):\n        subset = []\n        while k &gt; 0:\n            if is_possible(i+1,k-1,target - A[i]):\n                subset.append(A[i])\n                target -= A[i]\n                k -= 1\n            i += 1\n        return subset\n    for k in range(1, n//2 + 1):\n        if (total_sum * k) % n != 0:\n            continue\n        target_sum = (total_sum * k) // n\n        if (is_possible(0,k,target_sum):\n            subset1 = find_subset(0,k,target_sum)\n            # build its complement\n            subset2 = A.copy()\n            for x in subset1:\n                subset2.remove(x)\n            return [subset1,subset2]\n    return []\n</code></pre>"},{"location":"DSAyy/dp/#potion-mixing-for-min-smoke","title":"Potion mixing for min smoke","text":"<p>Given an arr A of N potions, in range \\([0,99]\\), indicating its color. We have mix all into one, following the below rules     Mix only two adjacent potions     Mixing X and Y results in X+Y mod 100 color     smoke generate during a mix is \\(X \\times Y\\)  Find min amount of smoke required to mix all potions into one. A = 2 3 ans = 6 A = 2 3 4 5 ans = 71</p>"},{"location":"DSAyy/dp/#how_32","title":"How?","text":"<p>MCM variant haha loser     Let \\(dp[i][j]\\) be min smoke generated to mix potions from i to j     Let \\(color[i][j]\\) be final color obtained after mixing potions from i to j Base case:     for single potions, no smoke:         \\(dp[i][i] = 0,\\space color[i][i] = A[i]\\)  Relation:     $$     dp[i][j] = min_k(dp[i][k] + dp[k+1][j] + color[i][k] \\times color[k+1][j])     $$     and then just update the color     $$     color[i][j] = (color[i][k] + color[k+1][j])\\space  mod \\space 100     $$</p> <pre><code>def minSmoke(A):\n    if not A: return 0\n    N = len(A)\n    dp = [[0]*(101) for _ in range(101)]\n    color = [[0]*(101) for _ in range(101)]\n    for i in range(N):\n        color[i][i] = A[i] % 100\n    for len in range(2,N+1):\n        for i in range(0,N-len+1):\n            j = i + len - 1\n            dp[i][j] = 10**15 # some max value\n            for k in range(i,j):\n                smoke = dp[i][k] + dp[k+1][j] + color[i][k]*color[k+1][j]\n                if smoke &lt; dp[i][j]:\n                    dp[i][j] = smoke\n                    color[i][j] = (color[i][k] + color[k+1][j]) % 100\n    return dp[0][n-1]           \n</code></pre>"},{"location":"DSAyy/dp/#buy-and-sell-stock-ii","title":"Buy and Sell stock II","text":"<p>Given arr A of prices. Buy and Sell (transaction) any number of times, but not overlapping.</p> <p>Return max pos profit.</p> <p>A = 1 2 3, Output = 2</p>"},{"location":"DSAyy/dp/#how_33","title":"How","text":"<p>This is a greedy problem bruv</p> <p>Just sum all positive differences between \\(A[i] - A[i-1]\\) </p> <pre><code>def maxProfit(A):\n    n = len(A)\n    profit = 0\n    for i in range(1,n):\n        profit += A[i] - A[i-1] if A[i] &gt; A[i-1]\n    return profit\n</code></pre>"},{"location":"DSAyy/dp/#word-break-ii","title":"Word Break II","text":"<p>Given string S and dict of words B, insert spaces into A to construct all possible sentences such that each word is in the dict.     A = catsanddogs     B = cat cats and sand dog     Output = \"cat sand dog\" \"cats and dog\"</p>"},{"location":"DSAyy/dp/#broke-ass-boy","title":"Broke ass boy","text":"<p>This is DFS + Memoization</p> <p><code>dfs(start)</code> would return all valid sentences starting at index <code>start</code> and it would be memoized on dfs.</p> <pre><code>from functools import lru_cache\ndef wordBreak(s,wordDict):\n    word_set = set(wordDict)\n    #lru_cache(maxSize = None)\n    def dfs(start):\n        if start == len(s): return [\"\"]\n        sentences = []\n        for end in range(start + 1, len(s) + 1):\n            word = s[start:end]\n            if word in word_set:\n                for suffix in dfs(end):\n                    sentence = word + (\" \" + suffix if suffix else \"\")\n                    sentences.append(sentence)\n        return sentences\n    result = dfs(0)\n    return sorted(result)\n</code></pre>"},{"location":"DSAyy/dp/#unique-binary-search-trees-ii","title":"Unique Binary Search Trees II","text":"<p>Given int A, compute num of structurally unique BSTs that store value from 1 to A.     A = 3, output = 5</p>"},{"location":"DSAyy/dp/#how_34","title":"How","text":"<p>This is just a Catalan Number dp problem. $$ G(n) = \\text{number of unique BSTs with node n} $$ $$ G(n) = \\sum_{i=1}^{n} G(i - 1) \\cdot G(n-i) $$ G(i-1) counts left subtrees and G(n-i) counts right subtrees. Base Case:  G(0) = 1 (Empty tree)</p> <pre><code>def UniqueBST(A):\n    G = [0]*(A+1)\n    for n in range(1,A+1):\n        for root in range(1,n+1):\n            G[n] += G[root - 1]*G[n - root]\n    return G[A]\n</code></pre>"},{"location":"DSAyy/dp/#count-permutations-of-bst-with-given-height","title":"Count Permutations of BST with Given Height","text":"<p>Given two int A and B, count how many perms of set {1,2..A} produce a BST of height B.     A = 3, B = 1, Output = 2. (2 1 3 and 2 3 1)     Note vals are inserted from L to R     Remember to MOD</p>"},{"location":"DSAyy/dp/#how_35","title":"How","text":"<p>Let \\(dp[n][k]\\) be num of perms of size n that from a BST of height \\(\\leq\\) h</p> <p>Choose a root( say i, which partitions set into left and right subtrees of size i-1 and  n - i)     Left and right subtrees must have height \\(\\leq\\) h-1     $$     dp[n][h] += dp[i-1][h-1] \\cdot dp[n-i][h-1] \\cdot \\binom{n-1}{i-1}     $$     Precompute combinations and use memoization for dp</p> <pre><code>from functools import lru_cache\nimport math\nMOD = 10**9 + 7\nMAX = 51\n\n#precompute n choose k\nchoose [[0]*MAX for _ in range(MAX)]\nfor n in range(MAX):\n    choose[n][0] = choose[n][n] = 1\n    for k in range(1,n):\n        choose[n][k] = (choose[n-1][k-1] + choose[n-1][k]) % MOD\n@lru_cache(maxSize = None)\ndef count_permutations(n,h):\n    if h == 0: return 1 if n &lt;= 1 else 0\n    if n == 0: return 1\n    total = 0\n    for i in range(1,n+1):\n        left = count_permutations(i-1,h-1)\n        right = count_permutations(n-i,h-1)\n        total += (left * right % MOD)* choose[n-1][i-1]\n    return total\ndef count_exact_height_bsts(A,B):\n    at_most_B = count_permutations(A,B)\n    at_most_B_minus_1 = count_permutations(A,B-1)\n    return (at_most_B - at_most_B_minus_1 + MOD) % MOD\n</code></pre>"},{"location":"DSAyy/dp/#palindrome-partitioning-ii","title":"Palindrome Partitioning II","text":"<p>Given string A, partition such that every substring in the partition is a palindrome.</p> <p>Return min cuts needed to achieve such a partition.     A = aba, output = 0 (already palindrome)     A = aab, output = 1  (aa and b)</p>"},{"location":"DSAyy/dp/#how_36","title":"How","text":"<p>Let \\(isPal[i][j]\\) check if A{i..j} is a palindrome. Precompute this. A DP array <code>f[i]</code> representing mincuts needed for substring \\(A[0..i]\\)</p> <p>Transition $$     f[i] = min_{0\\leq j &lt; i}(f[j] + 1) \\text{ if A[j + 1...i] is a palindrome}     $$ <pre><code>def minCut(s: str) -&gt; int:\n    n = len(s)\n    isPalindrome = [[False]*n for _ in range(n)]\n    for i in range(n): isPalindrome[i][i] = True\n    for length in range(2,n+1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                isPalindrome[i][j] = isPalindrome[i+1][j-1] if length != 2 else True\n    f = [float(inf)]*n\n    for i in range(n):\n        if palindrome[0][i]:\n            f[i] = 0\n        else:\n            for j in range(i):\n                if isPalindrome[j+1][i]:\n                    f[i] = min(f[i],f[j] + 1)\n    return f[n-1]\n</code></pre></p>"},{"location":"DSAyy/dp/#word-break","title":"Word Break","text":"<p>Given a string A, and dict B of valid words. Can A be segmented into a space -separated sequence of one or more dict words.</p> <p>Input: A = myinterviewtrainer , B = trainer my interview     Output = 1</p>"},{"location":"DSAyy/dp/#how_37","title":"How","text":"<p>Let \\(dp[i]\\) be true if \\(A[0...i]\\) can be broken into words from dictionary. \\(dp[0]\\) is true , coz empty string is segmentable</p> <p>Iterate over all lengths, and check if any valid suffix ending at <code>i</code> is in the dictionary. To optimize this, we compute max word length in the dict, to reduce the substring checks.</p> <pre><code>def wordBreak(s: str, wordDict: list[str]) -&gt; bool:\n    word_set = set(wordDict)\n    n = len(s)\n    max_word_length = max(len(word) for word in wordDict)\n    dp = [False]*(n+1)\n    dp[0] = 1\n    for i in range(1,n+1):\n        for length in range(1, min(i, max_word_length) + 1):\n            if dp[i-length] and s[i-length:i] in word_set:\n                dp[i] = True\n                break\n    return dp[n]\n</code></pre>"},{"location":"DSAyy/graph/","title":"Graphs","text":""},{"location":"DSAyy/graph/#path-in-a-directed-graph","title":"Path in a directed graph","text":"<p>Directed graph A nodes, node labelled 1 to A. Directed edges B.</p> <p>Determine if a path exists from node 1 to node A.</p>"},{"location":"DSAyy/graph/#how","title":"How","text":"<p>BFS. duh</p> <pre><code>from collections import deque, defaultdict\ndef reachable(A,B) \n    adj = defaultdict(list)\n    for u,v in B:\n        adj[u].append(v)\n    visited = [False]*(A+1)\n    q = deque()\n    visited[0] = True\n    q.append(1)\n    while q:\n        q.popleft()\n        if u == A: return 1\n        for v in adj[u]:\n            if not visited[v]:\n                visited[v] =True\n                q.append(v)\n    return 0    \n</code></pre>"},{"location":"DSAyy/graph/#water-flow","title":"Water Flow","text":"<p>Given a N \\(\\times\\) M matrix A. It represents height of land cells. Determine how many cells can allow water to flow to both the:</p> <p>Blue Lake: which touches top and left border</p> <p>Red Lake: which touches bottom and right border</p> <p>Water can flow from a cell to its neighbors if the neighbors height \\(\\leq\\) cur height</p>"},{"location":"DSAyy/graph/#how_1","title":"How?","text":"<p>Do two BFS traversal</p> <p>one from blue lake connected cells</p> <p>one from red lake connected cells</p> <p>Only flow if height of neighbor \\(\\geq\\) our height</p> <pre><code>from collections import deque\ndef waterFlow(A):\n    n,m = len(A), len(A[0])\n    blue = [[False]*(m+1) for _ in range(n)]\n    red = [[False]*(m+1) for _ in range(n)]\n    qb,qr = deque(), deque()\n    for i in range(n):\n        blue[i][0], red[i][m-1] = True, True\n        qb.append([i,0])\n        qr.append([i,m-1])\n    for j in range(m):\n        blue[0][j], red[n-1][j] = True, True\n        qb.append([0,j])\n        qr.append([n-1,j])\n    dirs = [[1,0],[-1,0], [0,1], [0,-1]]\n    def bfs(q,vis):\n        while q:\n            i,j = q.popleft()\n            for dx,dy in dirs:\n                ni,nj = i + dx, j + dy\n                if 0 &lt;= ni &lt; n and 0 &lt;= nj &lt; m and not vis[ni][nj]:\n                    if A[ni][nj] &gt;= A[i][j]:\n                        vis[ni][nj] = True\n                        q.append([ni,nj])\n    bfs(qb, blue)\n    bfs(qr,red)\n    ans = 0\n    for i in range(n):\n        for j in range(m):\n            if blue[i][j] and red[i][j]: ans += 1\n    return ans\n</code></pre>"},{"location":"DSAyy/graph/#stepping-number","title":"Stepping number","text":"<p>step num: if abs dif between every pair of adjacent digits = 1</p> <p>find all step num in range A to B</p> <p>123 and 321 are stepping nums, but 358 is not</p>"},{"location":"DSAyy/graph/#how_2","title":"How","text":"<p>Perform bfs for each starting from 1 to 9 (and include 0 is A = 0)</p> <p>For each num extract the last digit</p> <p>Append digit that differ by 1 to the current num</p> <p>\\(12 \\times 10 + (2-1) = 121\\)</p> <p>\\(12 \\times 10 + (2+1) = 123\\)</p> <p>bas yahi karte reh until you reach B <pre><code>vector&lt;int&gt; stepNum(int A, int B){\n    vector&lt;int&gt; result;\n    if (A == 0) result.push_back(0);\n    for (int start - 1; start &lt;= 9; ++start){\n        queue&lt;int&gt; q; q.push(start);\n        while (!q.empty()){\n            int num = q.front(); q.pop();\n            if (num &gt; B) continue;\n            if (num &gt;= A) result.push_back(num);\n            int last = num % 10;\n            if (last &gt; 0) q.push(num * 10 + (last - 1));\n            if (last &lt; 9) q.push(num * 10 + (last + 1)) ;\n        }\n    }\n    sort(results.begin(),results.end());\n    return result;\n}\n</code></pre></p>"},{"location":"DSAyy/graph/#capture-regions-on-board","title":"Capture regions on board.","text":"<p>Given a 2d character matrix A size \\(N \\times M\\) , each cell contains either <code>X</code> or <code>0</code>. Capture all regions surrounded by <code>X</code></p> <p>A region is captured by flipping 0s into Xs in that surrounded region.</p> <p>Dont output anything, just change inplace.</p>"},{"location":"DSAyy/graph/#how_3","title":"How","text":"<p>Find all boundary connected 0s,</p> <p>Mark them as # using BFS.</p> <p>Then traverse the entire board and convert unmarked Os into Xs</p> <p>Then convert marked # into 0s</p> <pre><code>from collections import deque\ndef captureRegions(A):\n    n,m = len(A), len(A[0])\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if A[i][j] == 'O':\n                A[i][j] = '#'\n                q.append((i,j))\n    dirs = [[1,0],[-1,0], [0,1], [0,-1]]\n    while q:\n        i,j = q.popleft()\n        for dx,dy in dirs:\n            x,y = i+dx,j + dy\n            if 0 &lt;= x &lt; n and 0 &lt;= y &lt; m and A[x][y] == 'O':\n                A[x][y] = '#'\n                q.append((x,y))\n    for i in range(n):\n        for j in range(m):\n            if A[i][j] == 'O': A[i][j] = 'X'\n            if A[i][j] == '#': A[i][j] = '0'    \n</code></pre>"},{"location":"DSAyy/graph/#word-search-on-a-board","title":"Word Search on a Board","text":"<p>2D char board and a word, determine if word exists in the grid. Word must be constructed through sequentially adjacent cells. Same letter can be used more than once on a cell</p> <p>Board = </p> <p>ABCE</p> <p>SFCS</p> <p>ADEE</p>"},{"location":"DSAyy/graph/#how_4","title":"How","text":"<p>Perform DFS from every cell in the board, check if the word can be constructed starting at that cell. Dont mark visited cells, since it can be resused.</p> <pre><code>def exist(board,word):\n    n,m = len(board), len(board[0])\n    dirs = [[1,0],[-1,0], [0,1], [0,-1]]\n    vis = [[False]*(m) for _ in range(n)]\n    def dfs(i, j ,pos):\n        if board[i][j] != word[pos]: return False\n        if pos == len(word) - 1: return True\n        vis[i][j] = 1\n        for dx,dy in dirs:\n            x,y = i + dx, j + dy\n            if 0 &lt;= x &lt; n and 0 &lt;= y &lt; m:\n                if dfs(i,j,pos+1):\n                    return True\n        vis[i][j] = 0\n        return False\n\n    for i in range(n):\n        for j in range(m):\n            if dfs(i,j,0): return True\n    return False\n</code></pre>"},{"location":"DSAyy/graph/#path-with-good-nodes","title":"Path with Good Nodes","text":"<p>Given a tree with N nodes. Each node is marked good/bad <code>A[i]</code> = 1 means node i+1 is good, warna its bad</p> <p>A 2D array B of (N-1) \\(\\times\\) 2 representing undirected edges of the tree.</p> <p>int C representing max good nodes on a path</p> <p>Compute num of root-to-leaf paths in the tree with atmost C good nodes.</p>"},{"location":"DSAyy/graph/#how_5","title":"How","text":"<p>Perform a dfs from node 1, keeping track of good nodes on the path If good nodes exceed C, prune the path.</p> <pre><code>from collections import defaultdict\ndef goodPath(A,B,C):\n    adj = defaultdict(list)\n    for u,v in B:\n        adj[u].append(v)\n        adj[v].append(u)\n    ans = 0\n    def dfs(node, parent, good_count):\n        if u != 1 and len(adj[u]) == 1:\n            if goodCnt &lt;= C: ans += 1\n            return\n        for v in adj[u]:\n            if v == parent: continue\n            nxtGood = goodCnt + A[v-1]\n            if nxtGood &lt;= C:\n                dfs(v,u,nxtGood)\n    dfs(1,0,A[0])\n    return ans\n</code></pre>"},{"location":"DSAyy/graph/#largest-dist-between-nodes-of-a-tree","title":"Largest Dist between nodes of a tree","text":"<p>Given an unweighted tree with N nodes numbered from 0 to N-1</p> <p>Find largest path in the tree.</p> <p>Given the parent array.</p> <p>if \\(parent[i]\\) = -1? i is the root, warna \\(parent[i]\\) has an edge with i</p>"},{"location":"DSAyy/graph/#how_6","title":"How","text":"<p>Find farthest node from root, then find farthest node from that node. The dist is the ans</p> <pre><code>from collections import defaultdict, deque\n\ndef largestDist(A):\n    n = len(A)\n    if n &lt;= 1: return 0\n    adj = defaultdict(list)\n    root = 0\n    for i in range(n):\n        if A[i] == -1:\n            root = i\n        else:\n            p = A[i]\n            adj[i].append(p)\n            adj[p].append(i)\n    def bfs(start):\n        dist = [-1]*(N)\n        q = deque()\n        dist[start] = 0\n        q.append(start)\n        farNode = start\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] != -1: continue\n                dist[v] = dist[u] + 1\n                q.push(v)\n                farNode = v if dist[v] &gt; dist[farNode] else farNode\n        return (farNode, dist[farNode])\n    u,du = bfs(root)\n    v,dv = bfs(u)\n    return dv\n</code></pre>"},{"location":"DSAyy/graph/#good-graph","title":"Good Graph","text":"<p>Directed Graph, N nodes. Each node points to exactly one node. </p> <p>We are given the parent array.</p> <p>Node is good if</p> <p>it is node 1</p> <p>it is connected to node 1</p> <p>Find min number of edge changes such that all nodes become good.</p>"},{"location":"DSAyy/graph/#how_7","title":"How","text":"<p>So the input is a functional graph where all nodes have out degree 1</p> <p>This may contain many disjoint cycles.</p> <p>We aim to detect all cycles.</p> <p>If a cycle contains node 1, it is already good. </p> <p>If it does notm we must change atleast one point in the cycle to point towards node 1 or another good node.</p> <pre><code>def goodGraph(A):\n    N = len(A)\n    next = [0]*(N)\n    for i in range(N): # convert to 0 based indexing\n        next[i] = A[i] - 1\n    vis = [0]*(N)\n    ans = 0\n    for i in range(N):\n        if vis[i]: continue\n        path = []\n        curr = i\n        while True:\n            vis[curr] = 1\n            path.append(curr)\n            nxt = next[curr]\n            if vis[nxt] == 0:\n                curr = nxt\n            elif vis[nxt] == 1: # this is a cycle\n                containsOne = False\n                n = len(path)\n                for k in range(n-1,-1,-1): # look if 1 is in the cycle\n                    if path[k] == nxt:\n                        for t in range(k,n):\n                            if path[t] == 0:\n                                containsOne = True\n                                break\n                        break\n                if not containOne: \n                    ans += 1\n                break # break once done doin the cycle shit\n            else : break # break if we come across an already processed node\n        for v in path:\n            vis[v] = 2 # mark processed\n    return ans  \n</code></pre>"},{"location":"DSAyy/graph/#cycle-in-directed-graph","title":"Cycle in directed graph","text":"<p>A nodes and M edges Directed, check if it has a cycle</p> <p>B is a list of edges</p>"},{"location":"DSAyy/graph/#how_8","title":"How?","text":"<p>If the graph can be topo sorted, it has no cycles.</p> <p>Topo sort is just bfs but</p> <p>compute indegree of all nodes</p> <p>nodes with indegree 0 go to queue</p> <p>while queue is not empty,</p> <p>increment processed for front node</p> <p>decrease indegree of all neighbors, and if 0, add to queue</p> <p>if processed count is not the same as A, cycle exists</p> <pre><code>from collections import defaultdict, deque\ndef hasCycle(A,B):\n    adj = defaultdict(list)\n    indegree = [0]*(A+1)\n    for u,v in B:\n        adj[u].append(v)\n        indegree[v] += 1\n    q = deque()\n    processed = 0\n    for i in range(1,A+1):\n        if indegree[i] == 0:\n            q.append(i)\n    while q:\n        u = q.popleft()\n        processed += 1\n        for v in adj[u]:\n            indegree[v] -= 1\n            if indegree[v] == 0:\n                q.append(v)\n    return processed != A\n</code></pre>"},{"location":"DSAyy/graph/#delete-edge","title":"Delete Edge!","text":"<p>Given rooted undirected tree with N nodes and arr A having weight of each node. Delete one node such that the product of the sum of weights of the two resulting subtrees is maximised.</p> <p>Example:</p> <p>A = 10 5 12 6</p> <p>B = (1,2) (1,4) (4,3)</p> <p>Output = 270</p> <p>Removing (1,4): output = 15 \\(\\times\\) 18 = 270</p>"},{"location":"DSAyy/graph/#how_9","title":"How","text":"<p>Post order dfs to compute subtree sum at each node for every edge, compute: $$ \\text{Product = Sum of Subtree} \\times (\\text{Total Sum - Sum of Subtree}) $$ <pre><code>from collections import defaultdict\nMOD = 10**9 + 7\n\ndef mxDelEdge(A,B):\n    adj = defaultdict(list)\n    for u,v in B:\n        adj[u].append(v)\n        adj[v].append(u)\n    n = len(A)\n    weights = [0]+A\n    totalSum = sum(weights)\n    maxProd = 0\n    subtreeSum = [0]*(n+1)\n    def dfs(u,parent):\n        nonlocal maxProd\n        subtreeSum[u] = weights[u]\n        for v in adj[u]:\n            if v != parent:\n                dfs(v,u)\n                subtreeSum[u] += subtreeSum[v]\n        prod = subtreeSum[u]*(totalSum - subtreeSum[u])\n        maxProd = max(maxProd,prod)\n    dfs(1,-1)\n    return maxProd % MOD\n</code></pre></p>"},{"location":"DSAyy/graph/#two-teams-if-graph-is-bipartite","title":"Two Teams? (if graph is bipartite)","text":"<p>A people, 1 to A. Divide them into two teams. Given list B of \\(M\\times 2\\) having edges. Person u and v are enemies and cant be on the same team. Determine if its possible to divide them into two teams.</p> <p>A = 5</p> <p>B = (1,2) (2,3) (1,5) (2,4)</p> <p>Output: 1 (Yes)</p>"},{"location":"DSAyy/graph/#how_10","title":"How","text":"<p>Bipartite Coloring kar, if not possible then ret 0</p> <p>BFS to traverse path</p> <p>Assign opp colors to the neighbors</p> <p>If adj nodes have same color, ret 0</p> <p>check all connected components</p> <pre><code>from collections import deque, defaultdict\ndef twoTeamsPossible(A,B):\n    adj = defaultdict(list)\n    for u,v in B:\n        adj[u].append(v)\n        adj[v].append(u)\n    color = [0]*(A+1)\n    q = deque()\n    for i in range(1,A+1):\n        if color[i]: continue # Already processed\n        color[i] = 1\n        q.append(i)\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if color[v] == 0:\n                    color[v] = -color[u]\n                    q.append(v)\n                elif color[v] == color[u]:\n                    return 0\n    return 1\n</code></pre>"},{"location":"DSAyy/graph/#valid-path","title":"Valid Path","text":"<p>Grid of size \\(x \\times y\\) and N circular obstacles of radius R centered inside the grid. Determine if its to go from (0,0) to (x,y) without touching any circular region.</p> <p>Movement:</p> <p>8D including the diagonals</p> <p>Cannot go outside grid boundaries (chutiya hai kya)</p> <p>Cannot step into a cell that intersects any circle</p> <p>Note: a circle blocks a cell (i,j) if the dist from the centre is less than or equal to R</p> <p>Example:</p> <p>x = 2, y= 3, N = 1, R = 1, A = (2), B = (3) Output? No. Circle at (2,3) blocks the path to dest</p>"},{"location":"DSAyy/graph/#how_11","title":"How","text":"<p>Preprocess Blocked Cells</p> <p>$$ (x-a)^2 + (y-b)^2 \\leq R^2 $$ Check this for every cell</p> <p>Perform BFS from 0,0 and check if any one reaches x,y</p> <pre><code>from collections import deque\ndef validPath(x,y,N,R,A,B):\n    blocked = [[False]*(y) for _ in range(x)]\n    center= []\n    for i in range(N):\n        center.append((A[i],B[i]))\n    for i in range(x):\n        for j in range(y):\n            for a,b in center:\n                if (i-a)**2 + (j-b)**2 &lt;= R**2:\n                    blocked[i][j] = True\n    if blocked[0][0] or blocked[x][y]:\n        return 0\n    q = deque()\n    q.append((0,0))\n    visited = [[False]*(y) for _ in range(x)]\n    dir = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),         (0, 1),\n                  (1, -1),  (1, 0),  (1, 1)]\n    while q:\n        i,j = q.popleft()\n        if (i,j) == (x,y): return 1\n        for dx,dy in dir:\n            nx = i+dx, ny= j+dy\n            if 0 &lt;= nx &lt;= x and 0 &lt;= ny &lt;= y:\n                if not blocked[nx][ny] and not visited[nx][ny]:\n                    visited[nx][ny] = 1\n                    q.append((nx,ny))\n    return 0\n</code></pre>"},{"location":"DSAyy/graph/#region-in-binary-matrix","title":"Region in binary matrix","text":"<p>Given binary matrix \\(N \\times M\\) . Each cell is either 1 (filled) or 0 (not).</p> <p>Region is formed by one or more connected components in 8D.</p> <p>Return the size of the largest connected component.</p> <p>Example</p> <p>A = 0 0 1 1 0     1 0 1 1 0     0 1 0 0 0     0 0 0 0 1 Ans : 6</p>"},{"location":"DSAyy/graph/#how_12","title":"How","text":"<p>Simple bfs from every unvisited cell and counting all reachable cells and marking them visited.</p> <pre><code>from collections import deque\ndef largestRegion(A):\n    n,m = len(A), len(A[0])\n    maxRegion = 0\n    seen = [[False]*(m) for _ in range(n)]\n    dir = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),         (0, 1),\n                  (1, -1),  (1, 0),  (1, 1)]\n\n    for i in range(n):\n        for j in range(m):\n            if not seen[i][j] and A[i][j]:\n                regionSize = 0\n                q = deque()\n                q.append((i,j))\n                seen[i][j] = 1\n                while q:\n                    x,y = q.popleft()\n                    regionSize += 1\n                    for dx,dy in dir:\n                        nx,ny = x + dx , y + dy\n                        if 0 &lt;= nx &lt; n and 0 &lt;= ny &lt; m:\n                            if not seen[nx][ny] and A[nx][ny]:\n                                seen[nx][ny] = 1\n                                q.append((nx,ny))\n                maxRegion = max(maxRegion,regionSize)\n    return maxRegion                        \n</code></pre>"},{"location":"DSAyy/graph/#path-in-matrix","title":"Path in Matrix","text":"<p>\\(N \\times M\\) matrix where 0 -&gt; wall (cant move), 1 -&gt; source, 2 -&gt; dest, 3 -&gt; blank (can move through)</p> <p>4D movement. Check if path exists from source to destination</p>"},{"location":"DSAyy/graph/#how_13","title":"How","text":"<p>BFS and explore the matrix and find the path.</p> <pre><code>from collections import deque\ndef checkPath(A):\n    n,m = len(A), len(A[0])\n    source,dest = (-1,-1),(-1,-1)\n    for i in range(n):\n        for j in range(m):\n            if A[i][j] == 1:\n                source = (i,j)\n            elif A[i][j] == 2:\n                dest = (i,j)\n    if source == (-1,-1) or dest == (-1,-1):\n        return 0\n    q = deque()\n    visited = [[False]*(m) for _ in range(n)]\n    q.append(source)\n    visited[source[0]][source[1]] = 1\n    dirs = [[1,0],[-1,0], [0,1], [0,-1]]\n    while q:\n        cur = q.popleft()\n        if cur == dest: return 1\n        i,j = cur\n        for dx,dy in dir:\n            x,y = i+dx, j+dy\n            if 0&lt;= x &lt; n and 0 &lt;= y &lt; m:\n                if not visited[x][y] or A[x][y] != 0:\n                    visited[x][y] = 1\n                    q.append((x,y))\n    return 0\n</code></pre>"},{"location":"DSAyy/graph/#level-order-traversal-of-binary-tree","title":"Level Order Traversal of Binary Tree","text":"<p>Given binary tree, return its level order traversal as 2D array. Level order is visiting nodes level by level starting from root</p>"},{"location":"DSAyy/graph/#how_14","title":"How","text":"<p>BFS. <pre><code>from collections import deque\ndef levelOrder(root):\n    if not root: return []\n    q = deque()\n    q.append(root)\n    result = []\n    while q:\n        levelSize = len(q)\n        level = []\n        for i in range(levelSize):\n            node = q.popleft()\n            level.append(node)\n            if node.left: q.append(node.left)\n            if node.right: q.append(node.right)\n        result.append(level)\n    return result\n</code></pre></p>"},{"location":"DSAyy/graph/#smallest-multiple-with-0-and-1","title":"Smallest multiple with 0 and 1","text":"<p>Given a pos int A, find smallest mult of A such that it only consists of 0 or 1. Output the num as string.</p> <p>Example, A = 55, ans = 110. </p>"},{"location":"DSAyy/graph/#how_15","title":"How","text":"<p>Shortest path search, each node is a remainder mod A.</p> <p>Edge are like adding 0 or 1 to current number</p> <p>start from <code>1</code></p> <p>for \\(d \\in {0,1}\\) : \\(newRem = (r\\times 10 + d) mod \\space A\\) Track parent and digit to reconstruct once we reach remainder 0.</p> <pre><code>from collections import deque\n\ndef multiple(A):\n    if A == 0:\n        return \"0\"\n\n    q = deque()\n    parent = [-1] * A\n    digit = [''] * A\n    visited = [False] * A\n\n    rem = 1 % A\n    visited[rem] = True\n    digit[rem] = '1'\n    q.append(rem)\n\n    while q:\n        r = q.popleft()\n        if r == 0:\n            break\n\n        for d in ['0', '1']:\n            newRem = (r * 10 + int(d)) % A\n            if not visited[newRem]:\n                visited[newRem] = True\n                parent[newRem] = r\n                digit[newRem] = d\n                q.append(newRem)\n\n    # Reconstruct the answer from remainder 0\n    rem = 0\n    result = []\n    while rem != -1:\n        result.append(digit[rem])\n        rem = parent[rem]\n\n    return ''.join(reversed(result))\n</code></pre>"},{"location":"DSAyy/graph/#snake-ladder-problem","title":"Snake Ladder Problem","text":"<p>Given a \\(10 \\times 10\\) snake ladder board, numbered from 1  to 100 with list of <code>N</code> ladders, each ladder is a pair <code>(u,v)</code> indicating a move from <code>u</code> to <code>v</code> (u &lt; v)</p> <p>A list of M snakes <code>(u,v)</code> where it moves from <code>v</code> to <code>u</code></p> <p>Find the min dice rolls, to reach from square <code>1</code> to square <code>100</code></p> <p>Rule: if you land on a ladder or a snake, you have to take it. (note no overlaps in ladder and snakes)</p>"},{"location":"DSAyy/graph/#how_16","title":"How?","text":"<p>BFS, node (1,100) where</p> <p>each node has edge to atmost 6 next nodes (dice roll)</p> <p>each edge leads to a destination after taking ladder or snake</p> <p>BFS, track min dice rolls to reach each square. Try all values of dice roll at each edge.</p> <pre><code>def snakeLadder(A,B):\n    jumps = [i for i in range(1,101)]\n    for u,v in A:\n        jump[u] = v\n    for u,v in B:\n        jump[v] = u\n    visited = [False]*(101)\n    q = deque()\n    visited[1] = 1\n    q.push((1,0)) # square , roll count\n    while q:\n        sq,rolls = q.popleft()\n        if sq == 100:\n            return rolls\n        for d in range(1,7):\n            nxt = sq + d\n            if nxt &gt; 100: break\n            nxt = jump[nxt]\n            if not visited[nxt]:\n                visited[nxt] = 1\n                q.append((nxt,rolls + 1))\n    return -1\n</code></pre>"},{"location":"DSAyy/graph/#min-cost-path","title":"Min Cost Path","text":"<p>Given matrix <code>C</code> of \\(A \\times B\\) where each cell has <code>U</code>, <code>D</code>, <code>L</code>, <code>R</code> Start from <code>0,0</code> and reach <code>A-1,B-1</code></p> <p>Rules:</p> <p>Following the dir on the current cell, move costs <code>0</code></p> <p>if you move in diff direction, it costs <code>1</code></p> <p>return min total cost to reach the destination</p> <p>Example:</p> <p>C = RRR     DDD     UUU Output = 1</p>"},{"location":"DSAyy/graph/#how_17","title":"How?","text":"<p>New Topic: (0-1) BFS</p> <p>If you move in the given dir, it costs <code>0</code>. (enqueue it at front)</p> <p>if you move in other dir, it costs <code>1</code> (enqueue it at the back)</p> <p>Simple deque bfs that always prefers lower cost</p> <pre><code>def minCost(A,B,C):\n    if A == 1 and B == 1: return 0\n    INF = 10**9\n    dist = [[INF]*(B) for _ in range(A)]\n    dist[0][0] = 0\n    q = deque()\n    q.append((0,0))\n    dir = {'U': (-1,0),'D': (1,0), 'L': (0,-1),'R': (0,1)}\n    while q:\n        i,j = q.popleft()\n        curCost = dist[i][j]\n        for d in ['U','D','L','R']:\n            dx,dy = dir[d]\n            x,y = i + dx, j + dy\n            if not (0 &lt;= x &lt; A and 0 &lt;= y &lt; B): continue\n            cost = 0 if C[x][y] == d else 1\n            if curCost + cost &lt; dist[x][y]:\n                dist[x][y] = curCost + cost\n                if cost == 0: q.appendleft((x,y))\n                else: q.append((x,y))\n    return dist[A-1][B-1]\n</code></pre>"},{"location":"DSAyy/graph/#permutation-swaps","title":"Permutation Swaps","text":"<p>Given two perm A and B of int from 1 to N, and list of M good pairs C. good pair \\((i,j)\\) meaning you can swap those \\((A[i],A[j])\\) as many times.</p> <p>Find if its possible to transform A into B.</p> <p>Example:</p> <p>A = 1 3 2 4 B = 1 4 2 3 C = (2,4)</p> <p>Output = Yes</p>"},{"location":"DSAyy/graph/#how_18","title":"How","text":"<p>DSU babyyy</p> <p>Build DSU from good pairs.</p> <p>In each component (group of indices), collect A and B at those indices</p> <p>Sort both subarrs. If the sorted val match, they can be rearranged.</p> <p>If any component mismatch, return 0</p> <pre><code>from collections import defaultdict\nclass DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0]*n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    def unite(self,x,y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root == y_root:\n            return\n        if self.rank[x_root] &lt; self.rank[y_root]:\n            self.parent[x_root] = y_root\n        elif self.rank[y_root] &lt; self.rank[x_root]:\n            self.parent[y_root] = x_root\n        else:\n            self.parent[y_root] = x_root\n            self.rank[x_root] += 1\ndef can_transform(A,B,C):\n    if A== B:\n        return true\n    N = len(A)\n    dsu = DSU(N)\n    for u,v in C:\n        dsu.unite(u-1,v-1)\n    groups = defaultdict(list)\n    for i in range(N):\n        groups[dsu.find(i)].append(i)\n    for indices in groups.values():\n        a_vals = sorted([A[i] for i in indices])\n        b_vals = sorted([B[i] for i in indices])\n        if a_vals != b_vals:\n            return False\n    return True\n</code></pre>"},{"location":"DSAyy/graph/#commutable-islands-mst","title":"Commutable Islands (MST)","text":"<p>Given A islands and M bidirectional bridges.  Each bridge has a cost. Your goal is to find the min total cost to connect all islands such that all of them are in one component.</p> <p>A= num of islands, B = \\(M \\times 3\\) arr with weighted undirected edges</p> <p>Output: Minimum total cost</p> <p>A = 4 B = 1 2 1     2 3 4     1 4 3     4 3 2     1 3 10 Output = 6</p>"},{"location":"DSAyy/graph/#how_19","title":"How","text":"<p>Kruskals Algorithm for MST with DSU</p> <p>Sort all bridges by ascending cost.</p> <p>Use disjoint set union to maintain connected components</p> <p>Iteratively add A-1 lowest ccost bridges which connects two different components.</p> <pre><code>class DSU:\n    def __init__(self,n):\n        self.parent = list(range(n))\n        self.rank = [0]*n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    def unite(self,x,y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        if self.rank[xr] &lt; self.rank[yr]:\n            self.parent[xr] = yr\n        if self.rank[yr] &lt; self.rank[xr]:\n            self.parent[yr] = xr\n        else:\n            self.parent[yr] = xr\n            self.rank[xr] += 1\n        return True\ndef minCost(A,B):\n    B.sort(key = lambda x: x[2])\n    dsu = DSU(A)\n    total_cost = 0\n    edges_used = 0\n    for u,v in B:\n        if  dsu.unite(u-1,v-1):\n            total_cost += cost\n            edges_used += 1\n            if edges_used == A-1:\n                break\n    return total_cost\n</code></pre>"},{"location":"DSAyy/graph/#possibility-of-finishing-all-courses-cycles-in-directed-graph-toposort","title":"Possibility of Finishing all courses (Cycles in directed Graph, TopoSort)","text":"<p>Given A courses, 1 to A.  pair \\(B[i],C[i]\\) means to take course \\(C[i]\\) you have to take \\(B[i]\\) first Determine if its possible to finish all courses.</p> <p>Example: A = 3, B = 1 2          C = 2 3     Output = 1</p> <p>Take 1 then 2 then 3</p>"},{"location":"DSAyy/graph/#how_20","title":"How","text":"<p>Topological Sort using Kahn's Algorithm</p> <p>Let courses be nodes and \\(prereq(u,v)\\) be directed node from \\((u,v)\\)</p> <p>To check that the courses can be completed, we need to make sure it has no cycles.</p> <p>Construct adj, and indegrees</p> <p>Toposort using BFS</p> <p>If all nodes are visited at the end(no cycle), return 1, else 0</p> <pre><code>from collections import deque, defaultdict\ndef topoSort(A,B,C):\n    adj = defaultdict(list)\n    indeg = [0]*(A+1)\n    M = len(B)\n    for i in range(M):\n        adj[B[i]].append(C[i])\n        indegree[C[i]]+= 1\n    q = deque()\n    for i in range(1,A+1):\n        if indegree[i] == 0:\n            q.append(i)\n    processed = 0\n    while q:\n        u = q.popleft()\n        processed += 1\n        for v in adj[u]:\n            indegree[v]-= 1\n            if indegree[v] == 0:\n                q.append(v)\n    return processed == A\n</code></pre>"},{"location":"DSAyy/graph/#cycles-in-undirected-graph","title":"Cycles in undirected graph","text":"<p>A nodes from 1 to A. M edges represented in \\(M \\times 2\\) arr B, check whether graph has a cycle</p> <p>Return if a cycle exists</p>"},{"location":"DSAyy/graph/#how_21","title":"How?","text":"<p>DSU</p> <p>for each node (u,v), if they are already connected, adding this edge would create a cycle.</p> <pre><code>class DSU:\n    def __init__(self,n):\n        self.parent = list(range(n))\n        self.rank = [0]*n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    def unite(self,x,y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        if self.rank[xr] &lt; self.rank[yr]:\n            self.parent[xr] = yr\n        elif self.rank[yr] &lt; self.rank[xr]:\n            self.parent[yr] = xr\n        else:\n            self.parent[yr] = xr\n            self.rank[xr] += 1\n        return True\ndef cycleExists(A,B):\n    dsu = DSU(A)\n    for u,v in B:\n        if not unite(u,v):\n            return 1\n    return 0\n</code></pre>"},{"location":"DSAyy/graph/#mother-vertex","title":"Mother Vertex","text":"<p>A vertices 1 to A, M directed edges given in a \\(M \\times 2\\) matrix B. Determine whether there is a mother.  Mother is a vertex from which all the vertices are reachable.</p> <p>Output boolean</p>"},{"location":"DSAyy/graph/#how_22","title":"How","text":"<p>Candidate find: perform dfs, keep track of vertex with max finishing time. Then waha se verify by running a dfs and checking is all are visited.</p> <pre><code>from collections import defaultdict\n\ndef motherVertex(A,B):\n    adj = defaultdict(list)\n    for u,v in B:\n        adj[u].append(v)\n    visited = [False]*(A+1)\n    candidate = 1\n    def dfs(u):\n        visited[u] = True\n        for v in adj[u]:\n            if not visited[v]:\n                dfs(v)\n    for i in range(1,n+1):\n        if not visited[i]:\n            dfs(i)\n            candidate = i\n    visited = [False]*(A+1)\n    dfs(candidate)\n    for i in range(1,A+1):\n        if not visited[i]:\n            return 0\n    return 1\n</code></pre>"},{"location":"DSAyy/graph/#file-search","title":"File Search","text":"<p>Organise records into sets. Each record is a pair (<code>ID</code>, <code>parentID</code>). If a record <code>(X,Y)</code> exists, then both <code>X</code> and <code>Y</code> belong to the same set.  Find max number of sets into which the records can be partitioned, such that the condition holds.</p>"},{"location":"DSAyy/graph/#how_23","title":"How","text":"<p>Just DSU and return the number of disjoint sets.</p> <pre><code>class DSU:\n    def __init__(self,n):\n        self.parent = list(range(n))\n        self.rank = [0]*(n)\n    def find(self,x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    def unite(self,x,y):\n        rx,ry = self.find(x), self.find(y)\n        if rx == ry:\n            return False\n        if self.rank[rx] &lt; self.rank[ry]:\n            self.parent[rx] = ry\n        elif self.rank[ry] &lt; self.rank[rx]:\n            self.parent[ry] = rx\n        else:\n            self.parent[ry] = rx\n            self.rank[rx] += 1\ndef fileSearch(A,B):\n    dsu = DSU(A)\n    for u,v in B:\n        dsu.unite(u,v)\n    groups = set()\n    for i in range(A+1):\n        groups.insert(dsu.find(i))\n    return len(groups)\n</code></pre>"},{"location":"DSAyy/graph/#black-shapes","title":"Black Shapes","text":"<p>Given a grid A, having char <code>O</code> (white cells) and <code>X</code> black cells. Count the number of black shapes in the grid.  Black shape is just the connected component of black cells.</p>"},{"location":"DSAyy/graph/#how_24","title":"How","text":"<p>Just count components using BFS</p> <pre><code>from collections import deque\ndef blackShapes(A):\n    if not A: return 0\n    n, m = len(A), len(A[0])\n    dirs = [[1,0],[-1,0], [0,1], [0,-1]]\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if A[i][j] == 'X':\n                count += 1\n                q = deque()\n                q.append((i,j))\n                A[i][j] = 'O'\n                while q:\n                    x,y = q.popleft()\n                    for dx,dy in dirs:\n                        a,b = x + dx, y + dy\n                        if 0 &lt;= a &lt; n and 0 &lt;= b &lt; m:\n                            if A[a][b] == 'X':\n                                A[a][b] = 'O'\n                                q.append((a,b))\n    return count\n</code></pre>"},{"location":"DSAyy/graph/#convert-sorted-list-to-binary-tree","title":"Convert Sorted List to Binary Tree","text":"<p>Given a linked list, where elements are in ascending order, convert it into a height balanced BST.</p> <p>Height balanced maane depth of two subtrees of a node does not differ by more than 1</p>"},{"location":"DSAyy/graph/#how_25","title":"How","text":"<p>Simulate \\(in-order\\) traversal over the BST and advance the LL pointer in parallel</p> <p>Count the length of linked list: n</p> <p>Recursively build the BST using a helper function with start and end indices.</p> <p>The function constructs left subtree first, then creates root using the current list node, then constructs the right subtree.</p> <pre><code>class ListNode:\n    def __init__(self, val = 0, next = None):\n        self.val = val\n        self.next = next\nclass TreeNode:\n    def __init__(self,val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef sortedListToBST(head: ListNode) -&gt; TreeNode:\n    # get length of LL\n    def getLength(node):\n        count = 0\n        while node:\n            count += 1\n            node =node.next\n        return count\n    n = get_length(head)\n    current = head\n    # Recursively build BST\n    def build_BST(start,end):\n        nonlocal current\n        if start &gt; end: return None\n        mid = (start + end) // 2\n        left= build_BST(start,mid - 1)\n        root = TreeNode(current.val)\n        root.left = left\n        current = current.next\n        root.right = build_BST(mid + 1,end)\n        return root\n    return build_BST(0,n-1)\n</code></pre>"},{"location":"DSAyy/graph/#sum-of-fibonacci-numbers","title":"Sum of Fibonacci Numbers","text":"<p>Given a pos int <code>A</code>, return min num of fibonacci numbers such that their sum is <code>A</code>. Repetition of numbers is allowed.</p> <p>Example</p> <p>A = 4, Output = 2 (2 + 2) A = 7, Output = 2 (5 + 2)</p>"},{"location":"DSAyy/graph/#how_26","title":"How","text":"<p>Generate all fibonacci numbers \\(\\leq\\) A.</p> <p>Repeatedly subtract largest fibonacci number \\(\\leq\\) remaining value.</p> <p>Count steps until <code>A</code> = 0</p> <p>This works due to Zeckendorf's Theorem that every number can be represented as the sum of non consecutive fibonacci numbers. </p> <pre><code>import bisect\ndef fibSum(A):\n    fib = [1,1]\n    while True:\n        nxt = fib[:-1] + fib[:-2]\n        if nxt &gt; A: break\n        fib.append(nxt)\n    # greedy subtraction\n    count = 0\n    while A &gt; 0:\n        idx = bisect.bisect_right(fib,A) # bisect right = upper bound\n        A -= fib[idx]\n        count += 1\n    return count\n</code></pre>"},{"location":"DSAyy/graph/#knight-on-chess-board","title":"Knight on chess board","text":"<p>Given a chessboard of size \\(A \\times B\\), a knight starts at pos \\((C,D)\\) and wants to reach pos \\((E,F)\\). Find min num of moves to reach the destination. If not pos, return -1</p>"},{"location":"DSAyy/graph/#how_27","title":"How","text":"<p>Its simple bfs idk bro</p> <pre><code>from collections import deque\ndef knight(A,B,C,D,E,F):\n    if C == E and D == F: return 0\n    dirs = [[2,1],[2,-1],[-2,1], [-2,-1], [1,2],[1,-2],[-1,2], [-1,-2]]\n    visited = [[False]*(B+1) for _ in range(A+1)]\n    q = deque((C,D,0))\n    visited[C][D] = 1\n    while q:\n        x,y,dist = q.popleft()\n        for dx,dy in dirs:\n            i,j = x + dx, y+dy\n            if 1 &lt;= i &lt;= A and 1 &lt;= j  &lt;= B and not visited[i][j]:\n                if (i,j) == (E,F):\n                    return dist + 1\n                visited[i][j] = 1\n                q.append((i,j,dist+1))\n    return -1\n</code></pre>"},{"location":"DSAyy/graph/#useful-extra-edges","title":"Useful Extra Edges","text":"<p>A Nodes, undirected weighted edges \\(B[i] = [u,v,w]\\) .</p> <p>Given source C and dest D. List of extra edges \\(E[j] = [u,v,w]\\)  You are allowed to add atmost one extra edge from E.</p> <p>Return the shortest path length from C to D. If no such path, return -1.</p>"},{"location":"DSAyy/graph/#how_28","title":"How","text":"<p>Run dijkstra from source, and compute <code>distFromC[x]</code> </p> <p>Run dijkstra from destination, and compute distFromD[x]</p> <p>let \\(best = distFromC[D]\\)  For each extra edge (u,v,w) $$ minpath = min(distFromC[u] + w + distFromD[v], distFromC[v] + w + distFromD[u]) $$ Update the best dist if a shorter path is found.</p> <pre><code>import heapq\nfrom collections import defaultdict\ndef dijkstra(start, graph, A):\n    dist = [float('inf')*(A+1)]\n    dist[start] = 0\n    pq = [(0, start)]\n    while pq:\n        d,u = heapq.heappop(pq)\n        if d &gt; dist[u]:\n            continue\n        for v,w in graph[u]:\n            if dist[u] + w &lt; dist[v]:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq,(dist[v],v))\n    return dist\ndef shortest_path_with_extra_edge(A,B,C,D,E):\n    graph = defaultdict(list)\n    for u,v,w in B:\n        graph[u].append((v,w))\n        graph[v].append((u,w)) \n    distFromC = dijkstra(C,graph,A)\n    distFromD = dijkstra(D,graph,A)\n    best = distFromC[D]\n    for u,v,w in E:\n        if distFromC[u] + w + distFromD[v] &lt; best:\n            best = distFromC[u] + w + distFromD[v]\n        if distFromC[v] + w + distFromD[u] &lt; best:\n            best = distFromC[v] + w + distFromD[u]\n    return best if best != float('inf') else -1\n</code></pre>"},{"location":"DSAyy/graph/#word-ladder-i","title":"Word Ladder I","text":"<p>Given two words <code>A</code> and <code>B</code>. Find shortest transformation from A to B where one letter can be changed at a time. The transformed word must be in the dictionary C.</p> <p>Return num of words in the shortest path. Return 0 if no such path exists.</p>"},{"location":"DSAyy/graph/#how_29","title":"How","text":"<p>BFS. </p> <p>Add all dict words in a set for \\(O(1)\\) lookup</p> <p>BFS starting from A. Each level of BFS represents one transformation.</p> <p>For each word, try single letter mutations and push valid transformations into queue.</p> <p>Stop when you reach B.</p> <pre><code>from collections import deque\ndef wordLadder(A,B,C):\n    if A == B: return 1\n    word_set = set(C)\n    if B not in word_set:\n        return 0\n    queue = deque([(A,1)])\n    visited = set([A])\n    L = len(A)\n    while queue:\n        word, steps = queue.popleft()\n        for i in range(L):\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                if word[i] == c:\n                    continue\n                nxt_word = word[:i] + c + word[i+1:]\n                if nxt_word == B:\n                    return steps + 1\n                if nxt_word in word_set and nxt_word not in visited:\n                    visited.add(nxt_word)\n                    queue.append((nxt_word,steps + 1))\n    return 0\n</code></pre>"},{"location":"DSAyy/graph/#word-ladder-ii","title":"Word Ladder II","text":"<p>Given two words, \\(start\\) and \\(end\\) , and a dict of words C, return all shortest transformation sequences from start to end with the same rules as Word Ladder I</p> <p>Example</p> <p>start = hit, end = cog, dict = hot dot dog lot log</p> <p>Output : hit hot dot dog cog</p> <p>hit hot lot log cog</p>"},{"location":"DSAyy/graph/#how_30","title":"How","text":"<p>Advanced BFS tbh</p> <p>Track all words at each level, and remove them once fully processed.  Just keep storing the traversals at each level.</p> <pre><code>from collections import deque, collections\ndef word_ladder_ii(beginWord, endWord, wordList):\n    wordSet = set(wordList)\n    if endWord not in wordSet:\n        return []\n\n    level = {beginWord}\n    parents = defautdict(set)\n    found = False\n\n    while level and not found:\n        next_level = defaultdict(set)\n        for word in level:\n            wordSet.discard(word)\n        for word in level:\n            for i in range(len(word)):\n                for c in range 'abcdefghijklmnopqrstuvwxyz':\n                    newWord = word[:i] + c + word[i+1:]\n                    if newWord in wordSet:\n                        next_level[newWord].add(word)\n                        if newWord == endWord:\n                            found = True\n        level = next_level\n        for child, parSet in next_level.items():\n            parents[child].update(parSet)\n    # back track to get the solution\n    res = []\n    def backtrack(word, path):\n        if word == beginWord:\n            res.append([beginWord] + path[::-1])\n            return\n        for par in parents[word]:\n            backtrack(par, path + [word])\n    if found:\n        backtrack(endWord,[])\n    return res\n</code></pre>"},{"location":"DSAyy/graph/#clone-graph","title":"Clone Graph","text":"<p>Clone an undirected graph.</p> <p>Each node in the graph contains a label and a list of its neighbors.</p> <p>Given pointer to the node in the graph, return a deep copy.</p>"},{"location":"DSAyy/graph/#how_31","title":"How","text":"<p>BFS traversal while cloning each node and its neigbors.</p> <p>Use a hash map to maintain the mapping from orignal node to its clone</p> <p>For each node visited, clone it, and clone its neighbors and link them</p> <p>Return the cloned version of the original starting node.</p> <pre><code>from collections import deque\n\nclass Node:\n    def __init__(self, val, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\ndef cloneGraph(node):\n    if not node:\n        return None\n    # map the starting node\n    clones = {node : Node(node.val)}\n\n    queue = deque([node])\n\n    while queue:\n        current = queue.popleft()\n        for neighbor in current.neighbors:\n            if neighbor not in clones:\n                clones[neighbor] = Node(neighbor.val)\n                queue.append(neighbor)\n            clones[current].neighbors.append(clones[neighbor])\n    return clones[node]\n</code></pre>"},{"location":"DSAyy/stacks_queues/","title":"Stacks and Queues","text":""},{"location":"DSAyy/stacks_queues/#valid-parenthesis","title":"Valid Parenthesis","text":"<p>Given a string containing bracket sequences, determine if the string is valid. brackets can be <code>(</code> ,<code>{</code> <code>[</code></p> <pre><code>def validParent(S):\n    stack = []\n    bracket_map = {')' : '(', '}' : '{', ']' : '['}\n    for char in S:\n        if char in bracket_map.values(): #opening bracket\n            stack.append(char)\n        elif char in bracket_map: #closing bracket\n            if not stack or stack[-1] != bracket_map[char]:\n                return False\n            stack.pop()\n    return not stack\n</code></pre>"},{"location":"DSAyy/stacks_queues/#reverse-string-using-stack","title":"Reverse String Using Stack","text":"<p>Given a string S, reverse the string using a stack. <pre><code>def reverse(s):\n    stack  = []\n    for char in S:\n        stack.append(char)\n    for i in range(len(S)):\n        S[i] = stack.pop()\n    return S\n</code></pre></p>"},{"location":"DSAyy/stacks_queues/#balanced-parentheses","title":"Balanced Parentheses","text":"<p>Given a string, consisting only of <code>(</code> and <code>)</code>. Determine if this sequence is balanced. <pre><code>def balanced(S):\n    balance = 0\n    for char in S:\n        balance += 1 if char == '(' else -1\n        if balance &lt; 0: return 0\n    return 1\n</code></pre></p>"},{"location":"DSAyy/stacks_queues/#simplify-directory-path","title":"Simplify Directory Path","text":"<p>Given a string representing absolute path for a file, return the simplified absolute path. Ex: 1. \"/home/\" -&gt; \"/home\" 2. \"/a/./b/../../c/\" -&gt; \"/c\"</p>"},{"location":"DSAyy/stacks_queues/#how","title":"How","text":"<ol> <li>Split the input path on '/' to get tokens.</li> <li>For .., pop the last directory fron the stack.</li> <li>Otherwise push directory name into the stack. <pre><code>def simplify_path(path):\n    stack = []\n    tokens = path.split('/')\n    for token in tokens:\n        if token == '' or token == '.':\n            continue\n        elif token == '..':\n            if stack:\n                stack.pop()\n        else:\n            stack.append(token)\n    return '/' + '/'.join(stack)\n</code></pre></li> </ol>"},{"location":"DSAyy/stacks_queues/#redundant-braces-in-expressions","title":"Redundant Braces in Expressions","text":"<p>Given a string denoting arithmetic expression (+ - * /), check whether it has redundant braces.</p> <p>Ex: 1. ((a+b)) : yes 2. (a + (a+b)) : no</p>"},{"location":"DSAyy/stacks_queues/#how_1","title":"How","text":"<ol> <li>Push everything onto the stack except when you see a closing parenthesis.</li> <li>On seeing ), pop untill you find a (.</li> <li>If no operator is found inside, they are redundant.</li> </ol> <pre><code>def has_redundant_braces(expression):\n    stack = []\n    for char in expression:\n        if char == ')':\n            has_operator = False\n            while stack and stack[-1] != '(':\n                top = stack.pop()\n                if top in ['+','-','*','/']:\n                    has_operator = True\n            if stack:\n                stack.pop() #pop the (\n            if not has_operator:\n                return True\n        else:\n            stack.append(char)\n    return False\n</code></pre>"},{"location":"DSAyy/stacks_queues/#min-stack-stack-with-constant-time-minimum","title":"Min Stack: Stack with constant time minimum","text":"<p>Design a stack with push pop top, and getMin(): retrieves the min element.</p> <p>getMin and top should return -1 on an empty stack. pop should do nothing on an empty stack.</p>"},{"location":"DSAyy/stacks_queues/#how_2","title":"How","text":"<p>Use two stacks, one for elements, other for min. Also push to minSt if its a new minimum, when you pop, also pop from minSt if it was the current minimum.</p> <pre><code>class MinStack:\n    def __init__(self):\n        self.st = []\n        self.minSt = []\n    def push(self,x):\n        self.st.append(x)\n        if not self.minSt or x &lt;= self.minSt[-1]:\n            self.minSt.append(x)\n    def pop(self):\n        if not self.st:\n            return\n        val = self.st.pop()\n        if self.minSt and val == self.minSt[-1]:\n            self.minSt.pop()\n    def top(self):\n        if not self.st:\n            return -1\n        return self.st[-1]\n    def getMin(self):\n        if not self.minSt:\n            return -1\n        return self.minSt[-1]\n</code></pre>"},{"location":"DSAyy/stacks_queues/#maxpprod-maximum-special-product","title":"MAXPPROD: Maximum Special Product","text":"<p>Given an array of integers, define for each index i: 1. LeftSpecialValue(LSV): the max index <code>j</code> such that \\(A[j] &gt; A[i]\\) . If none, LSV = 0 2. RightSpecialValue(RSV): the min index <code>i</code> such that \\(A[j] &gt; A[i]\\) if none, RSV = 0 3. Special Product for i is \\(LSV \\times RSV\\) </p>"},{"location":"DSAyy/stacks_queues/#how_3","title":"How","text":"<p>basically nearest greatest element to the left, and nearest greatest element to the right.</p> <pre><code>def max_special_product(A):\n    n = len(A)\n    left = [0]*n\n    right = [0]*n\n    stack = []\n    #compute left special\n    for i in range(n):\n        while stack and A[stack[-1]] &lt;= A[i]:\n            stack.pop()\n        left[i] = stack[-1] if stack else 0\n        stack.append(i)\n    stack.clear()\n    #compute right special\n    for i in range(n-1,-1,-1):\n        while stack and A[stack[-1]] &lt;= A[i]:\n            stack.pop()\n        right[i] = stack[-1] if stack else 0\n        stack.append(i)\n    #compute maxProd\n    maxProd = 0\n    for i in range(n):\n        prod = left[i]*right[i]\n        maxProd = max(maxProd, prod)\n    return maxProd % (10 **9 + 7)\n</code></pre>"},{"location":"DSAyy/stacks_queues/#nearest-smaller-element","title":"Nearest Smaller Element.","text":"<p>Monotonic Stack basic. Find nearest smaller element to the left. Return \\(G[i]\\) aka all the values of nearest smaller. If no element, \\(G[i] = -1\\) .</p> <pre><code>def prevSmaller(A):\n    n = len(A)\n    G = [0]*(n)\n    stack = []\n    for i in range(n):\n        while stack and A[stack[-1]] &gt;= A[i]:\n            stack.pop()\n        G[i] = stack[-1] if stack else -1\n        stack.append(A[i])\n    return G\n</code></pre>"},{"location":"DSAyy/stacks_queues/#largest-rectange-in-histogram","title":"Largest Rectange in Histogram.","text":"<p>Given an array containing height of histogram bars (Each width 1). Find the area of largest histogram.</p> <p>Ex: A = 2 1 5 6 2 3, Output = 10</p>"},{"location":"DSAyy/stacks_queues/#how_4","title":"How","text":"<ol> <li>Use a monotonic increasing stack to keep the value of left greatest.</li> <li>For each bar, while stack top is greater than current bar, pop and commute height times width. width is determined by the index. <pre><code>def largestRectArea(A):\n    n = len(A)\n    stack = []\n    maxArea = 0\n    for i in range(n+1):\n        h = 0 if i == n else A[i]\n        while stack and h &lt; A[stack[-1]]:\n            height = A[stack.pop()]\n            j = stack[-1] if stack else -1\n            width = i - j - 1\n            area = height * width\n            maxArea = max(maxArea, area)\n        stack.append(i)\n    return maxArea\n</code></pre></li> </ol>"},{"location":"DSAyy/stacks_queues/#hotel-service-nearest-hotel-in-a-grid","title":"Hotel Service (Nearest Hotel in a grid)","text":"<p>Given a matrix of \\(N \\times M\\) of 0s and 1s. \\(1 == hotel\\) and <code>Q</code> queries <code>B</code> (coordinates). Find the shortest distance from each query cell to nearest hotel. (measured in 4D).</p> <p>A = </p> <pre><code>0 0\n1 0\n</code></pre> <p>B = </p> <pre><code>1 1\n2 1\n1 2\n</code></pre> <p>Output: 1 0 2</p>"},{"location":"DSAyy/stacks_queues/#how_5","title":"How","text":"<p>Use multisource BFS 1. Stack BFS from every hotel cell (\\(A[i][j] = 1\\)) simultaneously. 2. Fill out a dist grid so that minimal steps to each coordinate is recorded. 3. After BFS, answer each query in \\(O(1)\\)</p> <pre><code>from collections import deque\ndef nearest_hotel_bfs(A,queries):\n    N = len(A)\n    M = len(A[0]) if N &gt; 0 else 0\n    dist = [[-1]*M for _ in range(N)]\n    Q = deque()\n    #enqueue all hotels\n    for i in range(N):\n        for j in range(M):\n            if A[i][j] == 1:\n                dist[i][j] = 0\n                Q.append((i,j))\n    directions = [(-1,0), (1,0), (0,-1), (0,1)]\n    while Q:\n        x,y = Q.popleft()\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 &lt;= nx &lt; N and 0 &lt;= ny &lt; M and dist[nx][ny] == -1:\n                dist[nx][ny] = dist[nx][ny] + 1\n                Q.append((nx,ny))\n    results = []\n    for X,Y in queries:\n        results.append(dist[X-1][Y-1])\n    return results\n</code></pre>"},{"location":"DSAyy/stacks_queues/#first-non-repeating-character-in-stream","title":"First Non-repeating character in stream","text":"<p>Given string representing a stream of lowercase letters, construct B such that \\(B[i]\\) is the first non repeating chracter in the prefix \\(A[0...i]\\) of the stream. If none, append #.</p> <p>A = abadbc, output = aabbdd</p>"},{"location":"DSAyy/stacks_queues/#how_6","title":"How","text":"<p>for each char 1. increase its frequency 2. push c into a queue if its a candidate for non repetition. 3. while the char at front of queue is a repeater(\\(\\text{frequency &gt; 1}\\)), pop it. 4. If the queue is empty, append <code>#</code> </p> <pre><code>from collections import deque\ndef first_non_repeating_char_stream(A):\n    freq = [0]*26 \n    Q = deque()\n    B = []\n    for c in A:\n        idx = ord(c) - ord('a')\n        freq[idx] +=  1\n        Q.append(c)\n        while Q and freq[ord(Q[0]) - ord('a')] &gt; 1:\n            Q.popleft()\n        if not Q:\n            B.append('#')\n        else:\n            B.append(Q[0])\n    return ''.join(B)\n</code></pre>"},{"location":"DSAyy/stacks_queues/#sliding-window-maximum","title":"Sliding Window Maximum","text":"<p>Given an array and a window size, for each window of that size moving from left to right, find the maximum in that window.</p> <p>A: 1 3 -1 -3 5 3 6 7</p> <p>B: 3</p> <p>Output: 3 3 5 5 6 7</p>"},{"location":"DSAyy/stacks_queues/#how_7","title":"How","text":"<p>Use a double-ended queue, to maintain a list of candidates for the maximum (monotonically decreasing) 1. When the window moves, remove the indices that are out of range from the front. 2. Remove indices from the back that are less than the current element (not maximum). 3. The front of the deque always gives maximum for the current window.</p> <pre><code>from collections import deque\ndef sliding_window_maximum(A,B):\n    n = len(A)\n    if B &gt; n: return [max(A)]\n    dq = deque()\n    C = []\n    for i in range(n):\n        if dq and dq[0] == i - B: #out of window index\n            dq.popleft()\n        #remove indices whose val &lt; A[i]\n        while dq and A[dq[-1]] &lt; A[i]:\n            dq.pop()\n        dq.append(i)\n        #record max for current window\n        if i &gt;= B-1:\n            C.append(A[dq[0]])\n    return C\n</code></pre>"},{"location":"DSAyy/stacks_queues/#evaluate-expression-reverse-polish-notation","title":"Evaluate Expression (Reverse Polish Notation)","text":"<p>Given a string <code>A</code> representing arithmetic expression in Reverse Polish Notation, evaluate and return its value.</p> <p>A = 2 1 + 3 * , Output = 9</p>"},{"location":"DSAyy/stacks_queues/#how_8","title":"How","text":"<p>traverse the tokens 1. If a number, push to stack. 2. If an operator, pop two numbers, compute the result, and push it back.</p> <pre><code>def RPN(tokens):\n    stack = []\n    for token in tokens:\n        if token in [\"+\", \"-\", \"*\", \"/\"]:\n            b = stack.pop()\n            a = stack.pop()\n            if token == \"+\":\n                res = a+b\n            elif token == \"-\":\n                res = a-b\n            elif token  == \"*\":\n                res = a*b\n            else:\n                res = int(a/b)\n            stack.append(res)\n        else:\n            stack.append(int(token))\n    return stack[-1]\n</code></pre>"},{"location":"DSAyy/stacks_queues/#trapping-rain-water-total-this-time","title":"Trapping Rain Water (total this time)","text":"<p>Given <code>A[i]</code> representing the height of the wall. width of each wall is <code>1</code>. Compute total units of water that can be trapped after it rains.</p> <p>A = 0 1 0 2 1 0 1 3 2 1 2 1, Output = 6</p>"},{"location":"DSAyy/stacks_queues/#how_9","title":"How","text":"<p>Water is trapped if there are taller bars on both sides. $$ \\text{water at i = } min(maxLeft_i, maxRight_i) - A[i] $$ Instead of precomputing maxLeft and maxRight, we can traverse both ends and track the highest bar from left to right on the go.</p> <ol> <li>Two pointers (left and right) at both ends, and two variables (left_max and right_max).</li> <li>Move the smaller inwards (if left is smaller):<ol> <li>If \\(A[left] \\geq \\text{left\\_max}\\), update left_max.</li> <li>Else, add left_max - A[left] to water. Increment left.</li> </ol> </li> <li>Else do the same for right.</li> <li>Continue until pointers meet. <pre><code>def trap_rain_water(A):\n    n = len(A)\n    left, right = 0, n-1\n    left_max, right_max = 0, 0\n    water = 0\n    while left &lt;= right:\n        if A[left] &lt; A[right]:\n            if A[left] &gt;= left_max:\n                left_max = A[left]\n            else:\n                water += left_max - A[left]\n            left += 1\n        else:  \n            if A[right] &gt;= right_max:\n                right_max = A[right]\n            else:\n                water += right_max - A[right]\n            right -= 1\n    return water\n</code></pre></li> </ol>"},{"location":"DSAyy/trees/","title":"Trees","text":""},{"location":"DSAyy/trees/#next-greater-number-in-bst","title":"Next Greater Number in BST","text":"<p>Given a BST Node, return the node which has val greater than given node.</p>"},{"location":"DSAyy/trees/#how","title":"How","text":"<p>This is basically finding inorder sucessor.</p> <p>For finding node with val just &gt; B,</p> <ol> <li>While searching for node with val B, whenever we move to left child, curr node is candidate for successor. We record that candidate and move ahead.</li> <li>Once we find the node with val B:<ol> <li>If N has a right subtree, then the sucessor is the leftmost node in the right subtree.</li> <li>Else sucessor is the latest recorded ancestor (candidate)</li> </ol> </li> </ol> <pre><code>class TreeNode:\n    def __init__(self,val):\n        self.val = val\n        self.left = None\n        self.right = None\ndef inorder_sucessor(root,target):\n    successor = None\n    #search for node while tracking sucessors\n    while root:\n        if target.val &lt; root.val:\n            successor = root\n            root = root.left\n        elif target.val &gt; root.val:\n            root = root.right\n        else:\n            break # found root\n    if target.right:\n        successor = target.right\n        while successor.left:\n            successor = successor.left\n    return successor\n</code></pre>"},{"location":"DSAyy/trees/#valid-bst-from-preorder","title":"Valid BST from PreOrder","text":"<p>Given and int arr A representing a preorder traversal of a BST.</p> <p>Determine if A can correspond to the preorder traversal of some valid BST.</p> <p>$$ (\\text{left subtree keys}) &lt; (\\text{node key}) &lt; (\\text{right subtree keys}) $$ Return if its a valid preorder of BST. </p>"},{"location":"DSAyy/trees/#how_1","title":"How","text":"<p>A valid preorder of BST would have {root, left subtree, right subtree} order.</p> <p>Each new preorder value should: 1. Be strictly greater than some lower bound 2. Fit into a position consistent with BST constraints implied previously</p> <p>We can simulate building the BST without constructing it by 1. A stack to track the chain of ancestors for which we have not yet assigned a right child. 2. A lower_bound variable that tracks the smallest permissible value for the current node (once we pop from the stack, that popped value becomes the new lower bound) <pre><code>def is_valid_bst_preorder(preorder):\n    stack = []\n    lower_bound = float('-inf')\n    for value in preorder:\n        #val must be greater than the lowest allowed val (left subtree needs a right)\n        if value &lt; lower_bound:\n            return False\n        #nodes popped mean we are in the right subtree now\n        while stack and value &gt; stack[-1]:\n            lower_bound = stack.pop() #pop all right subtree val\n        stack.append(value)\n    return True\n</code></pre></p>"},{"location":"DSAyy/trees/#kth-smallest-element-in-tree","title":"Kth Smallest Element in Tree","text":"<p>Given a BST, write a func to find the Kth smallest element in the tree.</p>"},{"location":"DSAyy/trees/#how_2","title":"How","text":"<p>The Kth smallest element is just the Kth element in the inorder traversal 1. Traverse BST iteratively using a stack to simulate recursion. 2. Always push left children onto the stack until we reach a null 3. Pop one node at a time, each pop node corresponds to the next smallest element in the sorted order. 4. Maintain a counter, when counter reaches k, return the popped value</p> <pre><code>class TreeNode:\n    def __init__(self,val):\n        self.val = val\n        self.left = None\n        self.right = None\ndef kth_smallest(root,k):\n    stack = []\n    current = root\n    while True:\n        #go as left as possible\n        while current:\n            stack.append(current)\n            current = current.left\n        #pop from stack\n        current = stack.pop()\n        k -= 1\n        if k == 0: return current.val\n        current = current.right\n</code></pre>"},{"location":"DSAyy/trees/#2-sum-binary-tree","title":"2-Sum Binary Tree","text":"<p>Given a BST, and an int B. Determine whether there are 2 distinct nodes X and Y in the tree such that $$ X.val + Y.val = B $$</p>"},{"location":"DSAyy/trees/#how_3","title":"How","text":"<p>Normally we use 2 pointer in a sorted array, we need to simulate this in BST. 1. An inorder iterator (left to right) that yields val in asc order. 2. A reverse-inorder iterator (right to left) that yields val in des order.</p> <p>Both iterators can be implemented with a stack 1. Init \\(next-smallest\\) stack by pushing all left descendents from root down to leftmost node. 2. Init \\(next-largest\\) stack by pushing all right descendents from root down to rightmost node. 3. getNext(): Pop from \\(s_1\\) call that node's val \\(v\\) . Then if that node has a right child, push its right child and all of that child's left descendents onto \\(s_1\\) . Return v. 4. getPrev(): Pop from \\(s_2\\) , Call that node's val \\(u\\). Then if that node has a left child, push its left child and all of its right descendents into \\(s_2\\) Return u. </p> <p>Then have a two-pointer loop. leftVal would be getNext(), rightVal would be getPrev(). Then normal 2 pointer approach.</p> <pre><code>class TreeNode:\n    def __init__(self,val):\n        self.val = val\n        self.left = None\n        self.right = None\nclass BSTIterator:\n    def __init__(self,root,forward):\n        self.stack = []\n        self.forward = forward #true is next val, false for prev\n        self.__push_all(root)\n    def __push_all(self,node):\n        while node:\n            self.stack.append(node)\n            node = node.left if self.forward else node.right\n    def next(self):\n        node = self.stack.pop()\n        val = node.val\n        if self.forward:\n            self.__push_all(node.right)\n        else:\n            self.__push_all(node.left)\n        return val\n    def has_next(self):\n        return len(stack) &gt; 0\ndef find_target(root,k):\n    if not root: return False\n    left_iter = BSTIterator(root,True)\n    right_iter = BSTIterator(root,False)\n    left_val = left_iter.next()\n    right_val = right_iter.next()\n    while left_val &lt; right_val:\n        cur_sum = left_val + right_val\n        if cur_sum == k:\n            return True\n        elif cur_sum &lt; k:\n            if left_iter.has_next():\n                left_val = left_iter.next()\n            else: \n                break\n        else:\n            if right_iter.has_next():\n                right_val = right_iter.next()\n            else:\n                break\n    return False\n</code></pre>"},{"location":"DSAyy/trees/#bst-iterator","title":"BST Iterator","text":"<p>Implement an iterator over a BST. Iterator is init with root of BST. 1. next() return the next smallest number in the BST 2. hasNext() return true if there is a next smallest number, otherwise false</p>"},{"location":"DSAyy/trees/#how_4","title":"How","text":"<p>Abhi just toh kiya upar</p> <pre><code>class TreeNode:\n    def __init__(self,val):\n        self.val = val\n        self.left = None\n        self.right = None\nclass BSTIterator:\n    def __init__(self,root):\n        self.stack = []\n        self._push_left(root)\n    def _push_left(self,node):\n        while node:\n            self.stack.append(node)\n            node = node.left\n    def next(self):\n        node = self.stack.pop()\n        val = node.val\n        if node.right:\n            self._push_left(node.right)\n        return val\n    def hasNext(self):\n        return len(stack) &gt; 0       \n</code></pre>"},{"location":"DSAyy/trees/#recover-binary-search-tree","title":"Recover Binary Search Tree","text":"<p>Two nodes of a BST are swapped by mistake. Identify which, and swap them back. Return a two-element list \\([v_1, v_2]\\) in asc order, wherte swapping \\(v_1\\) and \\(v_2\\) corrects the tree.</p>"},{"location":"DSAyy/trees/#how_5","title":"How","text":"<p>A correct BST inorder traversal produces a strictly increasing seq of node values. If  2 nodes are swapped, their inorder will have exactly one or two inversions.</p> <ol> <li>Case 1 (Non-adjacent swap): 2 inversions occur. First pair identifies the first wrong node, and second identifies the second wrong node.</li> <li>Case 2 (adjacent swap): Exactly one inversion occurs; just swap the 2 nodes in the inversion.</li> </ol> <p>Perform a Morris inorder traversal, with \\(O(1)\\) space. Keep track of prev pointer. Whenever \\(prev.val &gt; curr.val\\), we found an inversion.</p> <p>If first inversion, first = prev, second = curr, if second, second = curr</p> <pre><code>class TreeNode:\n    def __init__(self,val):\n        self.val = val\n        self.left = None\n        self.right = None\ndef recover_bst(root):\n    first = second = prev = None\n    current = root\n    while current:\n        if not current.left:\n            # check for inversion\n            if prev and prev.val &gt; current.val:\n                if not first:\n                    first = prev\n                second = current.right\n        else:\n            # morris traversal setup\n            pred = current.left\n            while pred.right and pred.right != current:\n                pred = pred.right\n            if not pred.right:\n                pred.right = current\n                current = current.left\n            else:\n                pred.right = None\n                if prev and prev.val &gt; current.val:\n                    if not first:\n                        first = prev\n                    second = current\n                prev = current\n                current = current.right\n    return sorted([first.val,second.val])\n</code></pre>"},{"location":"DSAyy/trees/#xor-between-two-arrays","title":"Xor Between Two Arrays","text":"<p>Given two Int arrays A and B. Pick one element \\(a \\in\\) A and one element \\(b\\in\\) B so to maximie the val of \\(a \\oplus b\\)  Where \\(\\oplus\\) is bitwise XOR. </p> <p>Return this max XOR value.</p> <p>Example: A = 1 2 3, B = 4 1 2. Max is \\(3 \\oplus 4\\) which is 7</p>"},{"location":"DSAyy/trees/#how_6","title":"How","text":"<p>We can insert all elements of A into a Binary Trie, instead of manually checking all the values.</p> <p>Insert all element \\(a \\in A\\)  into binary trie (a bitwise trie), and then, for each b \\(\\in\\) B, walk the trie greedily to pick bits that maximise \\(b \\oplus a\\) .</p> <p>Represent each int in 31 bits, and build a binary trie of depth 31, where each node has two children, \\(\\(child[0] \\space \\text{  bit = 0}, \\text{ child[1]      bit = 1}\\)\\) Inserting an int x simply means descending from root, examining bits and creating child pointers as needed.</p> <p>To query \\(b \\in B\\) , we walk the root, and at bit index \\(i\\) , we know b's ith bit is \\(b_i\\) . To maximise \\(b \\oplus a\\) at that bit, we would like to pick \\(a_i = 1 - b_i\\) if such a branch exists. Otherwise we must follow \\(a_i = b_i\\) </p> <p>Accumulating these chosen bits builds the best possible partner \\(a\\) from trie, and we compute (\\(b \\oplus a\\)).</p> <pre><code>class TrieNode:\n    def __init__(self):\n        self.child = [None,None] #child[0] for bit 0, child[1] for bit 1\ndef max_xor_between_arrays(A,B):\n    #build trie from elements of A\n    root = TrieNode()\n    for x in A:\n        node = root\n        for i in range(30,-1,-1):\n            bit = (x &gt;&gt; i) &amp; 1\n            if not node.child[bit]:\n                node.child[bit] = TrieNode()\n            node = node.child[bit]\n    #step 2\n    max_xor = 0\n    for b in B:\n        node = root\n        curr_xor = 0\n        for i in range(30,-1,-1):\n            bit = (b &gt;&gt; i) &amp; 1\n            desired = bit ^ 1 # opp bit for maximising xor\n            if node.child[desired]:\n                curr_xor |= (1 &lt;&lt; i)\n                node = node.child[desired]\n            else:\n                node = node.child[desired]\n        max_xor = max(max_xor, curr_xor)\n    return max_xor\n</code></pre>"},{"location":"DSAyy/trees/#hotel-reviews","title":"Hotel Reviews","text":"<p>Given a string <code>A</code> of good words, separated by <code>_</code> and a vector B of review strings, where sequence of words are also separated by underscore.</p> <p>Define the goodness value of a review, as the num of words in the review which match one of the good words. Return a vec of original indices of reviews in B, sorted in descending value of Goodness. If two reviews have same goodness, their relative order must be stable. (preserving original order)</p> <p>Example: A = cool_ice_wifi, B = {water_is_cool, cold_ice_drink, cool_wifi_speed} Ans: 2 0 1</p>"},{"location":"DSAyy/trees/#how_7","title":"How","text":"<p>Because num of good words and length of review can be large, we cannot compare every word, so we have to build a trie (prefix tree).</p> <p>Build a trie of all good words: 1. Split string A on '' to extract good word. (length \\(\\leq\\)  4 in this problem). 2. Insert each good word into a 26-ary trie (one child for each letter 'a'-'z'). And mark the end of a good word with a boolean flag. 3. For each review in B split on '', traverse trie to check if its marked good or not. 4. Count how many tokens appear in the review and that is the goodness val. 5. Finally perform the stable sort by comparing goodness in descending order.</p> <pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = True\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    def insert(self,word):\n         cur = self.root\n         for char in word:\n             if char not in cur.children:\n                 cur.children[char] = TrieNode()\n                cur = cur.children[char]\n        cur.is_end = True\n    def search(self,word);\n        cur = self.root\n        for char in word:\n            if char not in cur.children:\n                return False\n            cur = cur.children[char]\n        return cur.is_end\ndef hotel_reviews(A,B):\n    trie = Trie()\n    good_words = A.split('_')\n    for word in good_words:\n        trie.insert(word)\n    review_scores = []\n    for index, review in enumerate(B):\n        words = review.split('_')\n        score = sum(1 for word in words if trie.search(word))\n        review_scores.append((score,index))\n    # sort by desc goodness\n    review_scores.sort(key = lambda x: (-x[0],x[1]))\n    #ret indices\n    return [idx for _,idx in review_scores]\n</code></pre>"},{"location":"DSAyy/trees/#shortest-unique-prefix","title":"Shortest Unique Prefix","text":"<p>Given a list of words (all lowercase with no word being a prefix of the other), find the shortest unique prefix for each word that distinguishes it from all other words in the list.</p> <p>Example: zebra,dog,duck, dove. -&gt; output z,dog,dy,dov</p> <p>Simply prefix that no one else has.</p>"},{"location":"DSAyy/trees/#how_8","title":"How","text":"<p>We build a prefix tree, of all inputs and store at each node, the number of words that pass through the node (<code>count</code>) . Then: 1. Insert each word into the trie, incrementing <code>count</code> at every node along its path. 2. To find the shortest unique prefix of a word, traverse its path from root, char by char, appending to the prefix string. As soon as we reach a node where the count is 1, the prefix is going to be unique. 3. Because no word is a prefix of other, ans is guaranteed.</p> <pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.count = 0 #num of words passing through\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    def insert(self, word):\n        cur = self.root\n        for char in word:\n            if char not in cur.childrem:\n                cur.children[char] = TrieNode()\n            cur = cur.children[char]\n            cur.count += 1\n    def find_prefix(self,word):\n        cur = self.root\n        prefix = \"\"\n        for char in word:\n            prefix += char\n            cur = cur.children[char]\n            if cur.count == 1:\n                return prefix\n        return prefix #fallback, full word\ndef shortest_unique_prefix(words):\n    trie = Trie()\n    for word in words: trie.insert(word)\n    return [trie.find_prefix(word) for word in words]\n</code></pre>"},{"location":"DSAyy/trees/#path-to-given-node","title":"Path to Given Node","text":"<p>Given a binary tree <code>A</code> with N nodes. Each node has unique int value. And a target <code>B</code>. Find the path from <code>root</code> to the node whose value is <code>B</code>.</p> <p>Given a root pointer, return a 1D array with the path from root to B.</p>"},{"location":"DSAyy/trees/#how_9","title":"How","text":"<p>A common approach for this is DFS and keeping track of node's parent. Once we discover node <code>B</code>, we can reconstruct the path by walking backwards to the root using <code>parent</code> pointers. The just reverse the sequence.</p> <ol> <li>Init an empty map parent, with \\(nodeValue -&gt; parentValue\\)</li> <li>Use an explicit stack to DFS the tree. When we visit a child, record \\(parent[child.val] = current.val\\) </li> <li>As soon as we pop a node who value equals B, stops the DFS, and start reconstructing using the parent chain.</li> </ol> <pre><code>class TreeNode:\n    def __init__(self,val = 0, left= None, right= None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef path_to_node(root,B):\n    if not root: return []\n    parent = {root.val : None}\n    stack = [root]\n    target_node = None\n\n    while stack:\n        node = stack.pop()\n        if node.val == B:\n            target_node= node\n            break\n        if node.left:\n            parent[node.left.val] = node.val\n            stack.append(node.left)\n        if node.right:\n            parent[node.right.val] = node.val\n            stack.append(node.right)\n    if target_node is None:\n        return []\n    path = []\n    while B is not None:\n        path.append(B)\n        B = parent[B]\n    return path[::-1]\n</code></pre>"},{"location":"DSAyy/trees/#remove-half-nodes","title":"Remove Half Nodes","text":"<p>Given a binary tree A with N nodes, remove all half nodes - nodes that have exactly one child- and return the root of the resulting tree. </p> <p>A leaf should not be removed.</p>"},{"location":"DSAyy/trees/#how_10","title":"How","text":"<p>If a node has 2 children, keep it, else if it has one child, bypass it by linking it directly with its non-null child.</p> <p>A bottom-up traversal (post order?) 1. Recursively process left and right subtrees, so all the half nodes below are already removed. 2. After recursion, examine node \\(u\\) :     1. if u is a leaf, keep it     2. if it has 2 children, keep it     3. if it has one child, return <code>u.left</code> or <code>u.right</code> whichever is non-null 3. Recursive call returns the root of the new pruned tree.</p> <pre><code>class TreeNode:\n    def __init__(self, val = 0, left= None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef remove_half_nodes(root):\n    if not root: return None\n    root.left = remove_half_nodes(root.left)\n    root.right = remove_half_nodes(root.right)\n    if root.left and not root.right:\n        return root.left\n    if root.right and not root.left:\n        return root.right\n    return root\n</code></pre>"},{"location":"DSAyy/trees/#nodes-at-distance-k","title":"Nodes at distance K","text":"<p>Given the root of a binary tree <code>A</code>, and a target node value <code>B</code>, and an integer <code>C</code> Return the array of all nodes that are exactly at distance <code>C</code> from the node with value <code>B</code>.  You can return ans in any order.</p>"},{"location":"DSAyy/trees/#how_11","title":"How","text":"<p>We treat binary tree as an undirected graph. Then we perform a BFS starting from target node, expanding outwards in all three directions (left, right, parent). After <code>C</code> BFS levels, all nodes in the queue are at distance C.</p> <pre><code>from collections import defaultdict, deque\nclass TreeNode:\n    def __init__(self,val = 0, left = None, right = None):\n        self.val = val\n        self.left=  left\n        self.right = right\ndef distance_k(root, target_val, k):\n    graph = defaultdict(list)\n    def build_graph(node, parent = None):\n        if node:\n            if parent:\n                graph[node.val].append(parent.val)\n                graph[parent.val].append(node.val)\n            build_graph(node.left,node)\n            build_graph(node.right, node)\n    build_graph(root)\n    visited = set()\n    queue = deque([target_val])\n    visited.add(target_val)\n    distance = 0\n    while queue and distance &lt; k:\n        for _ in range(len(queue)):\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n        distance += 1\n    return list(queue)\n</code></pre>"},{"location":"DSAyy/trees/#last-node-in-a-complete-binary-tree","title":"Last Node in a complete binary tree.","text":"<p>Given the root of a complete binary tree A. Return the value of the rightmost node, in the last level of the tree. Aim for better than \\(O(N)\\) time.</p>"},{"location":"DSAyy/trees/#how_12","title":"How","text":"<p>In a complete binary tree of height <code>h</code>, the last level has indices 0 to \\(2^k - 1\\). </p> <p>Define \\(exists(idx)\\) that checks if a node at index <code>idx</code> exists. To do this, we start at root, and examine the bits of <code>idx</code> from (<code>h-1</code>) floor down to 0. A bit of <code>0</code> means go left, <code>1</code> means go right . If you never reach <code>NULL</code>, then that <code>index</code> exists. This costs \\(O(h)\\) </p> <p>This is like binary search on <code>idx</code>. </p> <pre><code>class TreeNode:\n    def __init__(self,val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef compute_height(node):\n    height = 0\n    while node.left:\n        height += 1\n        node = node.left\n    return height\ndef exists(idx, height, node):\n    left = 0\n    right = (1 &lt;&lt; height) - 1\n    for i in range(height):\n        mid = (left + right)//2\n        if idx &lt;= mid:\n            node = node.left\n            right = mid\n        else:\n            node = node.right\n            left = mid + 1\n        if not node:\n            return False\n    return True\ndef last_node_value(root):\n    if not root: return None\n    height = compute_height(root)\n    if height == 0: return root.val\n    left = 0\n    right = (1 &lt;&lt; height) - 1 #max pos nodes at last level\n    # binary search for last existing node index\n    while left &lt;= right:\n        mid = (left + right) // 2\n        if exists(mid,height,root):\n            left = mid + 1\n        else:\n            right = mid - 1\n    # traverse the node at index 'right' to get its value\n    idx = right\n    node= root\n    left=  0\n    right = (1 &lt;&lt; height) - 1\n    for _ in range(height):\n        mid = (left + right) // 2\n        if idx &lt;= mid:\n            node = node.left\n            right = mid\n        else:\n            node = node.right\n            left = mid + 1\n    return node.val if node else None\n</code></pre>"},{"location":"DSAyy/trees/#consecutive-parent-child","title":"Consecutive Parent-Child","text":"<p>Given root of binary tree A, count number of parent-child pais such that their values differ by exactly 1.  $$ |parent.val - child.val| = 1 $$</p>"},{"location":"DSAyy/trees/#how_13","title":"How","text":"<p>Simple tree traversal, (BFS or DFS), For each node: 1. If it has a left child, check if \\(|node.val - node.left.val| = 1,\\)  if yes increment the count. 2. Same for the right.</p> <pre><code>class TreeNode:\n    def __init__(self, val = 0, left= None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef count_consec_pairs(root):\n    if not root: return 0\n    count = 0\n    stack = [root]\n    while stack:\n        node= stack.pop()\n        if node.left:\n            if abs(node.val - node.left.val) == 1:\n                count += 1\n            stack.append(node.left)\n        if node.right:\n            if abs(node.val - node.right.val) == 1L\n                count += 1\n            stack.append(node.right)\n    return count\n</code></pre>"},{"location":"DSAyy/trees/#balanced-binary-tree","title":"Balanced Binary Tree","text":"<p>Given root of binary tree A, determine if its height balanced. A binary tree is height balanced. </p> <p>Height balanced means \\(|depth(A.left) - depth(A.right)| \\leq 1\\)</p> <p>Return the boolean if its height balanced.</p>"},{"location":"DSAyy/trees/#how_14","title":"How","text":"<p>Naive way would be computing height of its left and right subtree and checking the difference.</p> <p>But we can use a single post-order traversal: 1. Recursively compute the height of each subtree 2. If any tree if already unbalanced, propogate a sentinel (ex: \\(-1\\) ) upward immediately. 3. At each node, obtain the leftH and rightH, and if either is \\(-1\\) otherwise do the usual check. <pre><code>class TreeNode:\n    def __init__(self, val= 0 , left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right= right\ndef is_balanced(root):\n    def check_height(node):\n        if not node: return 0\n        left_height = check_height(node.left)\n        if left_height == -1: return -1\n        right_height = check_height(node.right)\n        if right_height == -1: return -1\n\n        if abs(left_height - right_height) &gt; 1:\n            return -1\n        return max(left_height, right_height) + 1\n    return 0 if check_height(root) == -1 else 1\n</code></pre></p>"},{"location":"DSAyy/trees/#maximum-edge-removal","title":"Maximum Edge Removal","text":"<p>Given an undirected tree, with an even number of nodes A. You may remove as many edges as possible so that each resulting connected component (subtree) has an even number of nodes.</p> <p>Return the maximum number of edges that can be removed.</p>"},{"location":"DSAyy/trees/#how_15","title":"How","text":"<p>Root the tree at node 1, we want to cut as many parent-child edges such that resulting connected components have even size. 1. If a subtree is rooted at u and has even number of nodes, we may cut te edge connecting it to its parent.  2. If a subtree has odd size, we cannot cut its root to parent edge.</p> <p>So 1. Compute, for every node <code>u</code>, the size of its subtree. 2. Process nodes in post order, (children first). Whenever a node \\(u\\neq\\) 1 has an even subtree size, increment the answer by 1, and do not add u's size to its parent.  3. If it has odd size, add u's size to its parent's running total. 4. Root's final collected size is A, which is even, but we can never cut above the root.</p> <pre><code>from collections import defaultdict\ndef max_edge_removal_even_tree(A,B):\n    #build adj\n    adj = defaultdict(list)\n    for u,v in B:\n        adj[u].append(v)\n        adj[v].append(u)\n    #post order setup\n    parent = [0]*(A+1)\n    parent[1] = 0\n    stack = [(1,0)]\n    postorder = []\n\n    while stack:\n        u,p = stack.pop()\n        postorder.append(u)\n        parent[u] = p\n        for v in adj[u]:\n            if v != p:\n                stack.append((v,u))\n    subsize = [1]*(A+1) #subtree size, default itself (1)\n    answer = 0\n    for u in reversed(postorder):\n        if u != 1 and subsize[u] % 2 == 0:\n            answer += 1\n        else:\n            p = parent[u]\n            if p != 0:\n                subsize[p] += u\n    return answer\n</code></pre>"},{"location":"DSAyy/trees/#merge-binary-trees","title":"Merge Binary Trees","text":"<p>Given two binary trees <code>A</code> and <code>B</code>. merge them into a single binary tree according to this rule 1. if two nodes overlap (both non-null at same position). sum their value to form a new node. 2. otherwise use the non-null node as in the merged tree. Return a pointer to the root of the merged tree.</p> <p>Input, ptr to A and B, Output the root ptr to merged binary tree.</p>"},{"location":"DSAyy/trees/#how_16","title":"How","text":"<p>We perform a simultaneous pre-order traversal of both trees: 1. if both current nodes u (from A) and v (from B) are non-null, create (or reuse) a node with value \\(u.val + v.val\\)      1. Recursively merge left children     2. Recursively merge right children</p> <pre><code>class TreeNode:\n    def __init__(self,val = 0, left= None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef mergeTrees(u,v):\n    if not u: return v\n    if not v: return u\n    u.val += v.val\n    u.left = mergeTrees(u.left,v.left)\n    u.right = mergeTrees(u.right,v.right)\n    return u\n</code></pre>"},{"location":"DSAyy/trees/#symmetric-binary-tree","title":"Symmetric Binary Tree","text":"<p>Given the root of binary tree A, determine whether it is symmetric around its center (i.e a mirror of itself). In other words, left and right subtree should be mirror images.</p>"},{"location":"DSAyy/trees/#how_17","title":"How","text":"<ol> <li>If both nodes are null, they match</li> <li>if one is null and other is not, they dont</li> <li>otherwise we repeat the top 2 for pair (left.left,right.right) and (left.right, right.left)</li> </ol> <pre><code>from collections import deque\nclass TreeNode:\n    def __init__(self, val = 0, left =None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef is_symmetric(root):\n    if not root: return 1\n    queue = deque()\n    queue.append((root.left,root.right))\n    while queue:\n        u,v = queue.popleft()\n        if not u and not v: continue\n        if not u or not v: return 0\n        if u.val != v.val: return 0\n        queue.append((u.left,v.right))\n        queue.append((u.right,v.right))\n    return 1 \n</code></pre>"},{"location":"DSAyy/trees/#identical-binary-tree","title":"Identical Binary Tree","text":"<p>Given two trees A and B, return if they are identical, structurally and value vise.</p>"},{"location":"DSAyy/trees/#how_18","title":"How","text":"<pre><code>class TreeNode:\n    def __init__(self,val = 0, left= None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef is_same_tree(u,v):\n    if not u and not v: return 1\n    if not u or not v: return 0\n    if u.val != v.val: return 0\n    return (is_same_tree(u.left,v.left) and is_same_tree(u.right,v.right)):\n</code></pre>"},{"location":"DSAyy/trees/#construct-bst-from-preorder","title":"Construct BST from PreOrder","text":"<p>Given an int arr of distinct elements representing the preorder traversal of a BST, construct the corresponding BST, and return its root pointer.</p>"},{"location":"DSAyy/trees/#how_19","title":"How","text":"<p>In a BST, for a node with val <code>v</code>, all subsequent preorder values less than <code>v</code> belong to the left subtree. Values greater than <code>v</code> belong to the right subtree or higher up.</p> <p>Simulate insertion using a stack: 1. First element \\(A[0]\\) becomes the root. 2. Maintain a stack of nodes representing the path from the root down to the most recently inserted node. 3. For each new value \\(A[i]\\) :     1. If \\(A[i]\\) is less than the value at the top of the stack, it must be the left child of that top value. Create a new node and attach it as top.left and push it on to the stack.     2. Else: pop from stack until you find a node that is greater than \\(A[i]\\). The last popped node is the parent of the new node in its right subtree.  Create the new node as parent.right, then push it onto the stack. 4. Continue until all elements are processed.</p> <pre><code>class TreeNode:\n    def __init__(self,val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef bst_from_preorder(preorder):\n    if not preorder: return Node\n    root = TreeNode(preorder[0])\n    stack = [root]\n    for i in range(1,len(preorder)):\n        curr = TreeNode(preorder[i])\n        #smaller than stack top? left child\n        if preorder[i] &lt; stack[-1].val:\n            stack[-1].left = curr\n        else: #find parent in right chain\n            parent = None\n            while stack and preorder[i] &gt; stack[-1].val:\n                parent = stack.pop()\n            parent.right = curr\n        stack.append(curr)\n    return root\n</code></pre>"},{"location":"DSAyy/trees/#inorder-traversal-of-a-cartesian-tree","title":"Inorder Traversal Of a Cartesian Tree","text":"<p>Given arr <code>A</code> on distinct integers, representing inorder traversal of a cartesian tree. Return the cartesian tree and its root. </p> <p>Cartesian Tree: 1. Heap Property: every node's value is greater than all values in its subtree. 2. Inorder property: an inorder traversal of the tree yields exactly the orignal array <code>A</code>.</p>"},{"location":"DSAyy/trees/#how_20","title":"How","text":"<p>To build the cartesian tree in \\(O(n)\\) time, we process A from left to right using a stack. 1. Init an empty stack <code>st</code> of TreeNode pointers. 2. For each value x = <code>A[i]</code>     1. Create a new node <code>curr</code> = TreeNode(x)     2. Pop nodes from the top of the stack while they have value less than x. Let last be the last node popped (or <code>nullptr</code> if none). Attach last as <code>curr.left</code>. This would maintain the inorder property: everything popped lies to the left of <code>x</code>.     3. If the stack is nonempty aftert popping, the new top's value is &gt; x, so we attach <code>curr</code> as <code>st.top().right</code>. This would ensure <code>curr</code> becomes the right child of the nearest larger node to its left.     4. Push <code>curr</code> onto the stack. 3. After processing all elements, bottom of the stack (first el pushed) is the root of cartesian tree.</p> <pre><code>class TreeNode:\n    def __init__(self,val):\n        self.val = val\n        self.left = None\n        self.right = None\ndef build_cartesian_tree(A):\n    st = []\n    for i in range(len(A)):\n        curr = TreeNode(A[i])\n        last = None\n        while st and st[-1].val &lt; A[i]:\n            last = st.pop()\n        curr.left = last\n        if st:\n            st[-1].right = curr\n        st.append(cur)\n    return st[0] if st else None\n</code></pre>"},{"location":"DSAyy/trees/#sorted-array-to-balanced-bst","title":"Sorted Array to Balanced BST","text":"<p>Given an array <code>A</code> of length <code>n</code> whose elements are sorted in strictly ascending order, convert it into a height balanced BST. </p> <p>Basically the depth of right and left subtree differ by atmost 1.</p>"},{"location":"DSAyy/trees/#how_21","title":"How","text":"<ol> <li>In a BST, in-order traversal yields the sorted sequence.</li> <li>To keep it balanced, choose the mid element of the array as root,  and half of the elements go to the left subtree and half to the right.</li> <li>Recursively apply the same procedure to the left subarray's midpoint and right subarray's midpoint.</li> </ol> <pre><code>class TreeNode:\n    def __init__(self,val):\n        self.val = val\n        self.left = None\n        self.right = None\ndef sorted_arr_to_bst(A):\n    def build_bst(l,r):\n        if l &gt; r:\n            return None\n        mid = l + (r- l) //2\n        node = TreeNode(A[mid])\n        node.left = build_bst(l,mid - 1)\n        node.right = build_bst(mid + 1, r)\n        return node\n    return build_bst(0, len(A) - 1)\n</code></pre>"},{"location":"DSAyy/trees/#construct-binary-tree-from-inorder-and-preorder","title":"Construct Binary Tree from Inorder and preorder","text":"<p>Given 2 int arrays A and B having pre-order and in-order traversal. Construct the binary tree and return its root pointer.</p>"},{"location":"DSAyy/trees/#how_22","title":"How","text":"<p>In preorder, first element is always the root. In inorder, the elements to the lest of that root are in left subtree, and els to the right are in right subtree.</p> <ol> <li>Maintain a global preIndex into the preorder array.</li> <li>Define a recursive function \\(build(inL,inR)\\) that constructs the subtree whose in-order indices range from \\(inL\\) to \\(inR\\) .</li> <li>In \\(build(inL,inR)\\):<ol> <li>root would be \\(A[preIndex]\\) , increment this ptr</li> <li>look for this value in inOrder array. call this <code>mid</code></li> <li>Now left subtree would be \\(B[inL...mid-1]\\)  and right subtree would be \\(build(mid+1 ... inR)\\) </li> <li>return root <pre><code>class TreeNode:\n    def __init__(self,val):\n        self.val = val\n        self.left=  None\n        self.right = None\ndef build_tree(preorder, inorder):\n    idx_map = {val : idx for idx,val in enumerate(inorder)}\n    pre_index = [0] #to pass by index\n    def build(left,right):\n        if left &gt; right: return None\n        root_val = preorder[pre_index[0]]\n        pre_index[0] += 1\n        root = TreeNode(root_val)\n        mid = idx_map[root_val]\n        root.left = build(left, mid - 1)\n        root.right = build(mid + 1, right)\n        return root\n    return build(0, len(inorder) - 1)\n</code></pre></li> </ol> </li> </ol>"},{"location":"DSAyy/trees/#binary-tree-from-inorder-and-postorder","title":"Binary Tree from Inorder and PostOrder","text":"<p>Given inorder and post-order traversal in an array, construct the binary tree and return the root pointer.</p>"},{"location":"DSAyy/trees/#how_23","title":"How","text":"<p>In the post order traversal, last element is always the root of the sub tree. Like above we use it but backwards.</p> <pre><code>class TreeNode:\n    def __init__(self,val):\n        self.val = val\n        self.left = None\n        self.right = None\ndef build_tree(inorder, postorder):\n    idx_map = {val,idx for idx,val in enumerate(inorder)}\n    post_index = [len(postorder) - 1] #use list for mutable int\n    def build(left,right):\n        if left &gt; right: return None\n        root_val = postorder[post_index[0]]\n        post_index[0] -= 1\n        root = TreeNode(root_val)\n        mid = idx_map[root_val]\n        root.right = build(mid + 1, right) #make the right first\n        root.left = build(left, mid - 1)\n        return root\n    return build(0,len(inorder) - 1)\n</code></pre>"},{"location":"DSAyy/trees/#vertical-order-traversal-of-binary-tree","title":"Vertical Order Traversal of Binary Tree","text":"<p>Given a binary tree of <code>N</code> nodes. Return a 2d array denoting its vertical order traversal. Label the root's column index as <code>0</code>; for any node at column <code>c</code>, its left child at column <code>c-1</code>, and its right child at column <code>c+1</code>.</p> <p>Group nodes by column. Basically column index is the array index. Give all elements column wise.</p>"},{"location":"DSAyy/trees/#how_24","title":"How","text":"<p>Perform a BFS but with node, also carry the current column index. When sending in left child, bas do <code>c-1</code>, and when going right, do <code>c+1</code>.</p> <pre><code>from collections import defaultdict, deque\nclass TreeNode:\n    def __init__(self,val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef vertical_order_traversal(root):\n    result = []\n    if root is None: return result\n    col_map = defaultdict(list)\n    min_col = max_col = 0\n    q = deque([(root,0)])\n    while q:\n        node , col = q.popleft()\n        col_map[col].append(node.val)\n        min_col = min(min_col,col)\n        max_col = max(max_col,col)\n        if node.left: q.append((node.left, col - 1))\n        if node.right: q.append((node.right, col + 1))\n    total_cols = max_col - min_col + 1\n    result = [[] for _ in range(total_cols)]\n    for col in range(min_col,max_col + 1):\n        result[col - min_col] = col_map[col]\n    return result\n</code></pre>"},{"location":"DSAyy/trees/#diagonal-traversal-of-binary-tree","title":"Diagonal Traversal Of Binary Tree","text":"<p>Given a binary tree A with N nodes, output all nodes in a diagonal order. Where nodes lying on the same line of slope - 1 belong to the same diagonal. Label the node's diagonal as 0.</p> <p>Within each diagonal, node must be in preorder. Finally concatenate the diagonals from smallest index to largest. (leftmost to rightmost)</p> <p>Input: Root of binary tree. Output: 1D array</p>"},{"location":"DSAyy/trees/#how_25","title":"How","text":"<p>A node's diagonal index d is defined as: $$ d(root) = 0, \\space d(node.left) = d(node) + 1, \\space d(node.right) = d(node) $$ Bas bhai map ke saath banate reh.</p> <pre><code>class TreeNode:\n    def __init__(self, val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef diagonal_traversal(root):\n    if not root: return []\n    diag_nodes = [] #list of lists\n    max_diag = 0\n    stack = [(root,0)]\n    while stack:\n        node, d = stack.pop() #dfs style\n        if len(diag_nodes) &lt;= d: #extend if diagonal too big\n            diag_nodes.extend([[] for _ in range(d - len(diag_nodes) + 1)])\n        diag_nodes[d].append(node.val)\n        max_diag = max(max_diag,d)\n        if node.right:\n            stack.append((node.right, d))\n        if node.left:\n            stack.append((node.left, d+1))\n    for i in range(max_diag + 1):\n        result.extend(diag_nodes[i])\n    return result\n</code></pre>"},{"location":"DSAyy/trees/#vertical-sum-of-a-binary-tree","title":"Vertical Sum of a Binary Tree","text":"<p>Given the root pointer of a binary tree. Comput the vertical sum for each vertical line of the tree. Label the root's column as 0; for any node at column c, its left child is at column <code>c-1</code> and right at <code>c+1</code> . The vertical sum for a column is the sum of all node values that lie in that column. Return an array of these sums, ordered from the leftmost column to the rightmost column.</p>"},{"location":"DSAyy/trees/#how_26","title":"How","text":"<p>Perform a BFS of the tree while tracking each node's column index. Keep a hasmap as column's sum metric.  Similar to what we solved above.</p> <pre><code>from collections import defaultdict, deque\nclass TreeNode:\n    def __init__(self,val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef vertical_sum(root):\n    if not root: return []\n    col_sum = defaultdict(int)\n    min_col = max_col = 0\n    q = deque([(root,0)])\n    while q:\n        node,col = q.popleft()\n        col_sum[col] += node.val\n        min_col = min(min_col,col)\n        max_col = max(max_col,col)\n        if node.left:\n            q.append((node.left,col - 1))\n        if node.right:\n            q.append((node.right, col + 1))\n    total_cols = max_col - min_col + 1\n    result = [0]*total_cols\n    for col in range(min_cols, max_cols + 1):\n        result[col - min_col] = col_sum[col]\n    return result\n</code></pre>"},{"location":"DSAyy/trees/#covered-uncovered-nodes","title":"Covered / Uncovered Nodes","text":"<p>Given root of a binary tree A. A node is : - Uncovered if it appears as either the first or the last node on its level. - Covered otherwise Compute absolute difference of: $$ |\\text{(sum of covered values) - (sum of uncovered values)}| $$</p>"},{"location":"DSAyy/trees/#how_27","title":"how","text":"<p>Perform BFS, to identfy first or last at each level. <pre><code>from collections import deque\nclass TreeNode:\n    def __init__(self,val = 0, left= None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef covered_minus_uncovered_sum(root):\n    if not root:\n        return 0\n    covered_sum = 0\n    uncovered_sum = 0\n    q = deque([root])\n    while q:\n        sz = len(q)\n        for i in range(sz):\n            node = q.popleft()\n            if i == 0 or i == sz - 1:\n                uncovered_sum += node.val\n            else:\n                covered_sum += node.val\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n    return covered_sum - uncovered_sum\n</code></pre></p>"},{"location":"DSAyy/trees/#inorder-traversal-of-a-binary-tree","title":"Inorder Traversal of A Binary Tree","text":"<p>Given <code>root</code> pointer of a binary tree, return its nodes in inOrder travesal.</p> <pre><code>class TreeNode:\n    def __init__(self,val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef inorder_traversal(root):\n    res, stack = [], []\n    while root or stack:\n        #go as far left as possible\n        while root:\n            stack.append(root)\n            root = root.left\n        #visit node (mid)\n        root = stack.pop()\n        res.append(root.val)\n        # then go right\n        root = root.right\n    return res\n</code></pre>"},{"location":"DSAyy/trees/#preorder-traversal-of-a-binary-tree","title":"Preorder Traversal Of a Binary Tree","text":"<p>Given <code>root</code> pointer of a binary tree, return its nodes in preorder traversal. <pre><code>class TreeNode:\n    def __init__(self, val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef preorder_traversal(root):\n    res, stack = [],[]\n    if root: stack.append(root)\n    while stack:\n        node = stack.pop()\n        res.append(node.val)\n        if node.right: \n            stack.append(node.right) #right first\n        if node.left:\n            stack.append(node.left) #then left, so left is processed first\n    return res\n</code></pre></p>"},{"location":"DSAyy/trees/#postorder-traversal-of-a-binary-tree","title":"PostOrder Traversal Of a binary Tree","text":"<p>Given <code>root</code> pointer of a binary tree, return its nodes in postorder traversal <pre><code>class TreeNode:\n    def __init__(self, val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef postorder_traversal(root):\n    if not root: return []\n    toVisit, visited = [root], []\n    while s1:\n        node = toVisit.pop()\n        visited.append(node)\n        if node.left: toVisit.append(node.left)\n        if node.right: toVisit.append(node.right)\n    return [n.val for n in reversed(visited)]\n</code></pre></p>"},{"location":"DSAyy/trees/#right-view-of-a-binary-tree","title":"Right view of a binary tree","text":"<p>Given <code>root</code>, return an <code>array</code> of int representing the right view of the tree. Basically the nodes that are visible when looked from the right.</p> <p>Basically the last element in every level order.</p> <pre><code>from collections import deque\nclass TreeNode:\n    def __init__(self,val = 0, left = 0, right = 0):\n        self.val = val\n        self.left =left\n        self.right = right\ndef rightView(root):\n    if not root: return []\n    right_view = []\n    q = deque([root])\n    while q:\n        sz = len(q)\n        for i in range(sz):\n            node = q.popleft()\n            if i == sz - 1:\n                right_view.append(node.val)\n            if node.left: q.append(node.left)\n            if node.right: q.append(node.right)\n    return right_view\n</code></pre>"},{"location":"DSAyy/trees/#cousins-in-a-binary-tree","title":"Cousins in a binary tree","text":"<p>Given <code>root</code> pointer of a binary tree with <code>N</code> nodes, and a target value <code>B</code> that exists in the tree. Return an <code>array</code> of all the cousins of node whole value is <code>B</code>. </p> <p>Two nodes are cousins, if they are on the same depth, but have different parents.  Sibling nodes are not cousins.</p>"},{"location":"DSAyy/trees/#how_28","title":"How","text":"<p>Perform a single BFS (level order), that keeps track of each node's parent 1. Record the nodes at the level <code>levelNodes</code> 2. Check if <code>B</code> is in <code>levelNodes</code> along with its parent pointer. 3. Return all other nodes on the level with different parent.</p> <pre><code>from collections import deque\nclass TreeNode:\n    def __init__(self,val = 0,left = None,right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef find_cousins(root,B):\n    if not root: return []\n    cousins = []\n    q = deque()\n    q.append((root,None)) # (node,parent)\n    while q: \n        sz = len(q)\n        level_nodes = []\n        target_parent = None\n        for _ in range(sz):\n            node, parent = q.popleft()\n            level_nodes.append((node,parent))\n            if node.val == B:\n                target_parent = parent\n        if target_parent:\n            for node,parent in level_nodes:\n                if parent != target_parent and node.val != B:\n                    cousins.append(node.val)\n        #enqueue children for the next level\n        for node,parent in level_nodes:\n            if node.left: q.append((node.left,node))\n            if node.right: q.append((node.right,node))\n    return cousins\n</code></pre>"},{"location":"DSAyy/trees/#reverse-level-order-traversal-of-a-binary-tree","title":"Reverse Level Order Traversal of a Binary Tree","text":"<p>Given <code>root</code>, return nodes in reverse level order. Like from bottom-most to the top.</p>"},{"location":"DSAyy/trees/#how_29","title":"How","text":"<p>Just do a normal BFS (level order) from top to bottom. But store each level's value in a list then prepend it to a <code>deque</code>.  1. Record current level, and push it to the front of the <code>deque</code>. 2. Now it will have from bottom to top coz we pushed to the front. <pre><code>from collections import deque\nclass TreeNode:\n    def __init__(self,val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef reverseLevel(root):\n    res = []\n    if not root: return res\n    q = deque([root])\n    levels = deque()\n    while q:\n        sz = len(q)\n        level = []\n        for _ in range(sz):\n            node = q.popleft()\n            level.append(node.val)\n            if node.left: q.append(node.left)\n            if node.right: q.append(node.right)\n        levels.appendleft(level)\n    for lvl in levels: res.extend(lvl)\n    return res\n</code></pre></p>"},{"location":"DSAyy/trees/#zigzag-level-order","title":"Zigzag Level Order","text":"<p>Given <code>root</code> of binary tree, return nodes in zigzag level order. - level 0, L to R - level 1, R to L basically alternating direction every level</p> <p>just reverse the even level bro i dont even know</p> <pre><code>from collections import deque\nclass TreeNode:\n    def __init__(self,val=0,left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef zigzag(root):\n    res = []\n    if not root: return res\n    q = deque([root])\n    left_to_right = True\n    while q:\n        sz = len(q)\n        level = []\n        for _ in range(sz):\n            node = q.popleft()\n            level.append(node)\n            if  node.left: q.append(node.left)\n            if node.right: q.append(node.right)\n        if not left_to_right: level = reversed(level)\n        left_to_right = !left_to_right\n        res.extend(level)\n    return res\n</code></pre>"},{"location":"DSAyy/trees/#populate-next-right-pointers-in-a-binary-tree","title":"Populate Next Right Pointers in a Binary Tree","text":"<p>Given the root pointer of a binary tree. The struct also has a next pointer. Populate each node's <code>next</code> pointer so that ir points to the node immediately to its right on the same level. If there is no such node, let <code>next</code> be null.</p> <pre><code>class TreeLinkNode:\n    def __init__(self, val = 0, left = None, right = None, next =None):\n        self.val = val\n        self.left= left\n        self.right = right\n        self.next = next\ndef connect(root):\n    head = root #head of current level\n    while head:\n        dummy = TreeLinkNode(0)\n        tail = dummy\n        curr = head\n\n        while cur:\n            if cur.left:\n                tail.next = cur.left\n                tail = tail.next\n            if cur.right:\n                tail.next = cur.right\n                tail = tail.next\n            cur = cur.next\n        head = dummy.next\n</code></pre>"},{"location":"DSAyy/trees/#burn-a-tree","title":"Burn a Tree","text":"<p>Given <code>root</code> of a binary tree A, and a target leaf <code>B</code>, a fire starts at node B at time = 0. Each second, the fire spreads from any burning node to its directly connected neighbors (left child, right child and parent). Compute minimum time required to burn the entire tree.</p>"},{"location":"DSAyy/trees/#how_30","title":"How","text":"<p>Run BFS, and treat the tree like an undirected graph. In BFS, also pass the time, and then check the min time.</p> <pre><code>from collections import deque, defaultdict\nclass TreeNode:\n    def __init__(self, val = 0, left = None, right = None):\n        self.val = val\n        self.left= left\n        self.right = right\ndef build_parent_map(root,parent_map):\n    queue = deque([root])\n    while queue:\n        node = queue.popleft()\n        if node.left:\n            parent_map[node.left] = node\n            queue.append(node.left)\n        if node.right:\n            parent_map[node.right] = node\n            queue.append(node.right)\ndef find_target_node(root, target):\n    if not root: return None\n    if root.val == target: return root\n    left = find_target_node(root.left, target)\n    if left: return left\n    return find_target_node(root.right, target)\ndef burn_tree(root, target_val):\n    if not root: return 0\n    parent_map = {}\n    build_parent_map(root,parent_map)\n    target_node = find_target_node(root,target_val)\n    visited = set()\n    queue = deque([target_node])\n    visited.add(target_node)\n    time = -1 #first level at t = 0\n    while queue:\n        sz = len(queue)\n        for _ in range(sz):\n            node = queue.popleft()\n            for neighbor in [node.left, node.right, parent_map.get(node)]:\n                if neighbor and neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)  \n        time += 1\n    return time\n</code></pre>"},{"location":"DSAyy/trees/#max-depth-of-a-binary-tree","title":"Max Depth of a Binary Tree","text":"<p>Given the <code>root</code> pointer of a binary tree, find its maximum depth. <pre><code>from collections import deque\nclass TreeNode:\n    def __init__(self, val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right= right\ndef maxDepth(root):\n    if not root: return 0\n    q = deque([root])\n    depth = 0\n    while q:\n        sz = len(q)\n        depth ++\n        for _ in range(sz):\n            node = q.popleft()\n            if node.left: q.append(node.left)\n            if node.right: q.append(node.right)\n    return depth\n</code></pre></p>"},{"location":"DSAyy/trees/#sum-root-to-leaf-numbers","title":"Sum Root to Leaf Numbers","text":"<p>Given <code>root</code> to a binary tree whose node contain 0-9, each root to leaf path represents a number concatenating the digits along the way. Return sum of all sum numbers modulo 1003.</p> <pre><code>class TreeNode:\n    def __init__(self,val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef sum_root_to_leaf_numbers(root):\n    if not root: return 0\n    MOD = 1003\n    result = 0\n    stack = [(root,root.val % MOD)] #(node, cur_sum modulo)\n    while stack:\n        node, curr = stack.pop()\n        if not node.left and not node.right:\n            result = (result + curr) % MOD\n        if node.right:\n            next_val = (curr*10 + node.right.val) % MOD\n            stack.append((node.right, next_val))\n        if node.left:\n            next_val = (curr*10 + node.left.val) % MOD\n            stack.append((node.left, next_val))\n    return result\n</code></pre>"},{"location":"DSAyy/trees/#path-sum","title":"Path Sum","text":"<p>Given <code>root</code> of a binary tree, and an int <code>B</code>, determine whether there exists a root-to-leaf path in A such that sum of node values along that path equals B.</p> <p>Just DFS and pass cur sum bro</p> <pre><code>class TreeNode:\n    def __init__(self, val = 0, left=  None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef has_path_sum(root, target_sum):\n    if not root: return 0\n    stack = [(root, root.val)] #(node, cur sum)\n    while stack:\n        node, cur_sum = stack.pop()\n        if not node.left and not node.right:\n            if cur_sum == target_sum: return 1\n        if node.right:\n            stack.append((node.right, cur_sum + node.right.val))\n        if node.left:\n            stack.append((node.left, cur_sum + node.left.val))\n    return 0\n</code></pre>"},{"location":"DSAyy/trees/#min-depth-of-a-binary-tree","title":"Min Depth of a Binary Tree","text":"<p>Given the <code>root</code> of a binary tree. Find its minimum depth. Basically min root-to-leaf path.</p> <pre><code>from collections import deque\nclass TreeNode:\n    def __init__(self,val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef min_depth(root):\n    if not root: return 0\n    queue= deque([(root,1)]) #(node, curr depth)\n    while queue:\n        node, depth = queue.popleft()\n        if not node.left and not node.right: #return the earliest you reach leaf\n            return depth\n        if node.left: \n            queue.append((node.left, depth + 1))\n        if node.right:\n            queue.append((node.right, depth + 1))\n    return 0    \n</code></pre>"},{"location":"DSAyy/trees/#root-to-leaf-paths-with-sum","title":"Root to leaf paths with sum","text":"<p>Given <code>root</code> of a binary tree, and an int <code>B</code>. Find all root-to-leaf paths such that the sum of the node values along each path equals <code>B</code>. Return a list of these.</p> <pre><code>class TreeNode:\n    def __init__(self, val = 0, left =None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef find_paths_with_sum(root, target_sum):\n    res = []\n    if not root: return res\n    stack = [(root, root.val, [root.val])] #(node, cur sum, path list)\n    while stack:\n        node, curr_sum, path = stack.pop()\n        if node.left is None and node.right is None:\n            if curr_sum == target_sum:\n                res.append(path)\n        if node.right:\n            new_path = path + [node.right.val]\n            stack.append((node.right, curr_sum + node.right.val, new_path))\n        if node.left:\n            new_path = path + [node.left.val]\n            stack.append((node.left, curr_sum + node.left.val, new_path))\n    return res\n</code></pre>"},{"location":"DSAyy/trees/#invert-binary-tree","title":"Invert Binary Tree","text":"<p>Given <code>root</code> of binary tree, invert the binary tree in place, and return the root of inverted tree. Basically mirror image kar diya.</p> <p>Left becomes right and right becomes left.</p> <pre><code>class TreeNode:\n    def __init__(self,val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef invert_binary_tree(root):\n    if not root: return None\n    stack = [root]\n    while stack:\n        node = stack.pop()\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n    return root\n</code></pre>"},{"location":"DSAyy/trees/#least-common-ancestor-in-a-binary-tree","title":"Least Common Ancestor in a Binary Tree","text":"<p>Given <code>root</code> of an unordered binary tree, and two int <code>B</code> and <code>C</code>. Find value of LCA of nodes with value <code>B</code> and <code>C</code>. LCA is like deepest node with common descendents.</p>"},{"location":"DSAyy/trees/#how_31","title":"How","text":"<ol> <li>Locate each node and record its parent.<ul> <li>BFS from root.</li> <li>Do the parent mapping.</li> <li>store the <code>nodeB</code> and <code>nodeC</code> when you come across it.</li> <li>do untill both nodeB and nodeC are not found.</li> </ul> </li> <li>Build the ancestor chain for one node, then walk up from other.<ul> <li>Visit the ancestor chain of <code>nodeB</code>. Then check nodeC for the deepest ancestor already visited in <code>nodeB</code>'s chain. <pre><code>class TreeNode:\n    def __init__(self, val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef find_lca(root, B, C):\n    if not root: return -1\n    parent = {}\n    parent[root] = None\n    nodeB = nodeC = None\n\n    from collections import deque\n     q= deque([root])\n    while q: #fill the parent map and check if both nodes exist\n        node = q.popleft()\n        if node.val == B:\n            nodeB = node\n        if node.val == C:\n            nodeC = node\n        if node.left:\n            parent[node.left] = node\n            q.append(node.left)\n        if node.right:\n            parent[node.right] = node\n            q.append(node.right)\n    if not nodeB or not nodeC: return -1\n\n    ancestors = set() #find the common parent, from ancestor list\n    curr = nodeB\n    while curr:\n        ancestors.add(curr)\n        curr = parent[curr]\n    curr = nodeC\n    while curr:\n        if curr in ancestors: return curr.val\n        curr = parent[curr]\n    return -1\n</code></pre></li> </ul> </li> </ol>"},{"location":"DSAyy/trees/#flatten-binary-tree-to-linked-list","title":"Flatten Binary tree to Linked List","text":"<p>Given <code>root</code> of a binary tree. Flatten it into a linked list.  After flattening: 1. Every node's left child is <code>NULL</code> 2. Each node's right child points to the next node in preorder traversal of orignal tree. <pre><code>class TreeNode:\n    def __init__(self, val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right=  right\ndef flatten_binary_tree(root):\n    curr = root\n    while curr:\n        if curr.left is None:\n            curr = curr.right\n        else:\n            #find the rightmost node in left subtree\n            pred = curr.left\n            while pred.right:\n                pred = pred.right\n            #rewire the connections\n            pred.right = curr.right\n            curr.right = curr.left\n            curr.left = None\n            curr = curr.right\n    return root\n</code></pre></p>"},{"location":"DSAyy/trees/#order-of-peoples-heights","title":"Order of People's Heights","text":"<p>Given pos int <code>N</code>. arr <code>Heights</code> of len <code>N</code>, containing distinct heights of N people standing in a queue.</p> <p>arr <code>infront</code> of len <code>N</code>, where <code>InFronts[i]</code> is the number of people taller than the i-th person, who must stand infront of them.</p> <p>Return arr of len <code>N</code>, which is the actual ordering of heights from front to back that satisfies all the <code>infront</code> constraints.</p>"},{"location":"DSAyy/trees/#how_32","title":"How","text":"<p>Sort all people by asc height. When inserting shortest to tallest, every unpplaced person is strictly taller than the current one. Hence, if a person of height <code>h</code> has infronts  = <code>k</code>, we need to place them at (<code>k+1</code>)th empty slot, among the remaining positions.</p> <p>To find k-th empty slot, and mark a slot as occupied, we can use a segment tree. Each leaf holds 1 if that is position is still free, Internal nodes store the sum of their children (count of free slots in that sub range)</p> <ol> <li>sort in asc (height, infont), by height</li> <li>build seg tree <code>[1..N]</code> init all leaf as 1 (all slots are free)</li> <li>for each pair (h,k) in sorted order:<ul> <li>Query the segment tree to find the index of (k+1)th free slot.</li> <li>place height at \\(answer[pos - 1]\\) = h</li> <li>update the segtree at leaf pos to 0.</li> </ul> </li> <li>Return the filled answer.</li> </ol> <pre><code>class SegmentTree:\n    def __init__(self, size):\n        self.size = size\n        self.tree = [0]*(4 * size)\n    def build(self, node, l ,r):\n        if l == r:\n            self.tree[node] = 1\n            return\n        m = (l+r)//2\n        self.build(node * 2,  l ,m)\n        self.build(node*2 + 1, m+1, r)\n        self.tree[node] = self.tree[node * 2] + self.tree[node * 2 + 1]\n    def update(self, node, l ,r, pos):\n        if l == r:\n            self.tree[node] = 0\n            return\n        m = (l+r)//2\n        if pos &lt;= m:\n            self.update(node*2, l,m,pos)\n        else:\n            self.update(node*2 + 1, m + 1, r, pos)\n        self.tree[node] = self.tree[node*2] + self.tree[node*2 + 1]\n    def kth_free(self,node,l,r,k):\n        if l == r:\n            return l\n        m = (l + r) // 2\n        left_count = self.tree[node* 2]\n        if k &lt;= left_count:\n            return self.kth_free(node*2, l,m,k)\n        else:\n            return self.kth_free(node*2 + 1, m+1, r, k- left_count)\ndef reconstruct_queue(heights, in_fronts):\n    n = len(height)\n    people = [(heights[i], in_fronts[i]) for i in range(n)]\n    people.sort(key = lambda x: (x[0], x[1]))\n    seg = SegmentTree(n)\n    seg.build(1,1,n)\n    answer = [0]*n\n    for h, inf in people:\n        k = inf + 1\n        pos = sef.kth_free(1,1,n,k)\n        answer[pos - 1] = h\n        seg.update(1,1,n,pos)\n    return answer\n</code></pre>"}]}
{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\udc4b Welcome to SDE Prep A2Z","text":"<p>Ye karne ke baad bhi tu gawar hi rahega</p>"},{"location":"#why-this-site","title":"\ud83d\ude80 Why this site?","text":"<ul> <li>Kyuki lawde unemployed hai tu</li> </ul>"},{"location":"#navigation","title":"\ud83e\udded Navigation","text":"<p>Jaake padle gaandu:</p> <ul> <li>\ud83d\udcc2 Arrays</li> <li>\ud83d\udd01 Dynamic Programming</li> <li>\ud83c\udf10 Graphs</li> <li>\ud83e\udd6c Trees</li> <li>\ud83e\udd48 Two Pointers</li> <li>\ud83d\ude14 Linked Lists</li> <li>\uff08 \u035c.\u4eba \u035c.\uff09Stacks and Queues</li> <li>Ni\u0f3c \u3064 \u25d5_\u25d5 \u0f3d\u3064gga Strings</li> <li>( \uff3e\u25e1\uff3e)\u3063\u2702\u2570\u22c3\u256f Maths</li> <li>(\u203f\u2223\u203f) slap \ud83e\udd24 Bit Manipulation</li> <li>\u256d\u2229\u256e( \u2022\u0300_\u2022\u0301 )\u256d\u2229\u256eGreedy</li> <li>\u25cf \u2588\u2580\u2588\u2584 \u2c6d\u035e \u0336\u035e \u0336\u035e \u0336\u035e \u0644\u06ba\u035eHashing</li> <li>\ud835\udd82\ud835\udd8d\ud835\udd86\ud835\udd99 \ud835\udd99\ud835\udd8d\ud835\udd8a \ud835\udd98\ud835\udd8e\ud835\udd8c\ud835\udd92\ud835\udd86 Binary Search</li> <li>\ud835\udd98\ud835\udd8d\ud835\udd9a\ud835\udd99 \ud835\udd9a\ud835\udd95 \ud835\udd8b\ud835\udd86\ud835\udd8c\ud835\udd8c\ud835\udd94\ud835\udd99 Heaps and Maps</li> <li>\ud835\udc0d\u03b9\u0648\u0648\u03b5r \ud83d\ude46\ud83c\udffe\ud83d\udc68\ud83c\udfff\u200d\ud83e\uddb1 BackTracking</li> <li>DMBS DBMS</li> <li>OOPS OOPS</li> <li>OS OS</li> </ul>"},{"location":"DSAyy/DBMS/","title":"DBMS","text":""},{"location":"DSAyy/DBMS/#index","title":"Index","text":"<ol> <li> <p>Introduction to DBMS</p> </li> <li> <p>Database Architecture</p> </li> <li> <p>Keys and Constraints</p> </li> <li> <p>SQL vs. NoSQL</p> </li> <li> <p>Normalization and Denormalization</p> </li> <li> <p>Indexing</p> </li> <li> <p>Transactions &amp; ACID Properties</p> </li> <li> <p>Concurrency Control &amp; Isolation Levels</p> </li> <li> <p>Deadlocks &amp; Resolution Strategies</p> </li> <li> <p>Joins &amp; Set Operations</p> </li> <li> <p>Stored Procedures, Functions &amp; Triggers</p> </li> <li> <p>Views &amp; Materialized Views</p> </li> <li> <p>Database Design &amp; ER Diagrams</p> </li> <li> <p>Commonly Asked Interview Questions</p> </li> <li> <p>Tips for Zomato Interview</p> </li> </ol>"},{"location":"DSAyy/DBMS/#1-introduction-to-dbms","title":"1. Introduction to DBMS","text":"<ul> <li> <p>Definition: A Database Management System (DBMS) is software that enables creation, management, and querying of databases.</p> </li> <li> <p>Purpose: Provides an abstraction layer over raw data files, ensuring data integrity, security, and efficient access.</p> </li> <li> <p>Examples: MySQL, PostgreSQL, Oracle, SQL Server for relational; MongoDB, Cassandra for NoSQL.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#2-database-architecture","title":"2. Database Architecture","text":"<ul> <li> <p>Three-Level ANSI/SPARC Model</p> <ol> <li> <p>Internal Level: Physical storage (pages, blocks on disk).</p> </li> <li> <p>Conceptual Level: Logical schema (tables, relationships).</p> </li> <li> <p>External Level: User views (restricted subsets via views).</p> </li> </ol> </li> <li> <p>Client\u2013Server: Clients send SQL queries; server processes and returns results.</p> </li> <li> <p>Tiered Architectures:</p> <ul> <li> <p>Two-tier: Client \u2194 DB server.</p> </li> <li> <p>Three-tier: Client \u2194 App server \u2194 DB server.</p> </li> </ul> </li> </ul>"},{"location":"DSAyy/DBMS/#3-keys-and-constraints","title":"3. Keys and Constraints","text":"<ul> <li> <p>Primary Key: Unique identifier for table rows; non-null.</p> </li> <li> <p>Candidate Key: Any minimal set of columns that can uniquely identify rows.</p> </li> <li> <p>Foreign Key: Enforces referential integrity between tables.</p> </li> <li> <p>Unique Constraint: Ensures all values in a column (or group) are unique.</p> </li> <li> <p>Check Constraint: Validates data against a Boolean expression.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#4-sql-vs-nosql","title":"4. SQL vs. NoSQL","text":"Aspect SQL NoSQL Schema Fixed, predefined Dynamic, flexible Data Model Tables (rows &amp; columns) Document, Key-Value, Column, Graph Transactions Strong ACID support BASE (Basic Availability, Soft state, Eventually consistent) Scaling Vertical (scale-up) Horizontal (scale-out) Use Cases Complex queries, transactions High throughput, flexible schema"},{"location":"DSAyy/DBMS/#5-normalization-and-denormalization","title":"5. Normalization and Denormalization","text":"<ul> <li> <p>Normalization: Process to eliminate redundancy &amp; anomalies via Normal Forms (1NF, 2NF, 3NF, BCNF).</p> <ul> <li> <p>1NF: Atomic values.</p> </li> <li> <p>2NF: No partial dependencies on a candidate key.</p> </li> <li> <p>3NF: No transitive dependencies.</p> </li> </ul> </li> <li> <p>Denormalization: Intentionally introducing redundancy for performance gains (e.g., read-heavy workloads).</p> </li> </ul>"},{"location":"DSAyy/DBMS/#6-indexing","title":"6. Indexing","text":"<ul> <li> <p>Purpose: Speed up data retrieval by creating auxiliary data structures.</p> </li> <li> <p>Types:</p> <ul> <li> <p>Clustered Index: Alters physical order of data. Only one per table.</p> </li> <li> <p>Non-Clustered Index: Separate structure with pointers to rows. Multiple per table.</p> </li> <li> <p>Hash Index: Uses hash table for exact-match lookups.</p> </li> <li> <p>Bitmap Index: Efficient for low-cardinality columns (e.g., gender).</p> </li> </ul> </li> <li> <p>Trade-offs:</p> <ul> <li> <p>Pros: Fast reads.</p> </li> <li> <p>Cons: Slower writes/updates; additional storage.</p> </li> </ul> </li> <li> <p>Interview Tip: Explain when to add composite indexes vs. single-column indexes, and how covering indexes reduce lookups.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#7-transactions-acid-properties","title":"7. Transactions &amp; ACID Properties","text":"<ul> <li> <p>Transaction: A unit of work that is either fully complete or fully rolled back.</p> </li> <li> <p>ACID:</p> <ol> <li> <p>Atomicity: All-or-nothing execution.</p> </li> <li> <p>Consistency: Database remains in a valid state.</p> </li> <li> <p>Isolation: Concurrent transactions don\u2019t interfere.</p> </li> <li> <p>Durability: Once committed, results persist.</p> </li> </ol> </li> <li> <p>Commit vs. Rollback: Persist or undo transaction changes.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#8-concurrency-control-isolation-levels","title":"8. Concurrency Control &amp; Isolation Levels","text":"<ul> <li> <p>Locking:</p> <ul> <li> <p>Shared Lock (S): Read-only.</p> </li> <li> <p>Exclusive Lock (X): Read/write.</p> </li> </ul> </li> <li> <p>Multi-Version Concurrency Control (MVCC): Maintains multiple versions for readers.</p> </li> <li> <p>Isolation Levels (SQL Standard):</p> <ol> <li> <p>Read Uncommitted: Dirty reads allowed.</p> </li> <li> <p>Read Committed: No dirty reads.</p> </li> <li> <p>Repeatable Read: No non-repeatable reads.</p> </li> <li> <p>Serializable: Full isolation.</p> </li> </ol> </li> <li> <p>Anomalies: Dirty reads, non-repeatable reads, phantom reads.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#9-deadlocks-resolution-strategies","title":"9. Deadlocks &amp; Resolution Strategies","text":"<ul> <li> <p>Deadlock: Two or more transactions waiting indefinitely for each other\u2019s locks.</p> </li> <li> <p>Detection: Wait-for graph cycle detection.</p> </li> <li> <p>Prevention: Lock ordering, timeouts, or no-wait policies.</p> </li> <li> <p>Resolution: Automatically roll back one transaction (victim).</p> </li> </ul>"},{"location":"DSAyy/DBMS/#10-joins-set-operations","title":"10. Joins &amp; Set Operations","text":"<ul> <li> <p>Joins:</p> <ul> <li> <p>Inner Join: Intersection of tables.</p> </li> <li> <p>Left/Right Outer Join: All from one side + matching from the other.</p> </li> <li> <p>Full Outer Join: All rows, matching where possible.</p> </li> <li> <p>Cross Join: Cartesian product.</p> </li> </ul> </li> <li> <p>Set Operations:</p> <ul> <li> <p>UNION / UNION ALL: Combine result sets (UNION removes duplicates).</p> </li> <li> <p>INTERSECT: Common rows.</p> </li> <li> <p>EXCEPT/MINUS: Rows in first not in second.</p> </li> </ul> </li> </ul>"},{"location":"DSAyy/DBMS/#11-stored-procedures-functions-triggers","title":"11. Stored Procedures, Functions &amp; Triggers","text":"<ul> <li> <p>Stored Procedure: Precompiled group of SQL statements; can perform complex operations.</p> </li> <li> <p>Function: Returns a value; can be used in SQL expressions.</p> </li> <li> <p>Trigger: Auto-executes upon DML events (INSERT/UPDATE/DELETE).</p> </li> <li> <p>Use Case: Encapsulate business logic, enforce data integrity.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#12-views-materialized-views","title":"12. Views &amp; Materialized Views","text":"<ul> <li> <p>View: Virtual table defined by a query; no storage overhead.</p> </li> <li> <p>Materialized View: Stores query result physically; must be refreshed.</p> </li> <li> <p>Benefits: Simplify complex queries, enforce security, improve performance (materialized).</p> </li> </ul>"},{"location":"DSAyy/DBMS/#13-database-design-er-diagrams","title":"13. Database Design &amp; ER Diagrams","text":"<ul> <li> <p>ER Modeling: Entities (tables), Attributes (columns), Relationships (1:1, 1:N, N:N).</p> </li> <li> <p>Design Steps:</p> <ol> <li> <p>Requirement gathering.</p> </li> <li> <p>Conceptual model (ER diagram).</p> </li> <li> <p>Logical model (relational schema).</p> </li> <li> <p>Physical model (indexes, storage).</p> </li> </ol> </li> <li> <p>Zomato Context: Model users, restaurants, orders, menus, ratings with clear relationships.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#14-commonly-asked-interview-questions","title":"14. Commonly Asked Interview Questions","text":"<ol> <li> <p>Difference between DELETE and TRUNCATE</p> <ul> <li>DELETE logs individual row deletions &amp; can be rolled back; TRUNCATE deallocates pages, faster, cannot be rolled back in most DBs.</li> </ul> </li> <li> <p>Explain ACID vs. BASE</p> <ul> <li>ACID (strict consistency), BASE (eventual consistency suited for high-scale NoSQL).</li> </ul> </li> <li> <p>When would you choose NoSQL over SQL?</p> <ul> <li>Flexible schema, massive horizontal scalability, simple key-value access.</li> </ul> </li> <li> <p>What is a covering index?</p> <ul> <li>An index that contains all columns needed by a query, avoiding lookup to base table.</li> </ul> </li> <li> <p>How do you detect and handle deadlocks?</p> <ul> <li>Monitor wait-for graphs; set lock timeouts; implement retry logic.</li> </ul> </li> <li> <p>Explain isolation levels with examples of anomalies.</p> </li> <li> <p>Describe normalization up to 3NF with examples.</p> </li> <li> <p>How do you optimize slow SQL queries?</p> <ul> <li>Analyze execution plan, add appropriate indexes, rewrite joins/subqueries, use pagination.</li> </ul> </li> <li> <p>What is MVCC and how does it work?</p> </li> <li> <p>Design a table schema for storing user ratings and reviews.</p> </li> </ol>"},{"location":"DSAyy/DBMS/#15-tips-for-zomato-interview","title":"15. Tips for Zomato Interview","text":"<ul> <li> <p>Relate Answers to Scale: Emphasize how indexing, partitioning, and sharding help handle Zomato\u2019s high-traffic order and search workloads.</p> </li> <li> <p>Use Real-World Metrics: \u201cAt peak hours, we process X QPS; an index can reduce I/O by Y%.\u201d</p> </li> <li> <p>Discuss Data Consistency: Balance between strong consistency for payments vs. eventual consistency for analytics.</p> </li> <li> <p>Be Ready to Whiteboard: Sketch ER diagrams quickly for restaurants\u2013menus\u2013orders.</p> </li> <li> <p>Behavioral Tie-In: Show how you\u2019ve debugged slow queries or optimized a schema in past projects.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#more-detailed","title":"More Detailed","text":"<p>Below are the first five topics expanded with deeper explanations, practical examples, and \u201ccommon interview queries\u201d you might encounter.</p>"},{"location":"DSAyy/DBMS/#1-introduction-to-dbms_1","title":"1. Introduction to DBMS","text":""},{"location":"DSAyy/DBMS/#what-is-a-dbms","title":"What is a DBMS?","text":"<p>A Database Management System is software that:</p> <ul> <li> <p>Stores large volumes of structured data efficiently on disk.</p> </li> <li> <p>Manages concurrent access by multiple users or applications.</p> </li> <li> <p>Enforces data integrity, security, and recovery from crashes.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#core-components","title":"Core Components","text":"<ol> <li> <p>Storage Manager</p> <ul> <li>Handles data files, buffer management, and I/O.</li> </ul> </li> <li> <p>Query Processor</p> <ul> <li>Parses SQL, optimizes it into an execution plan, and runs it.</li> </ul> </li> <li> <p>Transaction Manager</p> <ul> <li>Ensures ACID properties (covered later).</li> </ul> </li> <li> <p>Metadata Catalog</p> <ul> <li>Keeps schema definitions, statistics, and user privileges.</li> </ul> </li> </ol>"},{"location":"DSAyy/DBMS/#why-use-a-dbms","title":"Why Use a DBMS?","text":"<ul> <li> <p>Abstraction: Hides file\u2010level details (you write SQL, not file reads).</p> </li> <li> <p>Safety: Built\u2010in backup/restore and crash recovery.</p> </li> <li> <p>Concurrency: Multiple clients can read/write safely.</p> </li> <li> <p>Security: Fine\u2010grained user/role privileges on tables, rows, columns.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#common-interview-queries","title":"Common Interview Queries","text":"<ul> <li> <p>\u201cList DBMS advantages over flat files.\u201d</p> </li> <li> <p>\u201cExplain the role of the buffer manager.\u201d</p> </li> <li> <p>\u201cWhat\u2019s in the system catalog?\u201d</p> </li> <li> <p>SQL exercise:</p> <pre><code>-- How to list all tables and their row counts?\nSELECT table_schema, table_name,\n       table_rows \n  FROM information_schema.tables\n WHERE table_type='BASE TABLE';\n</code></pre> </li> </ul>"},{"location":"DSAyy/DBMS/#2-database-architecture_1","title":"2. Database Architecture","text":""},{"location":"DSAyy/DBMS/#ansisparc-threelevel-model","title":"ANSI/SPARC Three\u2011Level Model","text":"<ul> <li> <p>Internal Level</p> <ul> <li>Physical storage details (page layouts, indexing structures).</li> </ul> </li> <li> <p>Conceptual Level</p> <ul> <li>Global logical schema: tables, columns, data types, relationships.</li> </ul> </li> <li> <p>External Level</p> <ul> <li>Multiple user \u201cviews\u201d (e.g., read\u2010only or reduced\u2010column subsets).</li> </ul> </li> </ul>"},{"location":"DSAyy/DBMS/#clientserver-ntier","title":"Client\u2011Server &amp; N\u2011Tier","text":"<ul> <li> <p>Two\u2011Tier: Client directly issues SQL to DB server. Simpler but less scalable.</p> </li> <li> <p>Three\u2011Tier: Client \u2192 Application server \u2192 Database. Better separation of concerns, caching, and load\u2011balancing.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#distributed-cloud-architectures","title":"Distributed &amp; Cloud Architectures","text":"<ul> <li> <p>Sharding: Horizontal partitioning by key (e.g., user_id ranges).</p> </li> <li> <p>Replication: Master\u2013slave or multi\u2011master copies for high availability.</p> </li> <li> <p>Cloud DB Services: Aurora (MySQL\u2011compatible), DynamoDB (NoSQL), BigQuery (analytical).</p> </li> </ul>"},{"location":"DSAyy/DBMS/#common-interview-queries_1","title":"Common Interview Queries","text":"<ul> <li> <p>\u201cDraw and explain the ANSI/SPARC model.\u201d</p> </li> <li> <p>\u201cWhen would you choose two\u2011tier vs. three\u2011tier?\u201d</p> </li> <li> <p>\u201cHow does sharding differ from replication?\u201d</p> </li> <li> <p>SQL exercise:</p> <pre><code>-- Check replication status in MySQL\nSHOW SLAVE STATUS\\G;\n</code></pre> </li> </ul>"},{"location":"DSAyy/DBMS/#3-keys-and-constraints_1","title":"3. Keys and Constraints","text":""},{"location":"DSAyy/DBMS/#types-of-keys","title":"Types of Keys","text":"<ul> <li> <p>Primary Key</p> <ul> <li>Uniquely identifies each row; cannot be NULL.</li> </ul> </li> <li> <p>Candidate Key</p> <ul> <li>Any minimal superkey; one is chosen as the PK.</li> </ul> </li> <li> <p>Foreign Key</p> <ul> <li>References PK in another table; enforces referential integrity.</li> </ul> </li> <li> <p>Composite Key</p> <ul> <li>PK spanning multiple columns (e.g., <code>(order_id, item_id)</code>).</li> </ul> </li> </ul>"},{"location":"DSAyy/DBMS/#constraint-types","title":"Constraint Types","text":"<ul> <li> <p>UNIQUE: No duplicates allowed.</p> </li> <li> <p>NOT NULL: Disallows NULLs.</p> </li> <li> <p>CHECK: Enforces a Boolean expression (e.g., <code>CHECK (age&gt;=18)</code>).</p> </li> <li> <p>DEFAULT: Supplies default value if none given.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#how-constraints-are-enforced","title":"How Constraints Are Enforced","text":"<ul> <li> <p>At INSERT or UPDATE, the DBMS checks each relevant constraint.</p> </li> <li> <p>Violations cause the entire statement to roll back.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#common-interview-queries_2","title":"Common Interview Queries","text":"<ul> <li> <p>\u201cWrite SQL to add a foreign key to an existing table.\u201d</p> </li> <li> <p>\u201cHow do composite keys affect indexing?\u201d</p> </li> <li> <p>\u201cExplain deferred vs. immediate constraint checking.\u201d</p> </li> <li> <p>SQL exercises:</p> <pre><code>-- Add a FK:\nALTER TABLE orders\n  ADD CONSTRAINT fk_user\n  FOREIGN KEY (user_id) REFERENCES users(id)\n    ON DELETE CASCADE;\n\n-- Create a table with composite PK:\nCREATE TABLE order_items (\n  order_id INT,\n  item_id  INT,\n  qty      INT,\n  PRIMARY KEY (order_id, item_id)\n);\n</code></pre> </li> </ul>"},{"location":"DSAyy/DBMS/#4-sql-vs-nosql_1","title":"4. SQL vs. NoSQL","text":"Feature SQL (Relational) NoSQL (Non\u2011relational) Schema Rigid: ALTER TABLE required Flexible: Documents/columns added freely Data Model Rows &amp; columns Document (JSON), Key\u2011Value, Graph, Column Transactions Full ACID BASE: eventual consistency Scaling Vertical (bigger machines) Horizontal (add commodity nodes) Use Cases Financial, inventory systems High\u2011scale web services, caching"},{"location":"DSAyy/DBMS/#key-tradeoffs","title":"Key Trade\u2011offs","text":"<ul> <li> <p>Joins &amp; Complex Queries: SQL excels.</p> </li> <li> <p>Rapid Schema Evolution: NoSQL shines.</p> </li> <li> <p>Strong Consistency: SQL by default.</p> </li> <li> <p>Massive Scale\u2011out: Many NoSQL engines optimize for this.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#common-interview-queries_3","title":"Common Interview Queries","text":"<ul> <li> <p>\u201cWhen would you choose a document store over a relational DB?\u201d</p> </li> <li> <p>\u201cExplain BASE: break down each letter.\u201d</p> </li> <li> <p>\u201cHow does eventual consistency manifest in reads?\u201d</p> </li> <li> <p>Hands\u2011on:</p> <pre><code>-- Relational JOIN example:\nSELECT u.name, o.total\n  FROM users u\n  JOIN orders o ON u.id = o.user_id\n WHERE o.created_at &gt; '2025-01-01';\n\n-- MongoDB equivalent:\ndb.orders.aggregate([\n  { $match: { created_at: { $gt: ISODate(\"2025-01-01\") } } },\n  { $lookup: {\n      from: \"users\",\n      localField: \"user_id\",\n      foreignField: \"_id\",\n      as: \"user\"\n  }},\n  { $unwind: \"$user\" },\n  { $project: { \"user.name\":1, total:1 } }\n]);\n</code></pre> </li> </ul>"},{"location":"DSAyy/DBMS/#5-normalization-and-denormalization_1","title":"5. Normalization and Denormalization","text":""},{"location":"DSAyy/DBMS/#goals-of-normalization","title":"Goals of Normalization","text":"<ul> <li> <p>Eliminate Redundancy: Avoid repeating data.</p> </li> <li> <p>Prevent Anomalies: INSERT, UPDATE, DELETE anomalies.</p> </li> </ul> Normal Form Requirement 1NF Atomic (indivisible) column values; no repeating groups. 2NF 1NF + no partial dependency on a composite PK. 3NF 2NF + no transitive dependency (non\u2011key column depends only on PK). BCNF Every determinant is a candidate key (stronger than 3NF)."},{"location":"DSAyy/DBMS/#when-to-denormalize","title":"When to Denormalize","text":"<ul> <li> <p>Read\u2011Heavy Workloads: Fewer JOINs, faster reads.</p> </li> <li> <p>Reporting / OLAP: Pre\u2011aggregated or flattened tables.</p> </li> <li> <p>Materialized Views: Physically store complex aggregations.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#common-interview-queries_4","title":"Common Interview Queries","text":"<ul> <li> <p>\u201cNormalize this table to 3NF:\u201d</p> OrderID CustomerName Product Qty </li> <li> <p>\u201cWhat are the drawbacks of over\u2011normalizing?\u201d</p> </li> <li> <p>\u201cShow how to denormalize for a reporting table.\u201d</p> </li> <li> <p>SQL exercise:</p> <pre><code>-- Example: create a denormalized summary table\nCREATE TABLE daily_sales AS\nSELECT\n  DATE(order_date) AS sale_date,\n  store_id,\n  SUM(total_amount) AS total_sales,\n  COUNT(*) AS order_count\nFROM orders\nGROUP BY 1,2;\n</code></pre> </li> </ul>"},{"location":"DSAyy/DBMS/#-","title":"---","text":""},{"location":"DSAyy/DBMS/#6-indexing_1","title":"6. Indexing","text":""},{"location":"DSAyy/DBMS/#purpose-of-indexes","title":"Purpose of Indexes","text":"<ul> <li> <p>Speed up SELECTs by allowing the database engine to locate rows without scanning the entire table.</p> </li> <li> <p>Supporting ORDER\u00a0BY and GROUP\u00a0BY operations efficiently when the index matches the sort/group columns.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#types-of-indexes","title":"Types of Indexes","text":"<ol> <li> <p>B\u2011Tree (Balanced Tree)</p> <ul> <li> <p>Default in most RDBMS.</p> </li> <li> <p>Good for range scans (<code>WHERE col BETWEEN a AND b</code>).</p> </li> </ul> </li> <li> <p>Hash Index</p> <ul> <li>Ideal for exact\u2010match lookups (<code>WHERE col = value</code>), but cannot do range queries.</li> </ul> </li> <li> <p>Bitmap Index</p> <ul> <li>Very compact; optimal for low\u2010cardinality columns (e.g., gender or status flags).</li> </ul> </li> <li> <p>Clustered vs. Non\u2011Clustered</p> <ul> <li> <p>Clustered: Physically orders table data. Only one per table.</p> </li> <li> <p>Non\u2011Clustered: Separate structure with pointers back to table rows. Multiple per table.</p> </li> </ul> </li> <li> <p>Composite Index</p> <ul> <li>Index on multiple columns. Order matters: an index on <code>(A,\u00a0B)</code> can be used for queries filtering on <code>A</code> or on both <code>A</code> and <code>B</code>, but not on <code>B</code> alone.</li> </ul> </li> <li> <p>Covering Index</p> <ul> <li>Includes all columns needed by a query so the engine never has to hit the base table.</li> </ul> </li> </ol>"},{"location":"DSAyy/DBMS/#tradeoffs","title":"Trade\u2011Offs","text":"<ul> <li> <p>Pros: Faster reads, can enforce uniqueness.</p> </li> <li> <p>Cons: Slower writes (INSERT/UPDATE/DELETE must maintain indexes), extra storage, fragmentation over time.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#sql-examples","title":"SQL Examples","text":"<pre><code>-- Single\u2011column non\u2011clustered index\nCREATE INDEX idx_orders_created_at\n  ON orders(created_at);\n\n-- Composite covering index\nCREATE INDEX idx_orders_user_date_amt\n  ON orders(user_id, order_date)\n  INCLUDE (total_amount);\n\n-- Drop an index\nDROP INDEX idx_orders_created_at ON orders;\n</code></pre>"},{"location":"DSAyy/DBMS/#common-interview-queries_5","title":"Common Interview Queries","text":"<ul> <li> <p>\u201cExplain the difference between clustered and non\u2011clustered indexes.\u201d</p> </li> <li> <p>\u201cWhen would you use a covering index?\u201d</p> </li> <li> <p>\u201cHow does a composite index work, and why does column order matter?\u201d</p> </li> <li> <p>\u201cWhat\u2019s the impact of too many indexes on a table?\u201d</p> </li> </ul>"},{"location":"DSAyy/DBMS/#7-transactions-acid-properties_1","title":"7. Transactions &amp; ACID Properties","text":""},{"location":"DSAyy/DBMS/#what-is-a-transaction","title":"What Is a Transaction?","text":"<p>A transaction is a logical unit of work comprising one or more SQL statements that must all succeed or all fail as a group.</p>"},{"location":"DSAyy/DBMS/#acid-breakdown","title":"ACID Breakdown","text":"<ol> <li> <p>Atomicity</p> <ul> <li>All operations in a transaction are treated as a single unit: either all succeed or all are rolled back.</li> </ul> </li> <li> <p>Consistency</p> <ul> <li>Transactions move the database from one valid state to another, preserving integrity constraints.</li> </ul> </li> <li> <p>Isolation</p> <ul> <li>Concurrent transactions do not see each other\u2019s intermediate states.</li> </ul> </li> <li> <p>Durability</p> <ul> <li>Once committed, transaction effects persist even if the system crashes.</li> </ul> </li> </ol>"},{"location":"DSAyy/DBMS/#how-rdbms-enforces-acid","title":"How RDBMS Enforces ACID","text":"<ul> <li> <p>Write\u2011Ahead Log (WAL) / Redo &amp; Undo Logs for atomicity &amp; durability.</p> </li> <li> <p>Locking or MVCC for isolation.</p> </li> <li> <p>Integrity checks at commit time for consistency.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#sql-examples_1","title":"SQL Examples","text":"<pre><code>-- Explicit transaction block\nBEGIN TRANSACTION;\n\nUPDATE accounts\n   SET balance = balance - 100\n WHERE id = 101;\n\nUPDATE accounts\n   SET balance = balance + 100\n WHERE id = 202;\n\nCOMMIT;  -- or ROLLBACK on error\n</code></pre>"},{"location":"DSAyy/DBMS/#common-interview-queries_6","title":"Common Interview Queries","text":"<ul> <li> <p>\u201cWhat happens if the server crashes after you COMMIT but before data is flushed to disk?\u201d</p> </li> <li> <p>\u201cHow does PostgreSQL\u2019s MVCC model ensure isolation?\u201d</p> </li> <li> <p>\u201cExplain the difference between logical and physical logging.\u201d</p> </li> <li> <p>\u201cWhy is atomicity important in financial applications?\u201d</p> </li> </ul>"},{"location":"DSAyy/DBMS/#8-concurrency-control-isolation-levels_1","title":"8. Concurrency Control &amp; Isolation Levels","text":""},{"location":"DSAyy/DBMS/#lockbased-vs-mvcc","title":"Lock\u2011Based vs. MVCC","text":"<ul> <li> <p>Lock\u2011Based</p> <ul> <li>Uses shared (S) and exclusive (X) locks to serialize conflicting accesses.</li> </ul> </li> <li> <p>MVCC (Multi\u2011Version Concurrency Control)</p> <ul> <li>Writers create new row versions; readers see a snapshot, avoiding read locks.</li> </ul> </li> </ul>"},{"location":"DSAyy/DBMS/#sql-standard-isolation-levels","title":"SQL Standard Isolation Levels","text":"Level Dirty Reads Non\u2011Repeatable Reads Phantom Reads READ UNCOMMITTED Yes Yes Yes READ COMMITTED No Yes Yes REPEATABLE READ No No Yes SERIALIZABLE No No No"},{"location":"DSAyy/DBMS/#setting-isolation-levels","title":"Setting Isolation Levels","text":"<pre><code>-- PostgreSQL\nSET TRANSACTION ISOLATION LEVEL REPEATABLE READ;\n\n-- MySQL\nSET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;\n</code></pre>"},{"location":"DSAyy/DBMS/#common-interview-queries_7","title":"Common Interview Queries","text":"<ul> <li> <p>\u201cDefine phantom reads and how SERIALIZABLE prevents them.\u201d</p> </li> <li> <p>\u201cWhat\u2019s the difference between optimistic and pessimistic locking?\u201d</p> </li> <li> <p>\u201cHow does snapshot isolation differ from SERIALIZABLE?\u201d</p> </li> <li> <p>\u201cGive an example of a lost\u2011update anomaly and how to avoid it.\u201d</p> </li> </ul>"},{"location":"DSAyy/DBMS/#9-deadlocks-resolution-strategies_1","title":"9. Deadlocks &amp; Resolution Strategies","text":""},{"location":"DSAyy/DBMS/#what-is-a-deadlock","title":"What Is a Deadlock?","text":"<p>A deadlock occurs when two or more transactions are each waiting for locks held by the other, creating a cycle and halting progress.</p>"},{"location":"DSAyy/DBMS/#detection-resolution","title":"Detection &amp; Resolution","text":"<ul> <li> <p>Wait\u2011For Graph: DBMS builds a graph of transactions vs. locks; cycles indicate deadlocks.</p> </li> <li> <p>Victim Selection: One transaction is chosen as the \u201cvictim\u201d and rolled back to break the cycle.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#prevention-techniques","title":"Prevention Techniques","text":"<ul> <li> <p>Lock Ordering: Always acquire locks in a predefined order.</p> </li> <li> <p>Timeouts: Abort transactions that wait too long.</p> </li> <li> <p>No\u2011Wait Policy: Immediately abort if a lock cannot be acquired.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#monitoring-in-mysql-postgresql","title":"Monitoring in MySQL / PostgreSQL","text":"<pre><code>-- MySQL: view InnoDB transactions &amp; locks\nSHOW ENGINE INNODB STATUS\\G;\n\n-- PostgreSQL: list blocked queries\nSELECT blocked_locks.pid AS blocked_pid,\n       blocking_locks.pid AS blocking_pid,\n       blocked_activity.query AS blocked_query,\n       blocking_activity.query AS blocking_query\n  FROM pg_locks blocked_locks\n  JOIN pg_locks blocking_locks\n    ON blocked_locks.locktype = blocking_locks.locktype\n   AND blocked_locks.locktype = blocking_locks.locktype\n   AND blocked_locks.database IS NOT DISTINCT FROM blocking_locks.database\n   AND blocked_locks.relation IS NOT DISTINCT FROM blocking_locks.relation\n   AND blocked_locks.page IS NOT DISTINCT FROM blocking_locks.page\n   AND blocked_locks.tuple IS NOT DISTINCT FROM blocking_locks.tuple\n  JOIN pg_stat_activity blocked_activity\n    ON blocked_activity.pid = blocked_locks.pid\n  JOIN pg_stat_activity blocking_activity\n    ON blocking_activity.pid = blocking_locks.pid\n WHERE NOT blocked_locks.granted\n   AND blocking_locks.granted;\n</code></pre>"},{"location":"DSAyy/DBMS/#common-interview-queries_8","title":"Common Interview Queries","text":"<ul> <li> <p>\u201cHow does your DBMS detect deadlocks?\u201d</p> </li> <li> <p>\u201cExplain the difference between a deadlock and a lock wait timeout.\u201d</p> </li> <li> <p>\u201cDescribe a scenario leading to a phantom deadlock.\u201d</p> </li> <li> <p>\u201cWhat strategies would you implement to minimize deadlocks in a high\u2011throughput system?\u201d</p> </li> </ul>"},{"location":"DSAyy/DBMS/#10-joins-set-operations_1","title":"10. Joins &amp; Set Operations","text":""},{"location":"DSAyy/DBMS/#types-of-joins","title":"Types of Joins","text":"<ul> <li> <p>INNER JOIN: Returns rows where matching keys exist in both tables.</p> </li> <li> <p>LEFT/RIGHT OUTER JOIN: Returns all rows from one side, plus matches from the other.</p> </li> <li> <p>FULL OUTER JOIN: Combines LEFT and RIGHT\u2014keeps all rows from both.</p> </li> <li> <p>CROSS JOIN: Cartesian product of the two tables (rarely used).</p> </li> <li> <p>SELF JOIN: A table joined with itself (often via aliases).</p> </li> </ul>"},{"location":"DSAyy/DBMS/#join-algorithms","title":"Join Algorithms","text":"<ol> <li> <p>Nested Loop Join</p> </li> <li> <p>Hash Join</p> </li> <li> <p>Merge Join</p> </li> </ol>"},{"location":"DSAyy/DBMS/#set-operations","title":"Set Operations","text":"<ul> <li> <p>UNION / UNION ALL: Combine result sets (UNION removes duplicates).</p> </li> <li> <p>INTERSECT: Rows common to both queries.</p> </li> <li> <p>EXCEPT / MINUS: Rows in first query not in second.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#sql-examples_2","title":"SQL Examples","text":"<pre><code>-- INNER JOIN\nSELECT u.name, o.total_amount\n  FROM users u\n  JOIN orders o ON u.id = o.user_id;\n\n-- LEFT OUTER JOIN\nSELECT r.name, m.item_name\n  FROM restaurants r\n  LEFT JOIN menu m ON r.id = m.restaurant_id;\n\n-- UNION vs. UNION ALL\nSELECT city FROM users\nUNION\nSELECT city FROM restaurants;\n\nSELECT city FROM users\nUNION ALL\nSELECT city FROM restaurants;\n\n-- INTERSECT example (PostgreSQL)\nSELECT user_id FROM orders_2024\nINTERSECT\nSELECT user_id FROM orders_2025;\n</code></pre>"},{"location":"DSAyy/DBMS/#common-interview-queries_9","title":"Common Interview Queries","text":"<ul> <li> <p>\u201cWhat\u2019s the difference between INNER JOIN and CROSS JOIN?\u201d</p> </li> <li> <p>\u201cWhen would you choose a hash join over a nested loop?\u201d</p> </li> <li> <p>\u201cExplain how UNION ALL differs from UNION in performance.\u201d</p> </li> <li> <p>\u201cHow do you eliminate duplicate rows after a join?\u201d</p> </li> </ul>"},{"location":"DSAyy/DBMS/#solved-questions","title":"Solved Questions","text":""},{"location":"DSAyy/DBMS/#1-schema-design-complex-query","title":"1. Schema Design &amp; Complex Query","text":"<p>Q: Design a minimal schema to store users, restaurants, orders, and order_items. Then write a SQL query to list the top\u202f5 restaurants by total revenue in the last 30 days, including the revenue amount.</p> <pre><code>-- 1. Schema\nCREATE TABLE users (\n  user_id     BIGINT PRIMARY KEY,\n  name        VARCHAR(100),\n  signup_date DATE\n);\n\nCREATE TABLE restaurants (\n  restaurant_id BIGINT PRIMARY KEY,\n  name          VARCHAR(150),\n  city          VARCHAR(50)\n);\n\nCREATE TABLE orders (\n  order_id       BIGINT PRIMARY KEY,\n  user_id        BIGINT NOT NULL REFERENCES users(user_id),\n  restaurant_id  BIGINT NOT NULL REFERENCES restaurants(restaurant_id),\n  order_date     TIMESTAMP NOT NULL,\n  total_amount   DECIMAL(10,2)\n);\n\nCREATE TABLE order_items (\n  order_id    BIGINT NOT NULL REFERENCES orders(order_id),\n  item_id     BIGINT NOT NULL,\n  quantity    INT,\n  price       DECIMAL(10,2),\n  PRIMARY KEY (order_id, item_id)\n);\n\n-- 2. Top\u20115 restaurants by revenue in last 30 days\nSELECT\n  r.restaurant_id,\n  r.name AS restaurant_name,\n  SUM(o.total_amount) AS revenue\nFROM orders o\nJOIN restaurants r ON o.restaurant_id = r.restaurant_id\nWHERE o.order_date &gt;= NOW() - INTERVAL '30 days'\nGROUP BY r.restaurant_id, r.name\nORDER BY revenue DESC\nLIMIT 5;\n</code></pre> <p>Explanation:</p> <ul> <li> <p>We separate line\u2010items (<code>order_items</code>) from the order header (<code>orders</code>) to allow multiple items per order.</p> </li> <li> <p>We store <code>total_amount</code> on <code>orders</code> to avoid aggregating <code>order_items</code> in every query (denormalization for performance).</p> </li> <li> <p>The query groups by restaurant, sums <code>total_amount</code>, filters by date with an index on <code>order_date</code>, and fetches the top\u202f5.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#2-window-functions-for-top-n-per-group","title":"2. Window Functions for \u201cTop\u202fN per Group\u201d","text":"<p>Q: For each restaurant, find its highest\u2011grossing day (the date with the maximum total order value) over the past quarter.</p> <pre><code>WITH daily_rev AS (\n  SELECT\n    restaurant_id,\n    DATE(order_date) AS day,\n    SUM(total_amount) AS revenue\n  FROM orders\n  WHERE order_date &gt;= NOW() - INTERVAL '3 months'\n  GROUP BY restaurant_id, DATE(order_date)\n),\nranked_rev AS (\n  SELECT\n    restaurant_id,\n    day,\n    revenue,\n    ROW_NUMBER() OVER (\n      PARTITION BY restaurant_id\n      ORDER BY revenue DESC\n    ) AS rn\n  FROM daily_rev\n)\nSELECT\n  r.restaurant_id,\n  r.name            AS restaurant_name,\n  dr.day            AS top_day,\n  dr.revenue\nFROM ranked_rev dr\nJOIN restaurants r ON dr.restaurant_id = r.restaurant_id\nWHERE dr.rn = 1;\n</code></pre> <p>Explanation:</p> <ul> <li> <p>First CTE computes daily revenue per restaurant.</p> </li> <li> <p>Second CTE ranks days per restaurant by revenue using <code>ROW_NUMBER()</code>.</p> </li> <li> <p>Final query picks the top (<code>rn=1</code>) day for each restaurant and joins to get the name.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#3-query-optimization-indexing","title":"3. Query Optimization &amp; Indexing","text":"<p>Q: You notice this query is slow. How would you optimize it?</p> <pre><code>SELECT u.user_id, u.name, COUNT(o.order_id) AS num_orders\nFROM users u\nLEFT JOIN orders o\n  ON u.user_id = o.user_id\n  AND o.order_date &gt;= '2025-07-01'\nGROUP BY u.user_id, u.name\nHAVING COUNT(o.order_id) &gt; 100;\n</code></pre> <ol> <li> <p>Add a composite index on <code>(user_id, order_date)</code> in <code>orders</code> so the join/filter is index\u2011supported:</p> <pre><code>CREATE INDEX idx_orders_user_date\n  ON orders(user_id, order_date);\n</code></pre> </li> <li> <p>Rewrite HAVING as WHERE on a subquery to filter early:</p> <pre><code>SELECT u.user_id, u.name, o.num_orders\nFROM users u\nJOIN (\n  SELECT user_id, COUNT(*) AS num_orders\n  FROM orders\n  WHERE order_date &gt;= '2025-07-01'\n  GROUP BY user_id\n  HAVING COUNT(*) &gt; 100\n) o ON u.user_id = o.user_id;\n</code></pre> </li> <li> <p>Explain Plans: Always check <code>EXPLAIN ANALYZE</code> to confirm index usage and avoid full table scans.</p> </li> </ol> <p>Why:</p> <ul> <li> <p>The composite index supports both the join key and the date filter.</p> </li> <li> <p>Pushing filtering into a subquery reduces the number of rows joined to <code>users</code>.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#4-handling-highvolume-writes-with-partitioning","title":"4. Handling High\u2011Volume Writes with Partitioning","text":"<p>Q: Orders can exceed 10\u202fmillion records per month. How would you partition the <code>orders</code> table to maintain performance?</p> <ul> <li> <p>Range Partitioning by month on <code>order_date</code>:</p> <pre><code>-- PostgreSQL example\nCREATE TABLE orders_y2025m01 PARTITION OF orders\n  FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');\nCREATE TABLE orders_y2025m02 PARTITION OF orders\n  FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');\n-- ... and so on\n</code></pre> </li> <li> <p>Benefits:</p> <ul> <li> <p>Queries on recent data hit only a few partitions.</p> </li> <li> <p>Old partitions can be detached and archived quickly.</p> </li> </ul> </li> <li> <p>Indexing: Create indexes on each partition (or use <code>CREATE INDEX \u2026 ON ONLY orders</code> to propagate).</p> </li> <li> <p>Maintenance: Automate partition creation via a scheduled job.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#5-concurrency-idempotent-status-updates","title":"5. Concurrency &amp; Idempotent Status Updates","text":"<p>Q: Multiple services may update an order\u2019s <code>status</code> concurrently (e.g., \u201cplaced\u201d \u2192 \u201cconfirmed\u201d \u2192 \u201cdelivered\u201d). How do you ensure no status transitions are lost or applied out of order?</p> <ol> <li> <p>Use a check constraint or trigger to enforce valid transitions:</p> <pre><code>ALTER TABLE orders\n  ADD COLUMN status VARCHAR(20) NOT NULL DEFAULT 'placed';\n\nCREATE FUNCTION enforce_status_transition() RETURNS trigger AS $$\nBEGIN\n  IF (OLD.status, NEW.status) NOT IN (\n    ('placed','confirmed'),\n    ('confirmed','out_for_delivery'),\n    ('out_for_delivery','delivered')\n  ) THEN\n    RAISE EXCEPTION 'Invalid status transition: % \u2192 %', OLD.status, NEW.status;\n  END IF;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_status_transition\n  BEFORE UPDATE OF status ON orders\n  FOR EACH ROW EXECUTE FUNCTION enforce_status_transition();\n</code></pre> </li> <li> <p>Optimistic Locking: Add a <code>version</code> column and require <code>WHERE version = :old_version</code> in the <code>UPDATE</code>, incrementing <code>version</code>. If zero rows updated, retry.</p> </li> <li> <p>Idempotency Tokens: For external API calls, use an <code>idempotency_key</code> so retries don\u2019t duplicate transitions.</p> </li> </ol> <p>Why:</p> <ul> <li> <p>DB\u2011level enforcement ensures no invalid or out\u2011of\u2011order transition ever persists.</p> </li> <li> <p>Optimistic locking prevents lost updates without heavy locking overhead.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#6-realtime-analytics-with-materialized-views","title":"6. Real\u2011Time Analytics with Materialized Views","text":"<p>Q: You need to serve a dashboard showing hourly order volume for the last 24\u202fhours, refreshed every minute. How would you build this efficiently?</p> <ol> <li> <p>Create a rolling materialized view that aggregates orders by hour:</p> <pre><code>CREATE MATERIALIZED VIEW hourly_order_stats AS\nSELECT\n  date_trunc('hour', order_date) AS hour,\n  COUNT(*) AS order_count\nFROM orders\nWHERE order_date &gt;= NOW() - INTERVAL '1 day'\nGROUP BY 1;\n</code></pre> </li> <li> <p>Refresh incrementally using <code>CONCURRENTLY</code> and limiting to the newest hour:</p> <pre><code>-- Cron job running every minute:\nREFRESH MATERIALIZED VIEW CONCURRENTLY hourly_order_stats;\n</code></pre> </li> <li> <p>Index the view on <code>hour</code> for fast lookups:</p> <pre><code>CREATE INDEX idx_hourly_stats_hour ON hourly_order_stats(hour);\n</code></pre> </li> <li> <p>Serve Dashboard from this view rather than live-scanning the 10M rows/hour.</p> </li> </ol> <p>Why:</p> <ul> <li> <p>Materialized view avoids repeated full scans.</p> </li> <li> <p><code>CONCURRENTLY</code> allows reads during refresh.</p> </li> <li> <p>Hourly granularity keeps the data small (~24 rows).</p> </li> </ul>"},{"location":"DSAyy/DBMS/#more","title":"More","text":""},{"location":"DSAyy/DBMS/#7-designing-for-high-availability-automatic-failover","title":"7. Designing for High Availability &amp; Automatic Failover","text":"<p>Q: Zomato must stay online even if one database node crashes. Design a replication and failover strategy for the primary orders database.</p> <ol> <li> <p>Asynchronous Master\u2013Slave Replication</p> <pre><code>\u2013 Primary (\u201cmaster\u201d) accepts writes.\n\u2013 Two or more secondaries (\u201cslaves\u201d) replicate the WAL stream.\n\u2013 Slaves are read\u2011only and used for analytics/BI.\n</code></pre> </li> <li> <p>Automated Failover with Replica Promotion</p> <ul> <li> <p>Deploy Patroni (PostgreSQL) or MHA (MySQL) + etcd/ZooKeeper for leader election.</p> </li> <li> <p>Upon master failure:</p> <ol> <li> <p>Health checks detect unresponsive master.</p> </li> <li> <p>Orchestrator promotes the most up\u2011to\u2011date slave.</p> </li> <li> <p>Clients reconnect via a virtual IP or service discovery.</p> </li> </ol> </li> </ul> </li> <li> <p>Configuration Snippet (PostgreSQL + Patroni)</p> <pre><code>scope: orders_db\nnamespace: /service/\nname: master\n\nrestapi:\n  listen: 0.0.0.0:8008\n  connect_address: 10.0.0.1:8008\n\netcd:\n  host: 10.0.0.10:2379\n\nbootstrap:\n  dcs:\n    ttl: 30\n    loop_wait: 10\n    retry_timeout: 10\n    maximum_lag_on_failover: 1048576\n  initdb:\n    - encoding: UTF8\n    - data-checksums\n\npostgresql:\n  listen: 0.0.0.0:5432\n  connect_address: 10.0.0.1:5432\n  data_dir: /var/lib/postgresql/data\n  parameters:\n    wal_level: replica\n    max_wal_senders: 10\n    wal_keep_segments: 64\n</code></pre> </li> <li> <p>Client\u2011Side Configuration</p> <ul> <li> <p>Use a connection pooler (PgBouncer/MySQL Proxy) that automatically routes writes to master and reads to slaves.</p> </li> <li> <p>On failover, update the pooler\u2019s target master via the orchestration layer.</p> </li> </ul> </li> </ol> <p>Why This Works:</p> <ul> <li> <p>Asynchronous replication keeps slaves almost up\u2011to\u2011date with minimal write latency impact.</p> </li> <li> <p>Patroni\u2019s automatic promotion and health checks eliminate manual intervention.</p> </li> <li> <p>Connection pooling abstracts failover logic away from the application.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#8-balancing-consistency-availability-partition-tolerance-cap","title":"8. Balancing Consistency, Availability &amp; Partition Tolerance (CAP)","text":"<p>Q: Zomato\u2019s search service must return restaurant data quickly even if a regional datacenter is unreachable. How do you apply CAP principles when choosing your database and consistency model?</p> <ol> <li> <p>Identify Requirements</p> <ul> <li> <p>Availability (A): Search queries must still work when a DC is down.</p> </li> <li> <p>Partition Tolerance (P): Network splits between regions can happen.</p> </li> <li> <p>Consistency (C): Some stale data is acceptable for search results.</p> </li> </ul> </li> <li> <p>Choose AP\u2011oriented System</p> <ul> <li> <p>Cassandra or DynamoDB with eventual consistency.</p> </li> <li> <p>Configure read/write quorum to tune freshness vs. latency:</p> <ul> <li> <p>Write to W=1 replica (fast writes).</p> </li> <li> <p>Read from R=1 replica (fast reads).</p> </li> <li> <p>W + R &gt; Replication Factor for stronger consistency when needed.</p> </li> </ul> </li> </ul> </li> <li> <p>Consistency Tuning Example (Cassandra CQL)</p> <pre><code>-- Create a keyspace replicated across 3 DCs\nCREATE KEYSPACE zomato_search WITH\n  replication = {\n    'class': 'NetworkTopologyStrategy',\n    'dc1': '3',  -- 3 replicas in primary DC\n    'dc2': '2'   -- 2 replicas in secondary DC\n  };\n\n-- Write with QUORUM consistency\nINSERT INTO restaurant_data (...)\n  USING CONSISTENCY QUORUM\n  VALUES (...);\n\n-- Read with LOCAL_QUORUM for slightly fresher, region\u2011local data\nSELECT * FROM restaurant_data\n  WHERE id = '1234'\n  USING CONSISTENCY LOCAL_QUORUM;\n</code></pre> </li> <li> <p>Why Eventual Consistency Works for Search</p> <ul> <li> <p>Minor staleness (a few seconds) is acceptable for search indexes.</p> </li> <li> <p>High availability and partition tolerance ensure that ANY replica can serve queries.</p> </li> </ul> </li> </ol> <p>Key Takeaway:</p> <ul> <li>Sacrifice strict consistency for availability and partition tolerance in read\u2011heavy, latency\u2011sensitive services like search.</li> </ul>"},{"location":"DSAyy/DBMS/#9-caching-layer-for-hot-data","title":"9. Caching Layer for Hot Data","text":"<p>Q: How would you integrate a cache to accelerate reads of popular restaurant profiles and minimize DB load?</p> <ol> <li> <p>Deploy Redis (in\u2011memory KV store)</p> <ul> <li> <p>TTL of e.g. 5\u202fminutes to keep data reasonably fresh.</p> </li> <li> <p>Cache Aside pattern in the application:</p> <pre><code>function getRestaurant(id):\n  if exists in redis.get(id):\n    return cached value\n  else:\n    data = db.query(\"SELECT * FROM restaurants WHERE id=?\", id)\n    redis.set(id, data, ttl=300)\n    return data\n</code></pre> </li> </ul> </li> <li> <p>Handle Cache Invalidation</p> <ul> <li> <p>Time-based TTL handles most cases.</p> </li> <li> <p>Explicit Invalidation on updates:</p> <pre><code>-- After updating the restaurant row:\nredis.del(restaurant_id)\n</code></pre> </li> </ul> </li> <li> <p>Mitigate Cache Stampede</p> <ul> <li>Use mutex locks or request coalescing so that only one request fetches from the DB on a cache miss.</li> </ul> </li> <li> <p>Monitoring &amp; Metrics</p> <ul> <li> <p>Track cache hit ratio (&gt;\u202f90% ideal).</p> </li> <li> <p>Alert if miss ratio spikes (could indicate TTL too low or invalidation bug).</p> </li> </ul> </li> </ol> <p>Why This Works:</p> <ul> <li> <p>Redis drastically reduces p99 read latency and offloads traffic from the DB cluster.</p> </li> <li> <p>TTL plus explicit invalidation keeps the cache coherent.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#10-using-change-data-capture-cdc-for-analytics-pipelines","title":"10. Using Change Data Capture (CDC) for Analytics Pipelines","text":"<p>Q: Zomato wants a near\u2011real\u2011time analytics pipeline without hitting the primary DB. How do you stream order events into a data warehouse?</p> <ol> <li> <p>Enable CDC on Primary</p> <ul> <li>PostgreSQL with wal2json output plugin or Debezium connector.</li> </ul> </li> <li> <p>Stream to Kafka</p> <ul> <li>Debezium publishes every <code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code> on orders to a Kafka topic (<code>orders.cdc</code>).</li> </ul> </li> <li> <p>Consume and Load</p> <ul> <li>Use Kafka Connect with the JDBC Sink to load into your analytics DB (e.g., BigQuery, Redshift, ClickHouse) in micro\u2011batches.</li> </ul> </li> <li> <p>Schema Evolution</p> <ul> <li>Debezium auto\u2011detects schema changes and can update Kafka schema registry entries.</li> </ul> </li> <li> <p>Minimal Impact on OLTP</p> <ul> <li>CDC reads WAL asynchronously; no extra locks on the primary.</li> </ul> </li> </ol> <p>Architecture Diagram (simplified):</p> <pre><code>Primary DB  \u2500\u2500 WAL stream \u2500\u2500&gt; Debezium \u2500\u2500&gt; Kafka \u2500\u2500&gt; Kafka Connect \u2500\u2500&gt; Data Warehouse\n</code></pre> <p>Why CDC?</p> <ul> <li> <p>Gives near\u2011real\u2011time data in analytics without modifying application writes.</p> </li> <li> <p>Decouples OLTP and OLAP workloads entirely.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#11-designing-a-geodistributed-nearest-restaurant-query","title":"11. Designing a Geo\u2011Distributed \u201cNearest Restaurant\u201d Query","text":"<p>Q: How would you design a schema and indexes to efficiently find the 10 nearest restaurants to a given GPS coordinate in each city?</p> <ol> <li> <p>Store Coordinates</p> <pre><code>ALTER TABLE restaurants\n  ADD COLUMN latitude  DOUBLE PRECISION NOT NULL,\n  ADD COLUMN longitude DOUBLE PRECISION NOT NULL;\n</code></pre> </li> <li> <p>Use a Spatial Index</p> <ul> <li> <p>PostGIS extension on PostgreSQL:</p> <pre><code>-- Add a Geography column\nALTER TABLE restaurants\n  ADD COLUMN geog GEOGRAPHY(Point, 4326);\n\n-- Populate it\nUPDATE restaurants\n  SET geog = ST_SetSRID(ST_MakePoint(longitude, latitude), 4326);\n\n-- Create a GiST index\nCREATE INDEX idx_restaurants_geog\n  ON restaurants USING GIST(geog);\n</code></pre> </li> </ul> </li> <li> <p>Nearest\u2011Neighbor Query</p> <pre><code>SELECT id, name,\n       ST_Distance(geog, ST_SetSRID(ST_MakePoint(:lng, :lat), 4326)) AS dist_m\n  FROM restaurants\n WHERE city = :city\n ORDER BY geog &lt;-&gt; ST_SetSRID(ST_MakePoint(:lng, :lat), 4326)\n LIMIT 10;\n</code></pre> <ul> <li>The <code>&lt;-&gt;</code> operator invokes index\u2011accelerated KNN search on the GiST index.</li> </ul> </li> <li> <p>Sharding by City</p> <ul> <li>If a city has millions of restaurants, maintain separate tables or partitions per city to keep index size manageable.</li> </ul> </li> </ol> <p>Why This Works:</p> <ul> <li> <p>Spatial indexing reduces a full\u2011table scan into an indexed K\u2011NN search.</p> </li> <li> <p>Partitioning/sharding ensures low per\u2011index latency even at global scale.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#12-multimaster-replication-conflict-resolution","title":"12. Multi\u2011Master Replication &amp; Conflict Resolution","text":"<p>Q: Zomato runs writes in multiple datacenters (multi\u2011master). How do you handle write conflicts and ensure data convergence?</p> <ol> <li> <p>Choose a Conflict\u2011Resolution Strategy</p> <ul> <li> <p>Last\u2011Write\u2011Wins (LWW): Compare timestamps; highest \u201clast_modified\u201d wins.</p> </li> <li> <p>Custom Merge Function: E.g., sum quantities, pick max rating, or merge JSON blobs.</p> </li> </ul> </li> <li> <p>Implementation in Cassandra</p> <pre><code>-- Table with a write_time-based LWW\nCREATE TABLE restaurant_stats (\n  restaurant_id UUID,\n  metric        text,\n  value         bigint,\n  PRIMARY KEY (restaurant_id, metric)\n)\n  WITH default_time_to_live = 0\n  AND compaction = { 'class': 'LeveledCompactionStrategy' };\n</code></pre> <ul> <li>Cassandra\u2019s built\u2011in LWW uses CQL <code>WRITETIME(value)</code> to pick latest.</li> </ul> </li> <li> <p>Custom Resolver in DynamoDB</p> <pre><code>// Define an AWS Lambda for DynamoDB Streams\nexports.handler = async (event) =&gt; {\n  for (const record of event.Records) {\n    if (record.eventName === 'MODIFY') {\n      const old = record.dynamodb.OldImage;\n      const neu = record.dynamodb.NewImage;\n      // Example: choose higher order_count\n      const resolved = (neu.order_count.N &gt; old.order_count.N)\n        ? neu.order_count.N\n        : old.order_count.N;\n      // Write back the resolved value if different\n      // ...\n    }\n  }\n};\n</code></pre> </li> <li> <p>Ensure Convergence</p> <ul> <li> <p>Use vector clocks or Lamport timestamps if causal ordering matters.</p> </li> <li> <p>Periodically run a background reconciliation job to detect and merge any divergent rows.</p> </li> </ul> </li> </ol> <p>Why This Works:</p> <ul> <li> <p>LWW is simple and performant when slight overwrites are acceptable.</p> </li> <li> <p>Custom resolvers handle domain\u2011specific merges (e.g., accumulating metrics).</p> </li> <li> <p>Periodic reconciliation guarantees eventual consistency across sites.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#13-zerodowntime-schema-migrations","title":"13. Zero\u2011Downtime Schema Migrations","text":"<p>Q: You need to add a NOT NULL column <code>rating_reviewed</code> to a 1\u202fbillion\u2011row <code>reviews</code> table without blocking reads/writes. Outline a safe migration.</p> <ol> <li> <p>Add Nullable Column</p> <pre><code>ALTER TABLE reviews ADD COLUMN rating_reviewed BOOLEAN;\n</code></pre> </li> <li> <p>Backfill in Batches</p> <pre><code>-- Pseudo\u2011script running in chunks of 1M rows\nUPDATE reviews\n   SET rating_reviewed = TRUE\n WHERE rating_reviewed IS NULL\n   AND id BETWEEN :start AND :end;\n</code></pre> </li> <li> <p>Add NOT NULL Constraint (disable validation)</p> <pre><code>ALTER TABLE reviews\n  ALTER COLUMN rating_reviewed SET NOT NULL\n  NOT VALID;\n</code></pre> </li> <li> <p>Validate Constraint</p> <pre><code>ALTER TABLE reviews VALIDATE CONSTRAINT reviews_rating_reviewed_not_null;\n</code></pre> </li> <li> <p>Cleanup</p> <ul> <li>Drop any temporary flags or triggers used during backfill.</li> </ul> </li> </ol> <p>Why This Works:</p> <ul> <li> <p>Adding nullable column is instantaneous.</p> </li> <li> <p>Batching avoids long\u2011running locks.</p> </li> <li> <p>Deferring validation (<code>NOT VALID</code>) prevents table rewrite.</p> </li> <li> <p>Final validation is fast if backfill is complete.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#14-highvolume-bulk-ingestion-etl","title":"14. High\u2011Volume Bulk Ingestion &amp; ETL","text":"<p>Q: You must load 50\u202fmillion rows of historical order data nightly into the OLAP cluster. Describe an efficient ETL approach.</p> <ol> <li> <p>Staging via Flat Files</p> <ul> <li>Export data from OLTP \u2192 compressed CSV/Parquet on HDFS/S3.</li> </ul> </li> <li> <p>Parallel Loader</p> <ul> <li> <p>Use COPY (Postgres), LOAD DATA INFILE (MySQL), or COPY INTO (Snowflake) with multiple file slices:</p> <pre><code>COPY INTO analytics.orders_history\nFROM @s3://zomato/historical/orders/\nFILE_FORMAT = (TYPE=PARQUET)\nON_ERROR = 'CONTINUE';\n</code></pre> </li> </ul> </li> <li> <p>Partition\u2011Aware Load</p> <ul> <li> <p>Target partitions by date to enable pruning:</p> <pre><code>COPY INTO analytics.orders_y2020m01\n...\n</code></pre> </li> </ul> </li> <li> <p>Incremental Upserts</p> <ul> <li> <p>Use MERGE to insert new and update changed rows:</p> <pre><code>MERGE INTO analytics.orders_history tgt\nUSING staging.orders_updates src\nON tgt.order_id = src.order_id\nWHEN MATCHED THEN UPDATE SET ...\nWHEN NOT MATCHED THEN INSERT (...);\n</code></pre> </li> </ul> </li> <li> <p>Orchestration &amp; Monitoring</p> <ul> <li> <p>Schedule via Airflow with SLA alerts.</p> </li> <li> <p>Verify row counts and checksum hashes post\u2011load.</p> </li> </ul> </li> </ol> <p>Why This Works:</p> <ul> <li> <p>Staging separates ETL from OLTP, preventing load spikes.</p> </li> <li> <p>File\u2011based bulk load is orders of magnitude faster than individual inserts.</p> </li> <li> <p>Partition\u2011aware ingestion speeds downstream queries.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#15-data-archival-purging-strategy","title":"15. Data Archival &amp; Purging Strategy","text":"<p>Q: Zomato must keep only 2\u202fyears of orders online. Design an archival and purge process that\u2019s safe and reversible.</p> <ol> <li> <p>Archive to Cold Storage</p> <pre><code>CREATE TABLE orders_archive PARTITION OF orders\n  FOR VALUES FROM ('2023-01-01') TO ('2024-01-01')\n  WITH (storage_parameters);\n-- Detach and export partition to object storage:\nALTER TABLE orders_archive DETACH PARTITION;\n\\COPY orders_archive TO 's3://zomato/archive/orders_2023.parquet' PARQUET;\n</code></pre> </li> <li> <p>Verify &amp; Delete</p> <ul> <li> <p>Confirm integrity (row counts, checksums) in the archive.</p> </li> <li> <p>Drop the partition from the live cluster:</p> <pre><code>DROP TABLE orders_archive;\n</code></pre> </li> </ul> </li> <li> <p>Reversible Restore</p> <ul> <li> <p>To restore, COPY back from S3 into a new partition and ATTACH:</p> <pre><code>CREATE TABLE orders_archive (...);\n\\COPY orders_archive FROM 's3://zomato/archive/orders_2023.parquet' PARQUET;\nALTER TABLE orders ATTACH PARTITION orders_archive FOR VALUES ...;\n</code></pre> </li> </ul> </li> <li> <p>Automation</p> <ul> <li> <p>Schedule with cron or Airflow:</p> <ul> <li> <p>Monthly job: archive oldest month \u2192 drop.</p> </li> <li> <p>Weekly verification checksums.</p> </li> </ul> </li> </ul> </li> </ol> <p>Why This Works:</p> <ul> <li> <p>Partition\u2011based archive/purge is constant\u2011time per partition.</p> </li> <li> <p>Detached export ensures minimal impact on live workload.</p> </li> <li> <p>Archival in Parquet is both compact and queryable if needed.</p> </li> </ul>"},{"location":"DSAyy/DBMS/#16-querying-json-semistructured-data","title":"16. Querying JSON &amp; Semi\u2011Structured Data","text":"<p>Q: The <code>menu</code> table stores item details in a JSON column <code>specs</code>. Write a query to extract all items where <code>specs.ingredients</code> array contains \u201cchili\u201d.</p> <ol> <li> <p>Assume Table Definition</p> <pre><code>CREATE TABLE menu (\n  item_id   BIGINT PRIMARY KEY,\n  name      VARCHAR(100),\n  specs     JSONB\n);\n</code></pre> </li> <li> <p>Index the JSON Path</p> <pre><code>CREATE INDEX idx_menu_specs_ingredients\n  ON menu USING GIN ((specs -&gt; 'ingredients'));\n</code></pre> </li> <li> <p>Query with JSONB Operators</p> <pre><code>SELECT item_id, name, specs\n  FROM menu\n WHERE specs -&gt; 'ingredients' ? 'chili';\n</code></pre> </li> <li> <p>Extract Nested Values</p> <pre><code>SELECT\n  item_id,\n  specs -&gt;&gt; 'calories' AS calories_per_serving\nFROM menu\nWHERE specs -&gt; 'ingredients' ? 'chili';\n</code></pre> </li> </ol> <p>Why This Works:</p> <ul> <li> <p>GIN index on the array field makes the \u201ccontains\u201d test efficient.</p> </li> <li> <p>JSONB operators (<code>?</code>, <code>-&gt;</code>, <code>-&gt;&gt;</code>) allow direct path queries without full scans.</p> </li> </ul>"},{"location":"DSAyy/Greedy/","title":"Greedy","text":""},{"location":"DSAyy/Greedy/#highest-product-of-three-numbers","title":"Highest Product of Three Numbers","text":"<p>Given an int array, find the highest possible sum from any \\(3\\) elements in the array.</p> <p>A = 1 2 3 4, ans: 24</p> <pre><code>def maxp3(A):\n    max1 = max2 = max3 = float('-inf') #max3\n    min1 = min2 = float('inf') #min2\n    for x in A:\n        if x &gt; max1:\n            max3,max2,max1 = max2,max1,x\n        elif x &gt; max2:\n            max3,max2 = max2,x\n        elif x &gt; max3:\n            max3 = x\n        if x &lt; min1:\n            min2, min1 = min1, x\n        elif x &lt; min2:\n            min2 = x\n    prod1 = max1*max2*max3\n    prod2 = max1*min1*min2\n    return max(prod1, prod2)\n</code></pre>"},{"location":"DSAyy/Greedy/#bulbs","title":"Bulbs","text":"<p>Given \\(array\\) of bulbs. Each bulb has a switch. However due to faulty wiring, pressing a switch toggles all the bulbs to the right.</p> <p>Find min number of switches to turn all on.</p> <p>\\(A = 0 1 0 1\\)</p> <p>Output: \\(4\\)</p>"},{"location":"DSAyy/Greedy/#how","title":"How","text":"<p>Just simulate the effect of toggles.</p> <p>Maintain a \\(flips\\) counter</p> <p>If a bulb appears \\(off\\), it must be toggled \\(on\\).</p> <p>Go left to right.</p> <pre><code>def bulbs(A):\n    flips,ans = 0,0\n    for idx,switch in enumerate(A):\n        #determine state\n        curr = switch if flips % 2 == 0 else 1 - switch \n        if curr == 0:\n            ans += 1\n            flips += 1\n    return ans\n</code></pre>"},{"location":"DSAyy/Greedy/#disjoint-intervals","title":"Disjoint Intervals","text":"<p>Given \\(N\\) intervals, find max number of mutually disjoint intervals that can be selected. Disjoint meaning they dont share any point.</p> <p>Ex: \\(1,4\\) \\(2,3\\) \\(4,6\\) \\(8,9\\) : Output = \\(3\\)</p>"},{"location":"DSAyy/Greedy/#how_1","title":"How","text":"<p>Sort all in ascending order of ending times.</p> <p>Select an interval if its starting time is greater than end of the last one.</p> <pre><code>def disj(A):\n    if not A: return 0\n\n    A.sort(key = lambda x: x[1])\n    count = 0\n    last_end = -1\n    for start,end in A:\n        if start &gt; last_end:\n            count += 1\n            last_end = end\n    return count\n</code></pre>"},{"location":"DSAyy/Greedy/#largest-permutation","title":"Largest Permutation","text":"<p>Given a permutation of 1 to N, and int B, representing max swaps allowed, return the lexicographically largest permutation by performing atmost B swaps.</p> <p>Ex: A =  1 2 3 4, B = 1: Output: 4 2 3 1</p>"},{"location":"DSAyy/Greedy/#how_2","title":"How","text":"<p>To achieve the largest:</p> <ul> <li> <p>For every element \\(i\\) in \\(A\\), if \\(i\\) is not the maximum possible \\((N-i)\\), we find the position of the desired value and swap it with \\(A[i]\\).</p> </li> <li> <p>Maintain a map of positions to values for \\(O(1)\\) lookup.</p> </li> <li> <p>After each swap, decrement \\(B\\).</p> </li> </ul> <pre><code>def solve(A,B):\n    N = len(A)\n    pos = {val: i for i,val in enumerate(A)}\n    i = 0\n    while i &lt; N and B &gt; 0:\n        desired = N-i\n        if A[i] != desired:\n            idx = pos[desired]\n            pos[A[i]] = idx\n            pos[desired] = i\n            A[i],A[idx] = A[idx], A[i]\n            B-= 1\n        i += 1\n    return A\n</code></pre>"},{"location":"DSAyy/Greedy/#meeting-rooms","title":"Meeting Rooms","text":"<p>Given time intervals representing meetings, find minimum rooms required to accommodate all.</p> <p>If a meeting ends at \\(t\\), and another meeting starts at \\(t\\), they can use the same room.</p> <p>Ex: \\(0,30\\) \\(5,10\\) \\(15,20\\) Output: \\(2\\)</p> <pre><code>def meetingRoomsII(A):\n    N = len(A)\n    if N == 0: return 0\n    starts = sorted([interval[0] for interval in A])\n    ends = sorted([interval[1] for interval in A])\n    used = 0\n    maxRooms = 0\n    i = j = 0\n    while i &lt; N:\n        if starts[i] &lt; ends[j]:\n            used += 1\n            maxRooms = max(maxRooms, used)\n            i += 1\n        else:\n            used -= 1\n            j += 1\n    return maxRooms\n</code></pre>"},{"location":"DSAyy/Greedy/#distribute-candy","title":"Distribute Candy","text":"<p>\\(N\\) children in a line, Each has a \\(rating\\). Distribute candies such that</p> <ul> <li> <p>Each child gets atleast one candy.</p> </li> <li> <p>Child with a higher rating than the immediate neighbor must get more candies than that neighbor.</p> </li> </ul> <p>Return the min candies required.</p> <p>Ex: \\(1,2\\) Output \\(3\\)</p>"},{"location":"DSAyy/Greedy/#how_3","title":"How","text":"<p>Perform two passes, </p> <ol> <li> <p>Left to Right: If current rating is higher than the left neigbor, give one more candy than the left neighbor.</p> </li> <li> <p>Right to left: If current rating is higher than the right neighbor, ensure current has more candies.</p> </li> </ol> <p>Sum all these values.</p> <pre><code>def candy(A):\n    n = len(A)\n    if n == 0: return 0\n    candies = [1]*n\n    for i in range(1,n):\n        if A[i] &gt; A[i-1]:\n            candies[i] = candies[i-1] + 1\n    for i in range(n-2, -1 -1):\n        if A[i] &gt; A[i+1]:\n            candies[i] = max(candies[i], candies[i+1] + 1)\n    return sum(candies)\n</code></pre>"},{"location":"DSAyy/Greedy/#seats","title":"Seats","text":"<p>Given a string representing row of seats.</p> <ul> <li> <p>Each seat is either empty <code>.</code> or occupied <code>x</code></p> </li> <li> <p>A group of people is randomly scattered the row(at <code>x</code>).</p> </li> <li> <p>Move the people such that they sit together in adjacent seats, minimizing the number of total jumps.</p> </li> <li> <p>One jump allows a person to move to an adjacent seat.</p> </li> </ul> <p>Return the minimum number of jumps.</p> <p>Ex: \\(....x..xx...x..\\) Output: 5 (\\(6-4 + 12 - 9\\))</p> <p>Make them sit together from 6 to 9.</p>"},{"location":"DSAyy/Greedy/#how_4","title":"How","text":"<p>Store indices of occupied seats in a list \\(p\\).</p> <p>Define transformed list \\(r[i] = p[i] - i\\), which aligns people to a contiguous block.</p> <p>The optimal center for the group is the median \\(r\\).</p> <p>Number of jumps is \\(sum(r[i] - median)\\)</p> <pre><code>def seats(A):\n    MOD = 10000003\n    positions = [i for i,ch in enumerate(A) if ch == 'x']\n    k = len(positions)\n    if k &lt;= 1:\n        return 0 #no jumps\n    #adjust to normalised relative positions\n    r = [positions[i]-i for i in range(k)]\n    m = r[k//2] #median minimizes the difference\n    ans = sum(abs(val - m) for val in r) % MOD\n    return ans\n</code></pre>"},{"location":"DSAyy/Greedy/#assign-mices-to-holes","title":"Assign Mices to Holes","text":"<p>There are N mice and N holes, placed along a straight line. Each mouse and hole is positioned at a coordinate on this line:</p> <ul> <li>A mouse can move one step left or right in one minute.</li> <li>Each hole can hold only one mouse.</li> </ul> <p>The goal is to assign each mouse to a hole such that the time taken for the last mouse to enter a hole is minimized.</p> <p>Ex: Mouse = -4 2 3, Hole: 0 -2 4 Output: 2</p>"},{"location":"DSAyy/Greedy/#how_5","title":"How","text":"<p>Sort both arrays.</p> <p>Pair the smallest unassigned mouse with the smallest unassigned hole, second smallest with second smallest etc.</p> <p>For each pair, compute absolute difference and return the max.</p> <pre><code>def mice(A,B):\n    N = len(A)\n    A.sort()\n    B.sort()\n    return max(abs(A[i] - B[i]) for i in range(n))\n</code></pre>"},{"location":"DSAyy/Greedy/#majority-element","title":"Majority Element","text":"<p>Given an int array, find the majority element. The majority element is the element that appears more than \\(\\lfloor N/2 \\rfloor\\) times.</p> <p>Majority element always exists.</p> <p>Ex: 2 1 2, Output = 2</p> <pre><code>def majorityElement(A):\n    count,candidate = 0,0\n    for x in A:\n        if count == 0:\n            candidate = x\n            count = 1\n        elif x == candidate:\n            count += 1\n        else:\n            count -= 1\n    return candidate\n</code></pre>"},{"location":"DSAyy/Greedy/#gas-station","title":"Gas Station","text":"<p>Given two int arrays A and B of size N. There are N gas stations arranged in a circle:</p> <ul> <li> <p>\\(A[i]\\) amount of gas at station \\(i\\)</p> </li> <li> <p>\\(B[i]\\) cost of gas to travel from station \\(i\\) to station \\((i+1)\\) mod N</p> </li> </ul> <p>Return the minimum index of the gas station from which you can start and complete full circle exactly once, or -1 if no such start exists.</p> <p>A = 1 2</p> <p>B = 2 1</p> <p>Output = 1 (zero based)</p> <pre><code>def canCompleteCircuit(A,B):\n    total_tank, curr_tank = 0,0\n    start = 0\n    n = len(A)\n    for i in range(n):\n        diff = A[i] - B[i]\n        total_tank += diff\n        curr_tank += diff\n        if curr_tank &lt; 0:\n            start = i+1\n            curr_tank = 0\n    return start if total_tank &gt;= 0 else -1\n</code></pre>"},{"location":"DSAyy/LinkedList/","title":"Linked Lists","text":""},{"location":"DSAyy/LinkedList/#reverse-linkedlist","title":"Reverse LinkedList","text":"<p>Reverse a linkedlist in place</p> <ol> <li>Store the curr's next so we can go ahead in next iteration.</li> <li>just assign the next ptr to prev</li> <li>then prev = curr, and curr is that temp value</li> </ol> <pre><code>class ListNode:\n    def __init__(self, val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef reverseLL(head):\n    prev = None\n    curr = head\n    while curr:\n        next_temp = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_temp\n    return prev\n</code></pre>"},{"location":"DSAyy/LinkedList/#intersection-of-linkedlist","title":"Intersection Of LinkedList","text":"<p>Find the node where two linkedlists intersect. <pre><code>class ListNode:\n    def __init__(self, val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef getIntersectNode(headA, headB):\n    if not headA or not headB: return None\n    pA, pB = headA, headB\n    while pA != pB:\n        pA = pA.next if pA else headB\n        pB = pB.next if pB else headA\n    return pA\n</code></pre></p>"},{"location":"DSAyy/LinkedList/#sort-binary-linkedlist","title":"Sort Binary LinkedList","text":"<p>Do it inplace with \\(O(1)\\) extra space. <pre><code>class ListNode:\n    def __init__(self, val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef sortBinaryLL(head):\n    zeroDummy, oneDummy = ListNode(0), ListNode(0)\n    zeroTail, oneTail = zeroDummy, oneDummy\n    curr = head #link 2 chains for one and zero, then link them at the end\n    while curr:\n        if curr.val == 0:\n            zeroTail.next = curr\n            zeroTail = curr\n        else:\n            oneTail.next = curr\n            oneTail = curr\n        curr = curr.next\n    oneTail.next = None #end the list\n    zeroTail.next = oneDummy.next #link 0chain to 1 chain\n    return zeroDummy.next #first was dummy\n</code></pre></p>"},{"location":"DSAyy/LinkedList/#partition-list","title":"Partition List","text":"<p>Given a LL and a value <code>B</code>. Partition it so that all nodes with val less than B come before B, and all nodes with val greater than B come after it. </p> <p>Preserve the relative order homie. <pre><code>class ListNode:\n    def __init__(self, val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef partition(A,B):\n    leDummy, geDummy = ListNode(0), ListNode(0) #dummy pointers\n    leTail,geTail = leDummy, geDummy\n    curr = A\n    while curr:\n        if curr.val &lt; B:\n            leTail.next = curr\n            leTail = curr\n        else:\n            geTail.next = curr\n            geTail = curr\n        curr = curr.next\n    geTail.next = None\n    leTail.next = geDummy.next\n    return leDummy.next\n</code></pre></p>"},{"location":"DSAyy/LinkedList/#insertion-sort-list","title":"Insertion Sort List","text":"<p>Sort a LL with insertion sort.</p> <p>Just insert new node in the sorted portion in the correct order.</p> <pre><code>class ListNode:\n    def __init__(self,val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef insertionSortList(head):\n    if not head or head.next:\n        return head\n    dummy = ListNode(0)\n    dummy.next = jead\n    lastSorted = head\n    curr = head.next\n    while curr:\n        if lastSorted.val &lt;= curr.val:\n            lastSorted = curr\n        else:\n            prev = dummy\n            while prev.next.val &lt;= curr.val:\n                prev = prev.next\n            #re-link the nodes\n            lastSorted.next = curr.next #so we know where to cont from next iteration\n            curr.next = prev.next\n            prev.next = curr\n        curr = lastSorted.next\n    return dummy.next\n</code></pre>"},{"location":"DSAyy/LinkedList/#sort-list-merge-sort-on-linkedlist","title":"Sort List (Merge Sort on LinkedList)","text":"<p>you already know what it is.</p> <pre><code>class ListNode:\n    def __init__(self, val= 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef length(head):\n    count = 0\n    while head:\n        count += 1\n        head = head.next\n    return count\n#split first n nodes, return head of the rest\ndef split(head,n):\n    for _ in range(n-1):\n        if head: head = head.next\n        else: return None\n    if not head:\n        return None\n    second = head.next\n    head.next = None\n    return second\n#merge l1, l2 after tail, return new tail\ndef merge(l1,l2,tail):\n    curr = tail\n    while l1 and l2:\n        if l1.val &lt; l2.val:\n            curr.next = l1\n            l1 = l1.next\n        else:\n            curr.next= l2\n            l2 = l2.next\n        curr = curr.next\n    curr.next = l1 if l1 else l2\n    while curr.next:\n        curr = curr.next\n    return curr\ndef mergeSortLL(head):\n    dummy = ListNode(0)\n    dummy.next = head\n    n = length(head)\n    step = 1\n    while step &lt; n:\n        prev,curr = dummy, dummy.next\n        while curr:\n            left = curr\n            right = split(left,step)\n            curr = split(right,step)\n            prev = merge(left, right, prev)\n        step &lt;&lt;= 1\n    return dummy.next\n</code></pre>"},{"location":"DSAyy/LinkedList/#palindrome-list","title":"Palindrome List","text":"<p>Determine if the LL is a palindrome.</p> <pre><code>class ListNode:\n    def __init__(self,val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef isPalindromeLL(head):\n    if not head and head.next: return 1\n    #find the mid point\n    slow, fast = head, head\n    while fast.next and fast.next.next:\n        slow = fast.next\n        fast = fast.next.next\n    #reverse the second half\n    prev,curr = None, slow.next\n    while curr:\n        nxt = curr.next\n        curr.next = prev\n        prev = curr\n        curr = nxt\n    p1, p2 = head, prev\n    isPal = True\n    while p2:\n        if p1.val != p2.val:\n            isPal = False\n            break\n        p1 = p1.next\n        p2 = p2.next\n    #we can restore it too\n    curr,prev = slow.next = None\n    while curr:\n        nxt = curr.next\n        curr.next = prev\n        prev = curr\n        curr = nxt\n    slow.next =prev\n    return 1 is isPal else 0\n</code></pre>"},{"location":"DSAyy/LinkedList/#remove-duplicates-from-sorted-list-ii","title":"Remove Duplicates from Sorted List II","text":"<p>Delete all nodes that have duplicate numbers, leaving only distinct numbers from LL.</p> <pre><code>class ListNode:\n    def __init__(self,val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef removeDuplicatesII(head):\n    dummy = ListNode(0)\n    dummy.next = head\n    prev,curr = dummy,head\n    while curr:\n        if curr.next and curr.val == curr.next.val:\n            dupVal = curr.val\n            #skip all nodes with this value\n            while curr and curr.val == dupVal:\n                curr = curr.next\n            prev.next = curr\n        else:\n            prev = curr\n            curr = curr.next\n    return dummy.next\n</code></pre>"},{"location":"DSAyy/LinkedList/#merge-two-sorted-lists","title":"Merge Two Sorted Lists","text":"<p>Merge two sorted linked lists, and return the merged sorted list.</p> <pre><code>class ListNode:\n    def __init__(self,val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef merge(A,B):\n    dummy = ListNode(0)\n    tail = dummy\n    while A and B:\n        if A.val &lt; B.val:\n            tail.next = A\n            A= A.next\n        else:\n            tail.next = B\n            B = B.next\n        tail = tail.next\n    tail.next = A if A else B\n    return dummy.next\n</code></pre>"},{"location":"DSAyy/LinkedList/#remove-duplicates-from-sorted-list","title":"Remove Duplicates from Sorted List","text":"<p>Remove all duplicates so that each element appears only once.</p> <pre><code>class ListNode:\n    def __init__(self,val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef removeDuplicates(A):\n    curr = A\n    while curr and curr.next:\n        if curr.val == curr.next.val:\n            curr.next = curr.next.next\n        else:\n            curr = curr.next\n    return A\n</code></pre>"},{"location":"DSAyy/LinkedList/#remove-nth-node-from-list-end","title":"Remove Nth Node from List End","text":"<p>Given a singly LL, remove <code>B</code>th node from the end and return the head of the linked list.</p> <p>If B is greater than the length, remove the first node.</p>"},{"location":"DSAyy/LinkedList/#how","title":"How","text":"<p>Advance first ptr at Bth Node. Then advance both ptr until the first ptr reaches the end. The second ptr would be at the node just before the one we need to delete.</p> <pre><code>class ListNode:\n    def __init__(self,val = 0, nxt = 0):\n        self.val = val\n        self.next=  nxt\ndef removeEnd(head, B):\n    dummy = ListNode()\n    dummy.next = head\n    first,second = dummy, dummy\n    for _ in range(B):\n        if first.next: first = first.next\n        else:\n            return head.next\n    while first.next:\n        first = first.next\n        second = second.next\n    second.next = second.next.next\n    return dummy.next\n</code></pre>"},{"location":"DSAyy/LinkedList/#k-reverse-linked-list","title":"K-Reverse Linked List","text":"<p>Given a singly linked list, and an int K, reverse the nodes of the list, K at a time, and return the modified list.</p> <p>Note: the length is divisible by K.</p> <pre><code>class ListNode:\n    def __init__(self, val = 0, nxt =None):\n        self.val = val\n        self.next = nxt\ndef reverseKGroup(head, K):\n    if not head and K &lt;= 1:\n        return head\n    dummy = ListNode()\n    dummy.next = head\n    prevGroup = dummy\n    while True:\n        #find the Kth node\n        kth = prevGroup\n        for _ in range(K):\n            kth = kth.next\n            if not kth:\n                return dummy.next\n        groupStart = prevGroup.next\n        nextGroup = kth.next\n        #rev the group\n        prev, curr = nextGroup, groupStart\n        while curr != nextGroup:\n            tmp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = tmp\n        #connect the prev group\n        prevGroup.next = kth\n        prevGroup = groupStart\n    return dummy.next\n</code></pre>"},{"location":"DSAyy/LinkedList/#even-reverse","title":"Even Reverse","text":"<p>Given a LL, reverse the order of all nodes at even position.</p> <p>Before: 1 -&gt; 2 -&gt; 3 -&gt; 4 Output: 1 -&gt; 4 -&gt; 3 -&gt; 2</p> <ol> <li>Extract even pos nodes into a separate list.</li> <li>Reverse this even list</li> <li>Merge the reverse even list into the orignal list.</li> </ol> <pre><code>class ListNode:\n    def __init__(self, val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef evenReverse(head):\n    if not head or not head.next:\n        return head\n    odd, even = head, head.next\n    evenHead = even\n    while even and even.next: #extracting even list\n        odd.next = even.next\n        odd = odd.next\n        even.next = odd.next\n        even = even.next\n    #rev the even list\n    prev, curr = None, evenHead\n    while curr:\n        nxt = curr.next\n        curr.next = prev\n        prev = curr\n        curr = nxt\n    revEven = prev\n    #merge back even nodes\n    odd,even = head,revEven\n    while even:\n        tmp = odd.next\n        odd.next= even\n        even = even.next\n        odd.next.next = tmp\n        odd = tmp\n</code></pre>"},{"location":"DSAyy/LinkedList/#swap-list-nodes-in-pair","title":"Swap List Nodes in Pair","text":"<p>Given a LL A, swap every two adjacent nodes and return its head.</p> <pre><code>class ListNode:\n    def __init__(self, val = 0, nxt =  None):\n        self.val = val\n        self.next = nxt\ndef swapPair(head):\n    dummy = ListNode()\n    dummy.next = head\n    prev = dummy\n    while prev.next and prev.next.next:\n        first = prev.next\n        second = first.next\n        #swap pair\n        first.next = second.next\n        second.next = first\n        prev.next = second\n        #move prev two steps ahead\n        prev = first\n    return dummy.next\n</code></pre>"},{"location":"DSAyy/LinkedList/#rotate-list","title":"Rotate List","text":"<p>Given a linked list, rotate it by k places.</p> <p>Just connect the linked list in a cycle. Then break at the right spot.</p> <p>Find the length, then move to the new tail (\\(n-B\\) th node)</p> <pre><code>class ListNode:\n    def __init__(self, val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef rotateLL(head, k):\n    if not head or not head.next or k == 0:\n        return head\n    #find len and tail\n    length = 1\n    tail = head\n    while tail.next:\n        tail = tail.next\n        length += 1\n    #normalize k\n    k = k % length\n    tail.next  = head #make it circular\n    #find new tail (len - k)th node\n    newTail = head\n    for _ in range(length - k - 1):\n        newTail = newTail.next\n    newHead = newTail.next #break at the len-k - 1th node\n    newTail.next = None\n    return newHead# len - kth node is the new head\n</code></pre>"},{"location":"DSAyy/LinkedList/#kth-node-from-the-middle","title":"Kth node from the middle","text":"<p>Given a LL, find the value of kth node from the middle towards the head of the linkedlist.</p> <p>If no such node exists, return -1</p>"},{"location":"DSAyy/LinkedList/#how_1","title":"How","text":"<p>Find length, find the middle. To get the Bth node from middle, move B steps backwards from middle.</p> <pre><code>class ListNode:\n    def __init__(self, val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef kFromMid(head, k):\n    N = 0 #find len to get the mid\n    p = head\n    while p:\n        N += 1\n        p = p.next\n    #find mid\n    mid = N//2 + 1\n    target = mid - B\n    if target &lt; 1: return -1\n    # go to the target\n    p = head\n    for i in range(1, target):\n        p = p.next\n    return p\n</code></pre>"},{"location":"DSAyy/LinkedList/#reverse-alternate-k-nodes","title":"Reverse Alternate K nodes","text":"<p>Given a singly LL, reverse every alternate B nodes in the list.</p> <p>3-&gt;4-&gt;7-&gt;8-&gt;10-&gt;12, output: 4-&gt;3-&gt;7-&gt;8-&gt;12-&gt;10</p>"},{"location":"DSAyy/LinkedList/#how_2","title":"How","text":"<ol> <li>reverse first <code>B</code> nodes.</li> <li>skip the next <code>B</code> nodes.</li> <li>Continue reversing and skipping</li> </ol> <pre><code>class ListNode:\n    def __init__(self,val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef revAltK(head,k):\n    if not head or k &lt;= 1: return head\n    dummy = ListNode()\n    dummy.next = head\n    prevGroup = dummy\n    curr = head\n    doReverse = True\n    while curr:\n        #check if there are B nodes ahead\n        node = curr\n        count = 0\n        while node and count &lt; k:\n            node = node.next\n            count += 1\n        if count &lt; B: break\n        if doReverse:\n            prev,p = node, curr\n            for _ in range(k):\n                nxt = p.next\n                p.next = prev\n                prev = p\n                p = nxt\n            prevGroup.next = prev\n            prevGroup = curr\n            curr = node\n        else:\n            for _ in range(k):\n                prevGroup = curr\n                curr = curr.next\n        doReverse = not doReverse\n    return dummy.next\n</code></pre>"},{"location":"DSAyy/LinkedList/#reverse-linkedlist-ii","title":"Reverse LinkedList II","text":"<p>Given singly LL, reverse nodes from pos <code>m</code> to <code>n</code> in one pass and in-place.</p>"},{"location":"DSAyy/LinkedList/#how_3","title":"How","text":"<ol> <li>Traverse to the node just before m (call it <code>prev</code>)</li> <li>Reverse the next \\((n - m + 1)\\) nodes.</li> <li>Carefully reconnect: before m, reversed seg, after n</li> </ol> <pre><code>class ListNode:\n    def __init__(self, val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef revII(head, m, n):\n    if not head or m == n: return head\n    dummy = new ListNode()\n    dummy.next = head\n    prev = dummy\n    for _ in range(1,m): #move to node just before m\n        prev = prev.next\n    reverse_start = prev.next\n    curr = reverse_start.next\n    #reverse nodes [m,n]\n    for _ in range(n - m):\n        reverse_start.next = curr.next\n        curr.next = prev.next\n        prev.next = curr\n        curr = reverse_start.next\n    return dummy.next\n</code></pre>"},{"location":"DSAyy/LinkedList/#reorder-list","title":"Reorder List","text":"<p>Given a singly LL, re order it to $$ L_0 L_nL_1L_{n-1} ... L_xL_{n-x} $$ 1 -&gt;2 -&gt; 3 -&gt; 4, output is 1-&gt;4-&gt;2-&gt;3</p>"},{"location":"DSAyy/LinkedList/#how_4","title":"How","text":"<ol> <li>Reverse the second half.</li> <li>Zip first and reversed second half</li> </ol> <pre><code>class ListNode:\n    def __init__(self, val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef reorder(head):\n    if not head or not head.next: return head\n    #find the middle\n    slow, fast = head, head\n    while fast.next and fast.next.next:\n        slow = slow.next\n        fast = fast.next.next\n    #rev the second half\n    prev,curr = None, slow.next\n    while curr:\n        nxt = curr.next\n        curr.next = prev\n        prev = curr\n        curr = nxt\n    slow.next = None\n    #merge the two halves\n    p1,p2 = head, prev\n    while p2:\n        n1,n2 = p1.next, p2.next\n        p1.next = p2\n        p2.next = n1\n        p1,p2 = n1,n2\n    return head\n</code></pre>"},{"location":"DSAyy/LinkedList/#add-two-numbers-as-lists","title":"Add two numbers as Lists","text":"<p>Given two non-neg numbers as linkedlists, add them. Each list stores digits in reverse order.</p>"},{"location":"DSAyy/LinkedList/#how_5","title":"How","text":"<ol> <li>Trav both digit by digit</li> <li>maintain the carry</li> </ol> <pre><code>class ListNode:\n    def __init__(self,val = 0, nxt = None):\n        self.val = val\n        self.next = nxt\ndef addLL(A,B):\n    carry = 0\n    dummy = ListNode()\n    dummy.next = head\n    tail = dummy\n    while A or B or carry:\n        sum = carry\n        if A:\n            sum += A.val\n            A = A.next\n        if B:\n            sum += B.val\n            B = B.next\n        carry = sum//10\n        tail.next = ListNode(sum % 10)\n        tail = tail.next\n    return dummy.next\n</code></pre>"},{"location":"DSAyy/LinkedList/#list-cycle","title":"List Cycle","text":"<p>Given a LL, return the node where the cycle begins. If there is no cycle, return null.</p>"},{"location":"DSAyy/LinkedList/#how_6","title":"How","text":"<p>Tortoise Hare. 1. To find cycle's entry point, move one pointer to head, and advance both pointers one at a time, the node where they meet is the cycle's start.</p> <pre><code>class ListNode:\n    def __init__(self, val = 0, nxt =None):\n        self.val = val\n        self.next = None\ndef cycle(head):\n    if not head: return None\n    slow,fast = head,head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            #cycle mil gaya\n            ptr = head\n            while ptr != slow:\n                ptr = ptr.next\n                slow = slow.next\n            return ptr\n    return None\n</code></pre>"},{"location":"DSAyy/Maths/","title":"Maths","text":""},{"location":"DSAyy/Maths/#verify-prime","title":"Verify Prime","text":"<p>Given a number, find whether it is prime. <pre><code>def is_prime(N):\n    if n &lt; 2:\n        return False\n    if n in (2,3):\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5)+ 1, 2):\n        if n % i == 0:\n            return False\n    return True\n</code></pre></p>"},{"location":"DSAyy/Maths/#prime-numbers-linear-sieve","title":"Prime Numbers (Linear Sieve)","text":"<p>Given an int A, return all prime numbers \\(\\leq\\) A. Sorted in increasing order.</p> <pre><code>def primes_upto(A):\n    if A&lt; 2:\n        return []\n    sieve = [True]*(A+1)\n    sieve[0], sieve[1] = False, False\n    for i in range(2,int(A**0.5)+1):\n        if sieve[i]:\n            for j in range(i*i, A+1, i):\n                sieve[j] = False\n    return [i for i, is_prime in enumerate(sieve) if is_prime]\n</code></pre>"},{"location":"DSAyy/Maths/#prime-representation","title":"Prime Representation","text":"<p>Given a non-neg int N, find its binary representation as a string. <pre><code>def find_digits_in_binary(N):\n    if N == 0:\n        return \"0\"\n    bin_str = \"\"\n    while N &gt; 0:\n        bin_str += str(N &amp; 1)\n        N &gt;&gt;= 1\n    return bin_str[::-1]\n</code></pre></p>"},{"location":"DSAyy/Maths/#all-factors","title":"All Factors","text":"<p>Given an int A, find and return all its positive factors (divisors).</p>"},{"location":"DSAyy/Maths/#how","title":"How","text":"<p>Every factor \\(d\\) has to be \\(\\leq\\) \\(\\sqrt{A}\\) pairs with another factor \\(\\frac{A}{d}\\) <pre><code>def all_factors(A):\n    small = []\n    large = []\n    i = 1\n    for i*i &lt;= A:\n        if A % i == 0:\n            small.append(i)\n            if i != A//i:\n                large.append(A//i)\n    return small + large[::-1]\n</code></pre></p>"},{"location":"DSAyy/Maths/#adhoc","title":"Adhoc","text":"<p>Given the pos (A,B) of a bishop on a standard \\(8 \\times 8\\) chess board, count the total number of squares the bishop can move to in one move.</p> <p>Ex: A = 4, B = 4, Total = 13</p> <p>$$ Total = NE + NW + SE + SW $$ <pre><code>def bishopMoves(A,B):\n    n = 8\n    nw = min(A-1,B-1)\n    ne = min(A-1, n-B)\n    sw = min(n-A, B-1)\n    se = min(n-A,n-B)\n    return nw + ne + sw + se\n</code></pre></p>"},{"location":"DSAyy/Maths/#distribute-in-circle","title":"Distribute in Circle","text":"<p>Given \\(A\\) items to be delivered in circle of size \\(B\\), starting at position \\(C\\). Find the position where the \\(A\\)th item will be delivered. Items are delivered to adjacent positions.</p> <p>$$ \\text{Position = } (C+A - 1) mod \\space B $$ <pre><code>def distToCircle(A,B,C):\n    pos = (C + A - 1) % B\n    return B if pos == 0 else pos\n</code></pre></p>"},{"location":"DSAyy/Maths/#prime-sum","title":"Prime Sum","text":"<p>Given an even number \\(A &gt; 2\\), return two prime numbers whose sum equals \\(A\\). Return the lexicographically smallest pair \\([a,b]\\)</p>"},{"location":"DSAyy/Maths/#how_1","title":"How","text":"<p>This is based on Goldbach's Conjecture which states that every even integer \\(&gt; 2\\) can be expressed as sum of two prime numbers.</p> <p>Approach:</p> <ul> <li> <p>Generate all primes up to A using linear sieve.</p> </li> <li> <p>For each \\(a\\) from \\(2\\) to \\(A/2\\):</p> <ul> <li>If both \\(a\\) and \\(A-a\\) are primes, return \\([a,A-a]\\)</li> </ul> </li> </ul> <pre><code>def primeSum(A):\n    is_prime = [True]*(A+1)\n    is_prime[0] = is_prime[1] = False\n    for i in range(2,int(A**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, A+1, i):\n                is_prime[j] = False\n    for a in range(2, A//2):\n        if is_prime[a] and is_prime[A-a]:\n            return [a,A-a]\n    return []\n</code></pre>"},{"location":"DSAyy/Maths/#sum-of-pairwise-hamming-distance","title":"Sum of Pairwise Hamming Distance","text":"<p>Given an array of int, compute the sum of hamming distance of all ordered pairs in A.</p> <p>Hamming Distance: The hamming distance between two integers is the number of positions at which their binary representations differ. (basically popcount of xor)</p>"},{"location":"DSAyy/Maths/#how_2","title":"How","text":"<p>For each position b (from 0 to 30), count how many number have 1 at that position. \\(zeroes_b = N - ones_b\\) , then we just have to find how many 1's at that bit, we can pair with 0's since that creates a hamming distance of 1.</p> <p>Since (i,j) and (j,i) both count, we have to count duplicates.</p> <p>So  $$ \\text{Contribution} = 2 \\times ones_b \\times zeroes_b $$ Sum this over all bits, to get the answer.</p> <pre><code>def hamming_distance(A):\n    MOD = 10**9 + 7\n    N = len(A)\n    cnt = [0]*31 #counts of 1s in each bit position\n    for x in A:\n        for b in range(31):\n            if x &amp; (1 &lt;&lt; b):\n                cnt[b] += 1\n    ans = 0\n    for b in range(31):\n        ones = cnt[b]\n        zeroes = N - ones\n        contrib = (ones*zeroes) % MOD\n        contrib = (contrib*2) %MOD\n        ans = (ans + contrib) % MOD\n    return ans\n</code></pre>"},{"location":"DSAyy/Maths/#step-by-step","title":"Step by Step","text":"<p>Given a target position \\(A\\) on a infinite number line, starting at position \\(0\\), you can move in the \\(i\\)-th move by exactly \\(i\\) steps (either forward or backward). What is the minimum number of moves required to reach the target?</p>"},{"location":"DSAyy/Maths/#how_3","title":"How","text":"<p>Crazy baat: after k moves, sum of steps = \\(\\frac{k(k+1)}{2}\\) . So if sum = A, we can reach just by going forward. </p> <p>If \\(S &gt; A\\), then difference \\(S- A\\) can be compensated by reversing the directions of some steps. But you can only make \\(S-A\\) even since flipping the direction of a move changes the total by \\(2 \\times\\) (that move's length).</p> <p>So we need the smallest \\(k\\) such that: $$ S = \\frac{k(k+1)}{2} \\geq |A| \\text{ and } S - |A| \\text{ is even} $$</p> <p>So lets solve for k: $$ \\frac{k(k+1)}{2} \\geq \\text{target} \\equiv k^2 + k - 2\\times target \\geq 0 $$</p> <p>Using the quadratic formula: $$ k = \\lceil{ \\frac{-1 + \\sqrt{1 + 8 \\times target}}{2} }\\rceil $$</p> <pre><code>import math\ndef solve(A):\n    target = abs(A)\n    #minimal k such that k*(k+1)//2 &gt;= target\n    k = math.ceil((-1.0 + math.sqrt(1.0 + 8.0 * target)) / 2.0)\n    S = k*(k+1)//2\n    if (S - target) % 2 == 0:\n        return k\n    elif ((S+k+ 1 - target) % 2 == 0):\n        return k+1\n    else:\n        return k+2\n</code></pre>"},{"location":"DSAyy/Maths/#is-power","title":"Is Power?","text":"<p>Given an int A \\(&gt;\\) 0, can \\(A\\) be written as \\(a^p\\) for some integers \\(a \\geq 2\\) , \\(p \\geq 2\\) ?</p> <p>We just have to check if its a perfect power.</p> <pre><code>import math\ndef is_power(A):\n    if A == 1:\n        return 1\n    for p in range(2, int(math.log2(A)) + 1):\n        a = round(A ** (1/p))\n        if a &gt;= 2 and a**p == A:\n            return 1\n    return 0\n</code></pre>"},{"location":"DSAyy/Maths/#excel-column-number","title":"Excel Column Number","text":"<p>Given a string A representing a column title. Return its corresponding column number.</p> <p>Ex: <code>AB</code> output: 28</p> <p>For a string \\(A = a_1a_2...a_k\\) : $$ \\text{Value} = \\sum_{i = 1}^k (\\text{value of } a_i)\\times 26^{k-i} $$ Where value of \\(a_i\\) \\(= ascii[a_i] - ascii['A'] + 1\\)</p> <pre><code>def titleToNumber(A):\n    result = 0\n    for char in A:\n        digit = ord(char) - ord('A') + 1\n        result = result*26 + digit\n    return result\n</code></pre>"},{"location":"DSAyy/Maths/#excel-column-title","title":"Excel Column Title","text":"<p>Given a positive int \\(A\\), return its corresponding Excel Column Title.</p> \\[ \\text{current letter } = chr('A' + (A-1) \\space mod \\space 26) \\] \\[ A = \\lfloor \\frac{A-1}{26} \\rfloor \\] <pre><code>def convToTitle(A):\n    s = \"\"\n    while A &gt; 0:\n        A -= 1 #zero based\n        r = A % 26\n        s += chr(ord('A') + r)\n        A //= 26\n    return s[::-1]\n</code></pre>"},{"location":"DSAyy/Maths/#digit-ops","title":"Digit Ops","text":"<p>Determine whether an int A is a palindrome.</p> <pre><code>def is_palindrome_num(A):\n    if A &lt; 0 or (A%10 == 0 and A != 0):\n        return False\n    rev = 0\n    n = A\n    while n &gt; rev:\n        rev = rev*10 + n%10\n        n //= 10\n    return n == rev or n == rev//10\n</code></pre>"},{"location":"DSAyy/Maths/#next-smallest-palindrome","title":"Next Smallest Palindrome","text":"<p>Given a numeric string \\(A\\) (no leading zeroes). Find the smallest palindrome \\(&gt; A\\).</p> <p>Crazy Shit: If \\(A\\) only has \\(9\\)s, the answer is always \\(100..001\\). For \\(n\\) digits: \\(1\\) followed by \\(n-1\\) zeroes then \\(1\\). </p> <p>For other cases, we can try to mirror the left half into right half to form a palindrome.</p> <p>If that is not big enough, increment the middle, handle the carries, then mirror again.</p> <pre><code>def next_palindrome(A):\n    A = str(A)\n    n = len(A)\n    if A == '9'*n:\n        return '1' + '0'*(n-1) + '1'\n    #mirror left to right\n    def mirror(s):\n        half = s[:(n//2)]\n        if n%2 == 0:\n            return half + half[::-1]\n        else:\n            return half + s[n//2] + half[::-1]\n    mirrored = mirror(A)\n    if mirrored &gt; A:\n        return mirrored\n    #incr middle and mirror again\n    t = list(A)\n    mid = n//2\n    carry = 1\n    if n % 2 == 1:\n        i = mid\n        t[i] = str((int(t[i]) + carry) % 10)\n        carry = (int(A[i]) + 1) // 10\n        left = i-1\n        right = i+1\n    else:\n        left = mid - 1\n        right = mid\n    while left &gt;= 0 and carry:\n        num = int(t[left]) + carry\n        t[left] = str(num % 10)\n        carry = num // 10\n        t -= 1\n    #mirror again\n    for i in range(n//2):\n        t[-(i+1)] = t[i]\n    return ''.join(t)\n</code></pre>"},{"location":"DSAyy/Maths/#number-theory","title":"Number Theory","text":""},{"location":"DSAyy/Maths/#greatest-common-divisor-gcd","title":"Greatest Common Divisor (GCD)","text":"<p>Given two non-neg int \\(A\\) and \\(B\\), find their \\(GCD\\). Don't use library functions.</p> <p>Simple recurrence for this. $$ gcd(A,B) = gcd(B, A \\space mod \\space B) $$ <pre><code>def __gcd(a,b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n</code></pre></p>"},{"location":"DSAyy/Maths/#find-nth-fibonacci-number-mod","title":"Find N'th Fibonacci Number (mod)","text":"<p>Given int A, find the Ath fibonacci number mod \\(10^9 + 7\\)</p>"},{"location":"DSAyy/Maths/#how_4","title":"How","text":"<p>We can be a noob and use \\(F_n = F_{n-1} + F_{n-2}\\), but we can use something way more big dick energy.</p> <p>Mathematical Trick : Fast Doubling/ Matrix Exponentiation. We can compute this shit in \\(log(n)\\) using: $$ F_{2k} = F_k \\times [2F_{k+1} - F_k] $$ $$ F_{2k + 1} = F_k^2 + F_{k+1}^2 $$ <pre><code>def fib_pair(n):\n    if n == 0:\n        return (0,1)\n    (a,b) = fib_pair(n//2)\n    c = a*(2*b - a) % MOD\n    d = (a*a + b*b) % MOD\n    if n % 2 == 0:\n        return (c,d)\n    else:\n        return (d, (c+d)% MOD)\ndef nthFib(A):\n    return fib_pair(A)[0]\n</code></pre></p>"},{"location":"DSAyy/Maths/#divisible-by-60","title":"Divisible by 60","text":"<p>Given a large number represented in array of digits, determine if we can rearrange it to form a number divisible by 60.</p>"},{"location":"DSAyy/Maths/#how_5","title":"How","text":"<p>To be divisible by 60, it needs to be divisible by 5, 4 and 3.</p> <p>Divisible by 5: Last digit must be 5 or 0</p> <p>Divisible by 4: Last two digits form a number divisible by 4.</p> <p>Divisible by 3: Sum of digits must be divisible by 3.</p> <p>How to check for an arrangement?</p> <ul> <li> <p>There must be atleast one 0 digit (to end with 0)</p> </li> <li> <p>There must be atleast one more even digit, so that the last two digits can be even digit 0.</p> </li> <li> <p>Sum of digits must be divisible by 3.</p> </li> </ul> <pre><code>def divisibleBy60(A):\n    if len(A) == 1:\n        return 1 if A[0] == 0 else 0\n    sum_digits = 0\n    zero_count = 0\n    even_count = 0\n    for d in A:\n        sum_digits += d\n        if d == 0: zero_count += 1\n        if d % 2 == 0: even_count += 1\n    if sum_digits % 3 == 0 and zero_count &gt;= 1 and even_count &gt;= 2:\n        return 1\n    else:\n        return 0\n</code></pre>"},{"location":"DSAyy/Maths/#powerful-divisors","title":"Powerful Divisors","text":"<p>Given an array of integers, for each X in A, find the count of Y such that \\(1 \\leq Y \\leq X\\) and number of divisors of Y is a power of 2.</p> <p>Return an array with answer for every X in A.</p>"},{"location":"DSAyy/Maths/#how_6","title":"How","text":"<ul> <li> <p>Let \\(d(Y)\\) be the num of positive divisors of Y.</p> </li> <li> <p>A number is a power of 2 if it can be written as \\(2^k\\) for some k \\(\\geq\\) 0</p> </li> </ul> <p>For each X in A, count the Y's in \\([1,X]\\) such that \\(d(Y)\\) is a power of 2.</p> <p>Now to compute d(Y), we can use a modified sieve to compute \\(d(y)\\) for all \\(y\\) \\(\\leq A_{max}\\) </p> <p>Step 2: Precompute prefix counts of good numbers.</p> <p>Let \\(P(x)\\) be the count of numbers in \\([1,x]\\) with \\(d(y)\\) a power of 2.</p> <p>So for each \\(X\\) in \\(A\\), our answer is \\(P(X)\\).</p> <p>To check if a number is a power of \\(2\\), \\(n &gt; 0\\) and \\(n \\&amp; (n-1) == 0\\).</p> <pre><code>from math import isqrt\ndef powerfulDivisors(A):\n    N = len(A)\n    if N == 0: return []\n    M = max(A) #precompute till this\n    divs = [0]*(M+1) #div count sieve\n    for i in range(1,M+1):\n        for j in range(i, M+1, i):\n            divs[j] += 1\n    def is_power_of_two(x):\n        return x &gt; 0 and (x &amp;(x-1)) == 0\n    pref = [0]*(M+1) #pref sum of good numbers\n    for i in range(1,M+1):\n        pref[i] = pref[i-1]+ (1 if is_power_of_two(divs[i]) else 0)\n    return [pref[x] for x in A]\n</code></pre>"},{"location":"DSAyy/Maths/#trailing-zeroes-in-factorial","title":"Trailing Zeroes in Factorial","text":"<p>Given an int, return the number of trailing zeroes in A!.</p>"},{"location":"DSAyy/Maths/#how_7","title":"How","text":"<p>We need to count the 5 \\(\\times\\) 2 s. The count of 2 is always gonna be more than the count of 5s. So just check:</p> <p>Just check how many times 5 divides A factorial.  $$ \\lfloor \\frac{A}{5} \\rfloor + \\lfloor \\frac{A}{25} \\rfloor ... $$</p> <p>So the Trailing Zeroes in A! \\(= \\sum_{k = 1}^{\\infty}\\lfloor \\frac{A}{5^k} \\rfloor\\) </p> <pre><code>def trailingZeroes(int A):\n    count = 0\n    p = 5\n    while p &lt;= A:\n        count += A//p\n        p *= 5\n    return count\n</code></pre>"},{"location":"DSAyy/Maths/#sorted-permutation-rank","title":"Sorted Permutation Rank","text":"<p>Given a string \\(A\\) with no repeated chars, return the rank of \\(A\\) among all its lexicographically sorted permutations. Return the ans modulo \\(1000003\\).</p>"},{"location":"DSAyy/Maths/#how_8","title":"How","text":"<p>For each char in string from left to right, cound how many unused chars are smaller than the current one.</p> <p>For each such smaller chars, all permutations that can start with that char and  use the rest of the letters come before A.</p> <p>\\(n = |A|\\) and \\(A_i\\) be the \\(i\\)-th character. For each \\(i\\) \\(0 \\leq i \\leq n\\):</p> <p>smaller = number of unused chars \\(&lt; A_i\\)</p> <p>Permutations with \\(A_0...A_{i-1}\\) then a smaller char : \\(smaller \\times (n-1-i)!\\)</p> <p>So the total rank: \\(1 + \\sum_{i = 0}^{n-1}(\\text{number of unused chars &lt; } A_i \\times (n-1-i)!)\\)</p> <pre><code>from collections import Counter\nMOD = 10**9 + 7\ndef findRank(A):\n    n = len(A)\n    rank = 1\n    fact = [1]*(n+1)\n    for i in range(1,n+1):\n        fact[i] = (fact[i-1]*i) % MOD\n    freq = Counter(A) #freq count of all chars\n    for i,c in enumerate(A):\n        freq[c] -= 1\n        smaller = sum(freq[ch] for ch in freq if ch &lt; c)\n        rank = (rank + smaller*fact[n-1-i]) % MOD\n    return rank\n</code></pre>"},{"location":"DSAyy/Maths/#largest-coprime-divisor","title":"Largest Coprime Divisor","text":"<p>Given two positive int \\(A\\) and \\(B\\). find largest int \\(X\\) such that \\(X\\) divides \\(A\\) and \\(gcd(X,B) = 1\\). (that is, \\(X\\) and \\(B\\) are coprime).</p> <p>Ex: A = 30, B = 12, Answer = 5</p> <p>$$ \\text{while gcd(A,B) &gt; 1}: A \\equiv \\frac{A}{gcd(A,B)}  $$ Then A would be the answer.</p> <pre><code>def largCD(A,B):\n    while gcd(A,B) &gt; 1:\n        A = A // gcd(A,B)\n    return A\n</code></pre>"},{"location":"DSAyy/Maths/#sorted-permutation-rank-with-repeats","title":"Sorted Permutation Rank with Repeats","text":"<p>Given a string A with repeated chars, find the Rank of A among all its permutations.</p> <p>Return the rank modulo \\(10^6 + 3\\)</p> <p>Ex: A = \"aba\": Rank of aba is 2.</p>"},{"location":"DSAyy/Maths/#how_9","title":"How","text":"<p>Suppose A has n chars, possibly repeated. The number of unique permutations of A is: $$ Total = \\frac{n!}{\\prod_c(freq[c])!} $$ The rank of A is found by counting how many unique strings are lexicographically smaller than A.</p> <p>At each index i (\\(0\\) to \\(n-1\\)):</p> <ol> <li> <p>For each char \\(c\\) strictly less than \\(A[i]\\) that is still available,</p> </li> <li> <p>Place c at position i, then count how many unique permutations can be made with the remaining multiset.</p> </li> </ol> <p>$$ count = \\frac{(n-i-1)!}{\\prod_x(freq^`[x])!} $$ <pre><code>from math import factorial\nfrom collections import Counter\nMOD = 1000003\ndef modinv(a,mod):\n    return pow(a,mod - 2, mod)\ndef findRank(A):\n    n = len(A)\n    fact = [1]*(n+1)\n    inv_fact = [1]*(n+1)\n    for i in range(n):\n        fact[i] = (fact[i-1]*i) % MOD\n    inv_fact[n] = modinv(fact[n], MOD)\n    for i in range(n-1,-1,-1):\n        inv_fact[i] = (inv_fact[i+1]*(i+1)) % MOD\n    freq = Counter(A)\n    chars = sorted(freq.keys())\n    ans = 0\n    for i in range(n):\n        cur = A[i]\n        rem = n - 1 - i\n        for c in filter(lamda x: x &lt; cur, chars):\n            if freq[c] == 0:\n                continue\n            freq[c] -= 1\n            #compute permutations of remaining chars\n            perms = fact[rem]\n            for val in freq.values():\n                perms = (perms*inv_fact[val])% MOD\n            ans = (ans + perms) % MOD\n            freq[c] += 1\n        freq[cur] -= 1\n        if freq[cur] == 0:\n            chars.remove(cur)\n    return (ans + 1) % MOD\n</code></pre></p>"},{"location":"DSAyy/Maths/#k-th-permutation","title":"K-th Permutation","text":"<p>Given an integer A (length of the permutation) amd an int B, return the Bth permutation of A.</p>"},{"location":"DSAyy/Maths/#how_10","title":"How","text":"<p>There are A! permutations in total.</p> <p>Fix the first element: for \\([1,2....A]\\), the first element can be any of the A numbers, and for each such choice, there are (A-1)! ways to permute the rest.</p> <p>To find the Bth permutation, we can decide the first number, by figuring out how many blocks of size (A-1)! fit into B-1 (0-based index).</p> <p>Ex: </p> <p>A = 3; All perms = \\([1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]\\) </p> <p>Block size for first element: 2! = 2</p> <p>So permutations are grouped as: \\(\\(Start with 1: [1, 2, 3], [1, 3, 2] \\space Start with 2: [2, 1, 3], [2, 3, 1] \\space Start with 3: [3, 1, 2], [3, 2, 1]\\)\\) If B = 3, zero-based: B-1 = 2, 2/2 = 1. So second group (\\([2,1,3]\\)). Within group, 2 mod 2 = 0, so first element in group: \\([2,1,3]\\)</p> <p>Let S be the set of available numbers, At position i (\\(i \\leq i \\leq A\\)) $$ index = \\lfloor \\frac{B'}{(A-1-i)!} \\rfloor $$ Pick the \\(index\\)-th unused element, Update \\(B' = B' \\space mod \\space (A-1-i)!\\)</p>"},{"location":"DSAyy/Maths/#mathematical-diss","title":"Mathematical Diss","text":"<p>Partitioning List into equal sized blocks.</p> <p>Fix the first element, </p> <ul> <li> <p>If the first element is 1, the remaining A-1 numbers can appear in \\((A-1)!\\) ways.</p> </li> <li> <p>IF the first element is 2, same \\((A-1)!\\) ways.</p> </li> </ul> <p>Hence the full list can be viewed as \\((A-1)!\\) sized blocks.</p> <p>Now turning the rank b into factorial based digits.</p> <p>r = B - 1 (zero-based)</p> <p>Divide R successively by factorials.</p> step (position) divisor quotient = digit remainder interpretation 1st element (A-1)! \\(d_{A-1}=\\big\\lfloor r/(A-1)!\\big\\rfloor\\) \\(r\\gets r \\bmod (A-1)!\\) pick the \\(d_{A-1}-th\\) unused number 2nd element (A-2)! \\(d_{A-2}=\\big\\lfloor r/(A-2)!\\big\\rfloor\\) \\(r\\gets r \\bmod (A-2)!\\) pick the \\(d_{A-2}-th\\) unused number \u2026 \u2026 \u2026 \u2026 \u2026 last element 0!=10!=1 \\(d_{0}=r\\) 0 only one number left <pre><code>from math import factorial\n\ndef kth_permutation(A,B):\n    B -= 1 #zero based\n    symbols = list(range(1,A+1))\n    result = []\n    #repeatedly pick the correct element by factorial base digits.\n    for remaining in range(A,0,-1):\n        block = factorial(remaining - 1)\n        idx, B = divmod(B, block)\n        result.append(symbols.pop(idx))\n    return result\n</code></pre>"},{"location":"DSAyy/Maths/#city-tour","title":"City Tour","text":"<p>Given \\(A\\) cities from \\(1\\) to \\(A\\). \\(M\\) of them are already visited, given by an array \\(B\\) (of length \\(M\\)). From any visited city, you can visit adjacent unvisited cities \\((i-1)\\) or \\((i+1)\\). At each step, you can choose any available city that is adjacent to a visited city. Find the number of ways to visit all cities, modulo \\(10^9 + 7\\).</p> <p>For A = 5, B = \\([2,5]\\), All poss ways are:</p> <ol> <li> <p>1\u21923\u21924</p> </li> <li> <p>1\u21924\u21923</p> </li> <li> <p>3\u21921\u21924</p> </li> <li> <p>3\u21924\u21921</p> </li> <li> <p>4\u21921\u21923</p> </li> <li> <p>4\u21923\u21921</p> </li> </ol>"},{"location":"DSAyy/Maths/#how_11","title":"How","text":"<p>Partition the cities into segments.</p> <p>\\(L_0\\) : before the first visited city.</p> <p>\\(L_1..L_{M-1}\\): Between the visited cities.</p> <p>\\(L_M\\) after the visited city.</p> <p>So the edge segments have only one way to travel, but..</p> <p>MIddle segments have \\(2^{k-1}\\) ways to travel (since we can choose left or right)</p> <p>So the ways: $$ ways = \\frac{N!}{L_0!...L_M!} \\prod_{i=1}^{M-1} 2^{L_i - 1} $$</p> <p>Given; $$A = 5, B = [2,5] \\space L_0 = 2 - 1 = 1 \\space L_1 = 5 \u2212 2 \u2212 1 = 2 \\space L_2 = 5-5 = 0 \\space N = 5-2 = 3 $$ $$ ways = \\frac{3!}{1!2!0!} \\times 2^{2-1} = 6 $$</p> <pre><code>MOD = 1_000_000_007\ndef city_tour(A,B):\n    B = sorted(B)\n    gaps = [B[0] - 1] + [B[i] - B[i-1] - 1 for i in range(1,len(B))] + [A-B[-1]]\n    unvisited = A - len(B)\n    fact = [1]*(A+1)\n    for i in range(1,A+1):\n        fact[i] = fact[i-1]*i % MOD\n    inv_fact = [1]*(A+1)\n    inv_fact[A] = pow(fact[A], MOD-2, MOD)\n    for i in range(A,0,-1):\n        inv_fact[i-1] = inv_fact[i]*i % MOD\n    ans = fact[unvisited]\n    for g in gaps:\n        ans = ans * inv_fact[g] % MOD\n    #internal gaps add more\n    for g in gaps[1:-1]:\n        if g &gt;= 2:\n            ans = ans * pow(2,g-1,MOD) % MOD\n    return ans\n</code></pre>"},{"location":"DSAyy/Maths/#grid-unique-paths","title":"Grid Unique Paths","text":"<p>You are on the topleft of \\(A \\times B\\) grid. Robot can move only down and right. How many unique paths are there from top-left to bottom-right.</p>"},{"location":"DSAyy/Maths/#how_12","title":"How","text":"<p>Each unique path is a sequence of A-1 down moves and B-1 right moves.</p> <p>In total we make: \\(t = (A-1) + (B-1) = A + B - 2\\) moves. Out of which \\(A-1\\) are down.</p> <p>So total unique paths would be: $$ \\text{Unique Paths } = \\binom{A+B-2}{A-1} = \\frac{(A+B-2)!}{(A-1)! \\cdot (B-1)!} $$ we can also write $$ \\binom{t}{k} = \\prod_{i = 1}^{k} \\frac{t - k + i}{i} $$ So that means no factorial needed.</p> <pre><code>def uniquePaths(A,B):\n    n,m = A-1, B-1\n    k = min(m,n)\n    t = m+n\n    res = 1\n    for i in range(1,k+1):\n        res *= (t-k+1)//i\n    return res\n</code></pre>"},{"location":"DSAyy/Maths/#highest-score","title":"Highest Score","text":"<p>You are given a N \\times 2 string array A. Where each row consists of students name and their marks. Find maximum average marks for any student (rounding down).</p> <pre><code>def highestScore(records):\n    from collections import defaultdict\n    scores = defaultdict(lambda: [0,0])\n    for name, mark in records:\n        mark = int(mark)\n        scores[name][0] += mark #total score\n        scores[names][1] += 1 #count\n    best = 0\n    for total,count in score.values():\n        avg = total // count\n        best = max(best,avg)\n    return best\n</code></pre>"},{"location":"DSAyy/Maths/#addition-without-summation","title":"Addition without summation.","text":"<p>Add two numbers without summation.</p> <p>So basically sumBits = \\(A \\oplus B\\) and carryBits = \\((A \\&amp; B) &lt;&lt; 1\\) </p> <pre><code>def add(A,B):\n    while B != 0:\n        sumBits = A^B\n        carryBits = (A&amp;B) &lt;&lt; 1\n        A = sumBits\n        B = carryBits\n    return A\n</code></pre>"},{"location":"DSAyy/Maths/#next-similar-number","title":"Next Similar Number","text":"<p>Given a numeric string A, find the next_permutation that is greater than A.</p> <p>Find the pivot (first index i such that \\(A[i] &lt; A[i+1]\\)). If there is none, we have no next number. </p> <p>Find the successor (smallest digit from the right of \\(i\\), that is \\(&gt; i\\))</p> <p>Swap \\(A[i]\\) and \\(A[j]\\).</p> <p>Reverse from \\(A[i+1]\\) to the end.</p> <pre><code>def next_permutation(A):\n    A = list(A)\n    n = len(A)\n    i = n-2\n\n    while i &gt;= 0 and A[i] &gt;= A[i+1]:\n        i -= 1\n    if i &lt; 0:\n        return \"-1\"\n    j = n-1\n    while A[j] &lt;= A[i]:\n        j -= 1\n    A[i],A[j] = A[j], A[i]\n    A[i+1:] = reversed(A[i+1:])\n    return ''.join(A)\n</code></pre>"},{"location":"DSAyy/Maths/#rearrange-array","title":"Rearrange Array","text":"<p>Given an array, rearrange such that \\(A[i]\\) becomes \\(A[A[i]]\\).</p> <p>All elements are in range \\([0,N-1]\\), and distinct.</p>"},{"location":"DSAyy/Maths/#how_13","title":"How","text":"<p>Let \\(A[i] = \\text{ old value } + N \\times \\text{ new value}\\)</p> <p>then decode by \\(A[i] \\gets \\lfloor \\frac{A[i]}{N} \\rfloor\\)</p> <pre><code>def arrange(A):\n    N = len(A)\n    for i in range(N):\n        old = A[i]\n        newv = A[old] % N\n        A[i] = old + newv*N\n    A = [i//N for i in A]\n</code></pre>"},{"location":"DSAyy/Maths/#number-of-length-b-and-value-less-than-c","title":"Number of length B and value less than C","text":"<p>Given a set of digits \\(A\\) (sorted, may contain 0), and int \\(B\\) and \\(C\\). Count how many \\(B\\)-digit numbers are strictly less than \\(C\\).</p> <p>A = 0 1 5, B = 1, C = 2. Output = 2 (0,1)</p>"},{"location":"DSAyy/Maths/#how_14","title":"How","text":"<p>Let C have digits: \\(C_1C_2..C_B\\) We iterate over each digit position \\(i\\) from 0 to \\(B-1\\)</p> <p>For each position, count how many digits in \\(A\\) are \\(&lt; C_i\\) (for \\(i = 0\\), skip \\(0\\) if \\(B &gt; 1\\))</p> <p>For every such choice, the rest of \\(B-1- i\\) digits can be anything in A.</p> <p>If \\(C_i\\) itself not in \\(A\\), stop.</p> <pre><code>from bisect import bisect_left\n\ndef countNumbers(digits,length,upper):\n    digits = sorted(set(digits))\n    d = len(digits)\n    if d == 0 or length == 0:\n        return 0\n    upper_str = str(upper)\n    u_len = len(upper_str)\n    if u_len &lt; length:\n        return 0\n    # precomp powers: p[k] = d**k k &lt;= length\n    p = [1]\n    for _ in range(length):\n        p.append(p[-1]*d)\n    # \u2500\u2500 1.  C has more digits than `length` \u2192 only \u201clength-digit universe\u201d counts\n    #     First digit cannot be 0 if length &gt; 1\n    if u_len &gt; length:\n        if length == 0:\n            return d\n        non_zero_first = d - (1 if 0 in digits else 0)\n        return non_zero_first * p[length -1]\n    # \u2500\u2500 2.  u_len == length:  digit-by-digit scan\n    total = 0\n    for i in range(length):\n        current_digit = int(upper_str[i])\n        #how many avail are smaller than cur digit\n        smaller = bisect_left(digits,current_digit)\n        if i == 0 and length &gt; 1 and 0 in digits:\n            smaller -= 1 #cant start from 0\n        # add combinations for selecting a \u201csmaller\u201d digit here\n        total += smaller*p[length - 1 -i]\n        # if the current digit of C is not present in our digit set,\n        # we cannot continue matching the prefix \u21d2 stop the scan\n        if current_digit not in digits:\n            break\n    return total\n</code></pre>"},{"location":"DSAyy/OOPs/","title":"OOPS","text":""},{"location":"DSAyy/OOPs/#index","title":"Index","text":"<ol> <li> <p>OOP Fundamentals &amp; Pillars</p> </li> <li> <p>Classes &amp; Objects</p> </li> <li> <p>Encapsulation &amp; Access Control</p> </li> <li> <p>Inheritance</p> </li> <li> <p>Polymorphism</p> </li> <li> <p>Abstraction &amp; Interfaces</p> </li> <li> <p>Constructors, Destructors &amp; Object Lifecycle</p> </li> <li> <p>SOLID Design Principles</p> </li> <li> <p>Key Design Patterns</p> </li> <li> <p>UML &amp; System\u2011Level OOP Design</p> </li> <li> <p>Common OOP Interview Questions</p> </li> <li> <p>Tips for A+\u2011Level OOP Interviews</p> </li> </ol>"},{"location":"DSAyy/OOPs/#1-oop-fundamentals-pillars","title":"1. OOP Fundamentals &amp; Pillars","text":"<p>Object\u2011Oriented Programming models software as interacting objects (data + behavior).</p> <ul> <li> <p>Encapsulation: Bundling data (fields) and methods; hides internal state.</p> </li> <li> <p>Abstraction: Exposing only relevant interfaces; hides complexity.</p> </li> <li> <p>Inheritance: Reusing and extending behavior via parent\u2013child relationships.</p> </li> <li> <p>Polymorphism: \u201cMany forms\u201d \u2013 same interface, different implementations.</p> </li> </ul> <p>Common Interview Queries</p> <ul> <li> <p>\u201cExplain the four pillars of OOP with examples.\u201d</p> </li> <li> <p>\u201cWhy isn\u2019t OOP just about classes and objects?\u201d</p> </li> <li> <p>\u201cHow do these pillars interplay to improve maintainability?\u201d</p> </li> </ul>"},{"location":"DSAyy/OOPs/#2-classes-objects","title":"2. Classes &amp; Objects","text":"<ul> <li> <p>Class: Blueprint defining fields and methods.</p> </li> <li> <p>Object: Runtime instance with its own state.</p> </li> </ul> <pre><code>class User {\n    private String name;\n    private int id;\n\n    public User(int id, String name) {  // constructor\n        this.id = id;\n        this.name = name;\n    }\n    public String getName() { return name; }\n    public void setName(String name) { this.name = name; }\n}\n</code></pre> <ul> <li> <p>Static vs. Instance members:</p> <ul> <li> <p><code>static</code> fields/methods belong to the class, not instances.</p> </li> <li> <p>Instance members vary per object.</p> </li> </ul> </li> </ul> <p>Pitfalls &amp; Gotchas</p> <ul> <li> <p>Overusing <code>static</code> leads to global state and thread\u2011safety issues.</p> </li> <li> <p>Mutable shared objects can break encapsulation.</p> </li> </ul> <p>Common Interview Queries</p> <ul> <li> <p>\u201cWhat\u2019s the difference between a class variable and an instance variable?\u201d</p> </li> <li> <p>\u201cHow does the JVM lay out objects in memory?\u201d</p> </li> </ul>"},{"location":"DSAyy/OOPs/#3-encapsulation-access-control","title":"3. Encapsulation &amp; Access Control","text":"<p>Access Modifiers (Java/C#)</p> <ul> <li> <p><code>private</code> \u2013 accessible only within class.</p> </li> <li> <p><code>protected</code> \u2013 plus subclasses and same package.</p> </li> <li> <p><code>public</code> \u2013 everywhere.</p> </li> <li> <p>(package\u2011private) \u2013 default, visible in same package.</p> </li> </ul> <p>Benefits</p> <ul> <li> <p>Prevents external code from putting object into invalid state.</p> </li> <li> <p>Allows internal refactoring without breaking clients.</p> </li> </ul> <pre><code>class Account {\n    private double balance;\n\n    public void deposit(double amt) {\n        if (amt &lt; 0) throw new IllegalArgumentException();\n        balance += amt;\n    }\n    public double getBalance() { return balance; }\n}\n</code></pre> <p>Common Interview Queries</p> <ul> <li> <p>\u201cWhy use getters/setters instead of public fields?\u201d</p> </li> <li> <p>\u201cExplain tight vs. loose encapsulation.\u201d</p> </li> </ul>"},{"location":"DSAyy/OOPs/#4-inheritance","title":"4. Inheritance","text":"<ul> <li> <p>Single vs. Multiple Inheritance:</p> <ul> <li> <p>Java/C# allow single\u2011class inheritance + multiple interfaces.</p> </li> <li> <p>C++ supports multiple inheritance (danger: the Diamond Problem).</p> </li> </ul> </li> </ul> <pre><code>class Animal {\n    void eat() { \u2026 }\n}\nclass Dog extends Animal {\n    void bark() { \u2026 }\n}\n</code></pre> <ul> <li> <p>Method overriding: Subclass redefines parent\u2019s behavior.</p> </li> <li> <p><code>super</code> / <code>base</code> to call parent implementation.</p> </li> </ul> <p>Pitfalls</p> <ul> <li> <p>Over\u2011deep hierarchies: brittle and hard to change.</p> </li> <li> <p>Inherited implementation may not suit subclass; prefer composition.</p> </li> </ul> <p>Common Interview Queries</p> <ul> <li> <p>\u201cWhat\u2019s the Liskov Substitution Principle?\u201d</p> </li> <li> <p>\u201cWhen is inheritance preferable to composition?\u201d</p> </li> </ul>"},{"location":"DSAyy/OOPs/#5-polymorphism","title":"5. Polymorphism","text":"<ul> <li> <p>Compile\u2011time (Static) Polymorphism:</p> <ul> <li>Method overloading (same name, different signature).</li> </ul> </li> <li> <p>Runtime (Dynamic) Polymorphism:</p> <ul> <li>Method overriding + virtual dispatch.</li> </ul> </li> </ul> <pre><code>class Shape {\n    double area() { return 0; }\n}\nclass Circle extends Shape {\n    double radius;\n    @Override\n    double area() { return Math.PI * radius*radius; }\n}\nvoid printArea(Shape s) {\n    System.out.println(s.area());  // calls appropriate override\n}\n</code></pre> <p>Pitfalls</p> <ul> <li> <p>Overloading vs. overriding confusion.</p> </li> <li> <p>Virtual calls have slight performance cost.</p> </li> </ul> <p>Common Interview Queries</p> <ul> <li> <p>\u201cHow does Java implement dynamic dispatch under the hood?\u201d</p> </li> <li> <p>\u201cGive an example of static binding vs. dynamic binding.\u201d</p> </li> </ul>"},{"location":"DSAyy/OOPs/#6-abstraction-interfaces","title":"6. Abstraction &amp; Interfaces","text":"<ul> <li> <p>Abstract Class: Can have both concrete and abstract methods; share code.</p> </li> <li> <p>Interface: Pure contract (Java 8+ allows <code>default</code> methods too).</p> </li> </ul> <pre><code>interface Payment {\n    void pay(double amount);\n}\nclass CreditCardPayment implements Payment {\n    public void pay(double amount) { \u2026 }\n}\n</code></pre> <p>Why Use Interfaces?</p> <ul> <li> <p>Achieve polymorphism without inheritance.</p> </li> <li> <p>Allow multiple \u201ctypes\u201d (Java) since classes can implement many interfaces.</p> </li> </ul> <p>Common Interview Queries</p> <ul> <li> <p>\u201cWhen would you choose an abstract class over an interface?\u201d</p> </li> <li> <p>\u201cHow do you simulate multiple inheritance in Java?\u201d</p> </li> </ul>"},{"location":"DSAyy/OOPs/#7-constructors-destructors-object-lifecycle","title":"7. Constructors, Destructors &amp; Object Lifecycle","text":"<ul> <li> <p>Constructor Overloading: Multiple ways to initialize an object.</p> </li> <li> <p>Copy Constructors (C++/Java clone): Deep vs. shallow copy.</p> </li> <li> <p>Destructors / Finalizers:</p> <ul> <li> <p>C++: RAII \u2013 destructors free resources.</p> </li> <li> <p>Java: <code>finalize()</code> discouraged; use try\u2011with\u2011resources or explicit close.</p> </li> </ul> </li> </ul> <pre><code>class File {\n  FILE* fp;\npublic:\n  File(const char* name) { fp = fopen(name,\"r\"); }\n  ~File() { if (fp) fclose(fp); }\n};\n</code></pre> <p>Common Interview Queries</p> <ul> <li> <p>\u201cExplain RAII and how it avoids resource leaks.\u201d</p> </li> <li> <p>\u201cWhy is Java\u2019s <code>finalize()</code> problematic?\u201d</p> </li> </ul>"},{"location":"DSAyy/OOPs/#8-solid-design-principles","title":"8. SOLID Design Principles","text":"<ol> <li> <p>Single Responsibility</p> </li> <li> <p>Open/Closed (open for extension, closed for modification)</p> </li> <li> <p>Liskov Substitution (subtypes replace supertypes)</p> </li> <li> <p>Interface Segregation (many small interfaces)</p> </li> <li> <p>Dependency Inversion (code to abstractions)</p> </li> </ol> <p>Example (Open/Closed)</p> <ul> <li>Add new behavior by implementing new class; don\u2019t modify existing ones.</li> </ul> <pre><code>interface Discount {\n  double apply(double price);\n}\nclass SeasonalDiscount implements Discount { \u2026 }\nclass Checkout {\n  double total(Discount d, double price) {\n    return d.apply(price);\n  }\n}\n</code></pre> <p>Common Interview Queries</p> <ul> <li> <p>\u201cGive an example violation of Liskov Substitution.\u201d</p> </li> <li> <p>\u201cHow does Dependency Injection relate to the Dependency Inversion Principle?\u201d</p> </li> </ul>"},{"location":"DSAyy/OOPs/#9-key-design-patterns","title":"9. Key Design Patterns","text":"Pattern Intent Typical Use Singleton Single global instance Logger, Configuration Factory Encapsulate object creation Creating DB connections Observer Publish/subscribe for events UI event handling, notification services Strategy Swap algorithms at runtime Pluggable sorting, payment methods Decorator Add behavior dynamically I/O streams, UI components Adapter Match incompatible interfaces Integrating legacy code Builder Step\u2011by\u2011step construction of complex objects Fluent APIs, constructing HTTP requests <p>Common Interview Queries</p> <ul> <li> <p>\u201cSketch the class diagram for Observer.\u201d</p> </li> <li> <p>\u201cWhen would you use a Factory vs. Abstract Factory?\u201d</p> </li> <li> <p>\u201cImplement Singleton in a thread\u2011safe way.\u201d</p> </li> </ul>"},{"location":"DSAyy/OOPs/#10-uml-systemlevel-oop-design","title":"10. UML &amp; System\u2011Level OOP Design","text":"<ul> <li> <p>Class Diagrams: Show classes, fields, methods, relationships (inheritance, composition, aggregation).</p> </li> <li> <p>Sequence Diagrams: Object interactions over time.</p> </li> <li> <p>Use Case &amp; Activity Diagrams: High\u2011level workflows.</p> </li> </ul> <p>Sample Question: Design the class diagram for an online food ordering flow:</p> <ul> <li> <p>Entities: <code>User</code>, <code>Order</code>, <code>Restaurant</code>, <code>Menu</code>, <code>Payment</code></p> </li> <li> <p>Relationships:</p> <ul> <li> <p><code>User</code> 1\u2014* <code>Order</code></p> </li> <li> <p><code>Order</code> \u2014 <code>MenuItem</code> (via <code>OrderItem</code>)</p> </li> <li> <p><code>Order</code> 1\u20141 <code>Payment</code></p> </li> </ul> </li> </ul> <p>Be prepared to discuss how you\u2019d evolve the model (e.g., add <code>PromoCode</code>, support multiple payment methods via Strategy).</p>"},{"location":"DSAyy/OOPs/#11-common-oop-interview-questions","title":"11. Common OOP Interview Questions","text":"<ol> <li> <p>Explain the difference between abstraction and encapsulation.</p> </li> <li> <p>How do you prevent a class from being subclassed? (Java: <code>final</code> class)</p> </li> <li> <p>What\u2019s the difference between <code>equals()</code> and <code>==</code> in Java?</p> </li> <li> <p>Describe how garbage collection works in your language.</p> </li> <li> <p>How do you implement a thread\u2011safe Singleton?</p> </li> <li> <p>What are mix\u2011ins or traits, and how are they used?</p> </li> <li> <p>Explain interface versioning and evolving APIs without breaking clients.</p> </li> </ol>"},{"location":"DSAyy/OOPs/#12-tips-for-alevel-oop-interviews","title":"12. Tips for A+\u2011Level OOP Interviews","text":"<ul> <li> <p>Think in abstractions: Push most logic into interfaces/strategies, not monolithic classes.</p> </li> <li> <p>Discuss trade\u2011offs: Composition vs. inheritance, runtime vs. compile\u2011time polymorphism.</p> </li> <li> <p>Draw diagrams: Even rough UML on the whiteboard demonstrates clarity.</p> </li> <li> <p>Show awareness of language specifics: Memory model, GC vs. RAII, multithreading nuances.</p> </li> <li> <p>Relate to scale: How does your design handle thousands of simultaneous orders?</p> </li> </ul>"},{"location":"DSAyy/OOPs/#1-explain-the-difference-between-abstraction-and-encapsulation","title":"1. Explain the difference between abstraction and encapsulation","text":"<ul> <li> <p>Encapsulation is about hiding implementation details and protecting object state by exposing a controlled interface.</p> <ul> <li> <p>You make fields <code>private</code> and expose public getters/setters.</p> </li> <li> <p>Example:</p> <pre><code>public class Account {\n  private double balance;         // hidden\n  public void deposit(double amt) {\n    if (amt &lt;= 0) throw new IllegalArgumentException();\n    balance += amt;\n  }\n  public double getBalance() {    // controlled access\n    return balance;\n  }\n}\n</code></pre> </li> </ul> </li> <li> <p>Abstraction is about modeling the essential aspects of a concept while hiding irrelevant details.</p> <ul> <li> <p>You design an interface or abstract class that declares what operations are possible, without specifying how they\u2019re done.</p> </li> <li> <p>Example:</p> <pre><code>public interface PaymentGateway {\n  Receipt charge(CardInfo card, double amount);\n}\n// caller doesn\u2019t care if it\u2019s Stripe, PayPal, or a mock\n</code></pre> </li> </ul> </li> </ul> <p>Key distinction:</p> <ul> <li> <p>Encapsulation is a technique for enforcing abstraction boundaries.</p> </li> <li> <p>Abstraction is a design goal (\u201cWhat does this object do?\u201d); encapsulation is the mechanism (\u201cHow do I enforce that boundary?\u201d).</p> </li> </ul>"},{"location":"DSAyy/OOPs/#2-how-do-you-prevent-a-class-from-being-subclassed","title":"2. How do you prevent a class from being subclassed?","text":"<ul> <li> <p>Java: mark the class <code>final</code>:</p> <pre><code>public final class ImmutablePoint {\n  private final int x, y;\n  public ImmutablePoint(int x, int y) { this.x = x; this.y = y; }\n  public int getX() { return x; }\n  public int getY() { return y; }\n}\n</code></pre> </li> <li> <p>C#: use the <code>sealed</code> keyword:</p> <pre><code>public sealed class Logger {\n  // cannot be inherited\n}\n</code></pre> </li> <li> <p>Why:</p> <ul> <li> <p>Enforce invariants (e.g., immutability).</p> </li> <li> <p>Prevent method overriding that could break base\u2011class contracts.</p> </li> </ul> </li> </ul>"},{"location":"DSAyy/OOPs/#3-whats-the-difference-between-and-equals-in-java","title":"3. What\u2019s the difference between <code>==</code> and <code>equals()</code> in Java?","text":"Operator/Method Compares\u2026 Example <code>==</code> Reference identity (are they the same object?) <code>new String(\"x\") == new String(\"x\") // false</code> <code>equals()</code> Logical equality (if implemented) <code>new String(\"x\").equals(new String(\"x\")) // true</code> <ul> <li> <p>Default <code>equals()</code> (in <code>Object</code>) does the same as <code>==</code>.</p> </li> <li> <p>Override <code>equals()</code> (and <code>hashCode()</code>) for value\u2011based classes:</p> <pre><code>@Override\npublic boolean equals(Object o) {\n  if (this == o) return true;\n  if (!(o instanceof Point)) return false;\n  Point p = (Point)o;\n  return x == p.x &amp;&amp; y == p.y;\n}\n@Override\npublic int hashCode() {\n  return Objects.hash(x, y);\n}\n</code></pre> </li> <li> <p>Pitfall: Failing to override <code>hashCode()</code> breaks hashed collections (e.g., <code>HashSet</code>, <code>HashMap</code>).</p> </li> </ul>"},{"location":"DSAyy/OOPs/#4-describe-how-garbage-collection-works-in-java","title":"4. Describe how garbage collection works in Java","text":"<ol> <li> <p>Roots &amp; Reachability</p> <ul> <li> <p>JVM tracks \u201cGC roots\u201d (active threads, static fields, local vars).</p> </li> <li> <p>Anything reachable from those roots is live; everything else is garbage.</p> </li> </ul> </li> <li> <p>Generational GC</p> <ul> <li> <p>Young Generation: new objects; collected frequently (minor GC).</p> </li> <li> <p>Old Generation: long\u2011lived objects; collected less often (major GC).</p> </li> </ul> </li> <li> <p>Algorithms</p> <ul> <li> <p>Mark\u2011Sweep: Mark live objects, then sweep dead ones.</p> </li> <li> <p>Copying: Move live objects to a new area, reclaim the rest.</p> </li> <li> <p>CMS / G1: Concurrent collectors to reduce pause times.</p> </li> </ul> </li> <li> <p>Tuning</p> <ul> <li> <p>Choose GC algorithm based on throughput vs. latency needs (e.g., G1 for low\u2011pause).</p> </li> <li> <p>Adjust heap sizes (<code>-Xms</code>, <code>-Xmx</code>) and pause thresholds.</p> </li> </ul> </li> <li> <p>Pitfalls</p> <ul> <li> <p>Over\u2011tuning can backfire\u2014monitor real metrics (pause times, allocation rate).</p> </li> <li> <p>Holding onto references (e.g., static caches) leads to memory leaks.</p> </li> </ul> </li> </ol>"},{"location":"DSAyy/OOPs/#5-how-do-you-implement-a-threadsafe-singleton","title":"5. How do you implement a thread\u2011safe Singleton?","text":""},{"location":"DSAyy/OOPs/#51-classic-doublechecked-locking","title":"5.1 Classic Double\u2011Checked Locking","text":"<pre><code>public class Singleton {\n  private static volatile Singleton instance;\n  private Singleton() { }\n  public static Singleton getInstance() {\n    if (instance == null) {                   // 1st check (no lock)\n      synchronized (Singleton.class) {\n        if (instance == null) {               // 2nd check (with lock)\n          instance = new Singleton();\n        }\n      }\n    }\n    return instance;\n  }\n}\n</code></pre> <ul> <li><code>volatile</code> ensures visibility of the initialized instance across threads.</li> </ul>"},{"location":"DSAyy/OOPs/#52-initializationondemand-holder","title":"5.2 Initialization\u2011on\u2011Demand Holder","text":"<pre><code>public class Singleton {\n  private Singleton() { }\n  private static class Holder {\n    static final Singleton INSTANCE = new Singleton();\n  }\n  public static Singleton getInstance() {\n    return Holder.INSTANCE;\n  }\n}\n</code></pre> <ul> <li>JVM guarantees that the <code>Holder</code> class is loaded and initialized lazily and thread\u2011safely on first access.</li> </ul>"},{"location":"DSAyy/OOPs/#6-composition-vs-inheritance","title":"6. Composition vs. Inheritance","text":"<p>Q: What\u2019s the difference between composition and inheritance, and when would you choose one over the other?</p>"},{"location":"DSAyy/OOPs/#answer","title":"Answer","text":"<ul> <li> <p>Inheritance (\u201cis\u2011a\u201d):</p> <ul> <li> <p>A subclass extends a parent class and inherits its behavior/contract.</p> </li> <li> <p>Tight coupling\u2014changes in the base class ripple into all subclasses.</p> </li> <li> <p>Example:</p> <pre><code>class Animal {\n  void eat() { \u2026 }\n}\nclass Dog extends Animal {         // Dog is\u2011a Animal\n  void bark() { \u2026 }\n}\n</code></pre> </li> </ul> </li> <li> <p>Composition (\u201chas\u2011a\u201d):</p> <ul> <li> <p>An object contains instances of other classes to reuse behavior.</p> </li> <li> <p>Looser coupling\u2014internal implementation can change without affecting clients.</p> </li> <li> <p>Example:</p> <pre><code>class Engine {\n  void start() { \u2026 }\n}\nclass Car {\n  private final Engine engine;     // Car has\u2011a Engine\n  Car(Engine e) { this.engine = e; }\n  void drive() {\n    engine.start();\n    // \u2026\n  }\n}\n</code></pre> </li> </ul> </li> </ul>"},{"location":"DSAyy/OOPs/#tradeoffs-when-to-use","title":"Trade\u2011Offs &amp; When to Use","text":"Aspect Inheritance Composition Coupling Tight Looser Flexibility Less (fixed hierarchy) More (delegate at runtime) Reuse Inherited behavior Wrapped behavior via interfaces Change Impact High (fragile base class) Localized <ul> <li> <p>Use inheritance only when there is a clear \u201cis\u2011a\u201d relationship and you want to share or override default behavior.</p> </li> <li> <p>Prefer composition for greater flexibility, to avoid deep hierarchies, and when you want to switch implementations at runtime (e.g., via interfaces).</p> </li> </ul>"},{"location":"DSAyy/OOPs/#7-applying-solid-principles-in-code","title":"7. Applying SOLID Principles in Code","text":"<p>Q: Pick one SOLID principle and show a \u201cbefore vs. after\u201d refactoring example.</p>"},{"location":"DSAyy/OOPs/#answer-openclosed-principle","title":"Answer: Open/Closed Principle","text":"<ul> <li> <p>Before (violates O/C)</p> <pre><code>class InvoiceCalculator {\n  double calculate(Invoice inv, String type) {\n    if (type.equals(\"STANDARD\")) {\n      return inv.getAmount();\n    } else if (type.equals(\"DISCOUNTED\")) {\n      return inv.getAmount() * 0.9;\n    }\n    // add new types \u2192 modify this method\n    return inv.getAmount();\n  }\n}\n</code></pre> </li> <li> <p>After (adheres to O/C)</p> <pre><code>interface InvoiceStrategy {\n  double calculate(Invoice inv);\n}\n\nclass StandardInvoice implements InvoiceStrategy {\n  public double calculate(Invoice inv) {\n    return inv.getAmount();\n  }\n}\n\nclass DiscountedInvoice implements InvoiceStrategy {\n  public double calculate(Invoice inv) {\n    return inv.getAmount() * 0.9;\n  }\n}\n\nclass InvoiceCalculator {\n  private final InvoiceStrategy strategy;\n  InvoiceCalculator(InvoiceStrategy s) { this.strategy = s; }\n  double calculate(Invoice inv) {\n    return strategy.calculate(inv);\n  }\n}\n</code></pre> </li> <li> <p>Why This Is Better</p> <ul> <li> <p>Closed for modification: you don\u2019t change <code>InvoiceCalculator</code>.</p> </li> <li> <p>Open for extension: add new <code>InvoiceStrategy</code> implementations without touching existing code.</p> </li> </ul> </li> </ul>"},{"location":"DSAyy/OOPs/#8-strategy-pattern-in-practice","title":"8. Strategy Pattern in Practice","text":"<p>Q: How does the Strategy pattern work? Provide a code sample.</p>"},{"location":"DSAyy/OOPs/#answer_1","title":"Answer","text":"<ul> <li>Intent: Define a family of interchangeable algorithms, encapsulate each, and make them interchangeable.</li> </ul> <pre><code>// Strategy interface\ninterface SortingStrategy {\n  void sort(int[] data);\n}\n\n// Concrete strategies\nclass QuickSort implements SortingStrategy {\n  public void sort(int[] data) { /* quicksort impl */ }\n}\n\nclass MergeSort implements SortingStrategy {\n  public void sort(int[] data) { /* mergesort impl */ }\n}\n\n// Context\nclass Sorter {\n  private final SortingStrategy strategy;\n  Sorter(SortingStrategy strat) { this.strategy = strat; }\n  void sort(int[] data) {\n    strategy.sort(data);\n  }\n}\n\n// Client usage\nint[] arr = {5,3,8,1};\nSorter sorter = new Sorter(new QuickSort());\nsorter.sort(arr); // uses QuickSort\n</code></pre> <ul> <li> <p>When to Use:</p> <ul> <li> <p>When you have multiple ways to perform an operation and want to switch at runtime (e.g., various payment processors, sorting algorithms, compression codecs).</p> </li> <li> <p>Keeps the context class simple and decoupled from specific implementations.</p> </li> </ul> </li> </ul>"},{"location":"DSAyy/OOPs/#9-evolving-interfaces-without-breaking-clients","title":"9. Evolving Interfaces Without Breaking Clients","text":"<p>Q: You need to add a method to a widely\u2011used interface in Java\u2014how do you avoid breaking all implementations?</p>"},{"location":"DSAyy/OOPs/#answer_2","title":"Answer","text":"<ol> <li> <p>Default Methods (Java\u00a08+):</p> <pre><code>public interface Notifier {\n  void send(String msg);\n  default void sendUrgent(String msg) {\n    send(\"[URGENT] \" + msg);\n  }\n}\n</code></pre> <ul> <li>Existing implementors only needed to define <code>send()</code>, and automatically get <code>sendUrgent()</code>.</li> </ul> </li> <li> <p>Adapter / Wrapper:</p> <ul> <li> <p>Provide an abstract adapter class with a no\u2011op implementation:</p> <pre><code>public abstract class NotifierAdapter implements Notifier {\n  @Override public void send(String msg) { }\n  // new methods get default stubs\n  @Override public void sendUrgent(String msg) { }\n}\n</code></pre> </li> <li> <p>Clients extend <code>NotifierAdapter</code> instead of implementing <code>Notifier</code> directly.</p> </li> </ul> </li> <li> <p>Versioned Interfaces:</p> <ul> <li>Create <code>NotifierV2</code> and maintain both for a transition period.</li> </ul> </li> </ol>"},{"location":"DSAyy/OOPs/#10-mixins-traits-multiple-inheritance-alternatives","title":"10. Mix\u2011ins / Traits &amp; Multiple Inheritance Alternatives","text":"<p>Q: What are mix\u2011ins or traits, and how do you use them in languages that don\u2019t support multiple inheritance?</p>"},{"location":"DSAyy/OOPs/#answer_3","title":"Answer","text":"<ul> <li> <p>Mix\u2011in / Trait: A reusable set of methods and/or fields that can be \u201cmixed into\u201d a class without forming a superclass.</p> </li> <li> <p>Java via Interfaces with Default Methods:</p> <pre><code>interface AuditMixin {\n  default void auditLog(String msg) {\n    System.out.println(\"AUDIT: \" + msg);\n  }\n}\nclass OrderService implements AuditMixin {\n  void placeOrder() {\n    auditLog(\"order placed\");\n  }\n}\n</code></pre> </li> <li> <p>Python Multiple Inheritance:</p> <pre><code>class AuditMixin:\n    def audit_log(self, msg):\n        print(f\"AUDIT: {msg}\")\n\nclass OrderService(AuditMixin):\n    def place_order(self):\n        self.audit_log(\"order placed\")\n</code></pre> </li> <li> <p>C# via Extension Methods:</p> <pre><code>public static class AuditExtensions {\n  public static void AuditLog(this object obj, string msg) {\n    Console.WriteLine($\"AUDIT: {msg}\");\n  }\n}\n// Usage:\n// myService.AuditLog(\"something happened\");\n</code></pre> </li> <li> <p>Why Use Mix\u2011ins/Traits:</p> <ul> <li> <p>Add orthogonal behavior (logging, validation, auditing) to many classes without polluting your class hierarchy.</p> </li> <li> <p>Avoid the diamond problem of true multiple inheritance.</p> </li> </ul> </li> </ul>"},{"location":"DSAyy/OOPs/#11-observer-pattern-realtime-notifications","title":"11. Observer Pattern: Real\u2011Time Notifications","text":"<p>Q: How do you implement the Observer pattern to push real\u2011time order status updates to multiple subscribers?</p>"},{"location":"DSAyy/OOPs/#answer_4","title":"Answer","text":"<ul> <li>Intent: Define a one\u2011to\u2011many dependency so that when one object changes state, all its dependents are notified automatically.</li> </ul> <pre><code>// Observer interface\ninterface OrderObserver {\n  void onOrderStatusChanged(long orderId, String status);\n}\n\n// Subject interface\ninterface OrderSubject {\n  void registerObserver(OrderObserver o);\n  void removeObserver(OrderObserver o);\n  void notifyObservers();\n}\n\n// Concrete Subject\nclass Order implements OrderSubject {\n  private final long id;\n  private String status;\n  private final List&lt;OrderObserver&gt; observers = new ArrayList&lt;&gt;();\n\n  public Order(long id) { this.id = id; }\n  public void setStatus(String status) {\n    this.status = status;\n    notifyObservers();\n  }\n  public String getStatus() { return status; }\n  public long getId() { return id; }\n\n  @Override\n  public void registerObserver(OrderObserver o) {\n    observers.add(o);\n  }\n  @Override\n  public void removeObserver(OrderObserver o) {\n    observers.remove(o);\n  }\n  @Override\n  public void notifyObservers() {\n    for (OrderObserver o : observers) {\n      o.onOrderStatusChanged(id, status);\n    }\n  }\n}\n\n// Concrete Observer\nclass EmailNotifier implements OrderObserver {\n  public void onOrderStatusChanged(long orderId, String status) {\n    System.out.println(\"Email: Order \" + orderId + \" is now \" + status);\n  }\n}\n\n// Usage\nOrder order = new Order(123L);\norder.registerObserver(new EmailNotifier());\norder.setStatus(\"CONFIRMED\");  // triggers notification\n</code></pre> <p>Why It Matters for Zomato:</p> <ul> <li> <p>Enables loosely\u2011coupled updates (e.g., email, SMS, mobile push) whenever the order status changes.</p> </li> <li> <p>Supports dynamic addition/removal of channels without modifying the core <code>Order</code> class.</p> </li> </ul>"},{"location":"DSAyy/OOPs/#12-dependency-injection-inversion-of-control","title":"12. Dependency Injection &amp; Inversion of Control","text":"<p>Q: Explain Dependency Injection (DI) and show how it improves testability.</p>"},{"location":"DSAyy/OOPs/#answer_5","title":"Answer","text":"<ul> <li> <p>Dependency Injection: You inject collaborators into a class instead of creating them internally.</p> </li> <li> <p>Inversion of Control: The class no longer controls instantiation; an external framework or factory does.</p> </li> </ul> <pre><code>// Service interface\ninterface PaymentProcessor {\n  void process(double amount);\n}\n\n// Concrete implementation\nclass StripeProcessor implements PaymentProcessor {\n  public void process(double amount) {\n    System.out.println(\"Processing $\" + amount + \" via Stripe.\");\n  }\n}\n\n// Client class without DI (hard\u2011coded dependency)\nclass CheckoutBad {\n  private final PaymentProcessor processor = new StripeProcessor(); // tight coupling\n  public void checkout(double amount) {\n    processor.process(amount);\n  }\n}\n\n// Client class with DI (loose coupling)\nclass Checkout {\n  private final PaymentProcessor processor;\n  // Constructor injection\n  public Checkout(PaymentProcessor processor) {\n    this.processor = processor;\n  }\n  public void checkout(double amount) {\n    processor.process(amount);\n  }\n}\n\n// Wiring (could be done by Spring, Guice, etc.)\nPaymentProcessor pp = new StripeProcessor();\nCheckout chk = new Checkout(pp);\nchk.checkout(49.99);\n</code></pre> <p>Testability:</p> <ul> <li>In tests, you inject a mock or fake <code>PaymentProcessor</code> to verify behavior without hitting external services.</li> </ul> <pre><code>class FakeProcessor implements PaymentProcessor {\n  boolean called = false;\n  public void process(double amount) { called = true; }\n}\n// In your unit test:\nFakeProcessor fp = new FakeProcessor();\nCheckout chkTest = new Checkout(fp);\nchkTest.checkout(10);\nassertTrue(fp.called);\n</code></pre>"},{"location":"DSAyy/OOPs/#13-prototype-pattern-cloning-objects","title":"13. Prototype Pattern: Cloning Objects","text":"<p>Q: When and how would you use the Prototype pattern to create object copies?</p>"},{"location":"DSAyy/OOPs/#answer_6","title":"Answer","text":"<ul> <li>Intent: Specify the kinds of objects to create using a prototypical instance, then clone it to produce new objects.</li> </ul> <pre><code>// Prototype interface\ninterface CloneableOrder extends Cloneable {\n  CloneableOrder clone();\n}\n\n// Concrete prototype\nclass Order implements CloneableOrder {\n  private long id;\n  private String customer;\n  private List&lt;String&gt; items;\n\n  public Order(long id, String cust, List&lt;String&gt; items) {\n    this.id = id; this.customer = cust;\n    this.items = new ArrayList&lt;&gt;(items);\n  }\n\n  @Override\n  public Order clone() {\n    try {\n      Order copy = (Order) super.clone();\n      copy.items = new ArrayList&lt;&gt;(this.items);  // deep copy\n      return copy;\n    } catch (CloneNotSupportedException e) {\n      throw new AssertionError();\n    }\n  }\n}\n\n// Usage\nOrder prototype = new Order(0, \"guest\", List.of(\"Pizza\", \"Coke\"));\nOrder newOrder = prototype.clone();\nnewOrder.setId(101L);\n</code></pre> <p>When to Use:</p> <ul> <li> <p>Creating new orders with default templates (e.g., guest checkout).</p> </li> <li> <p>Performance benefit when object construction is expensive or complex.</p> </li> </ul>"},{"location":"DSAyy/OOPs/#14-liskov-substitution-principle-lsp-violation-fix","title":"14. Liskov Substitution Principle (LSP) Violation &amp; Fix","text":"<p>Q: Show an LSP violation using a <code>Rectangle</code>/<code>Square</code> example, then refactor to comply.</p>"},{"location":"DSAyy/OOPs/#answer_7","title":"Answer","text":"<ul> <li>Violation: <code>Square</code> inherits from <code>Rectangle</code> but cannot honor <code>setWidth</code>/<code>setHeight</code> independently.</li> </ul> <pre><code>class Rectangle {\n  protected int width, height;\n  public void setWidth(int w) { width = w; }\n  public void setHeight(int h) { height = h; }\n  public int getArea() { return width * height; }\n}\n\nclass Square extends Rectangle {\n  @Override\n  public void setWidth(int w) {\n    super.setWidth(w); super.setHeight(w);\n  }\n  @Override\n  public void setHeight(int h) {\n    super.setWidth(h); super.setHeight(h);\n  }\n}\n\n// Client code expecting Rectangle behavior\nRectangle r = new Square();\nr.setWidth(5);\nr.setHeight(10);\n// Now r.getArea() == 100, not 50 \u2192 surprising behavior!\n</code></pre> <ul> <li>Fix: Use composition instead of inheritance.</li> </ul> <pre><code>interface Shape {\n  int getArea();\n}\n\nclass Rectangle implements Shape {\n  private int width, height;\n  /* setters/getters omitted */\n  public int getArea() { return width * height; }\n}\n\nclass Square implements Shape {\n  private int side;\n  public Square(int side) { this.side = side; }\n  public int getArea() { return side * side; }\n}\n</code></pre> <p>Key Takeaway:</p> <ul> <li> <p>Subtypes must conform to the expectations set by their supertypes.</p> </li> <li> <p>Favor composition/interfaces when specialization changes the contract.</p> </li> </ul>"},{"location":"DSAyy/OOPs/#15-chain-of-responsibility-validation-pipeline","title":"15. Chain of Responsibility: Validation Pipeline","text":"<p>Q: Design a request\u2011validation pipeline for orders using the Chain of Responsibility pattern.</p>"},{"location":"DSAyy/OOPs/#answer_8","title":"Answer","text":"<ul> <li>Intent: Pass a request along a chain of handlers; each handler decides to process it and/or pass it on.</li> </ul> <pre><code>// Handler interface\nabstract class OrderHandler {\n  protected OrderHandler next;\n  public OrderHandler linkWith(OrderHandler next) {\n    this.next = next; return next;\n  }\n  public abstract boolean handle(OrderContext ctx);\n}\n\nclass StockCheckHandler extends OrderHandler {\n  @Override\n  public boolean handle(OrderContext ctx) {\n    if (!checkStock(ctx)) return false;\n    return next == null || next.handle(ctx);\n  }\n}\n\nclass PaymentValidationHandler extends OrderHandler {\n  @Override\n  public boolean handle(OrderContext ctx) {\n    if (!validatePayment(ctx)) return false;\n    return next == null || next.handle(ctx);\n  }\n}\n\nclass AddressValidationHandler extends OrderHandler {\n  @Override\n  public boolean handle(OrderContext ctx) {\n    if (!validateAddress(ctx)) return false;\n    return next == null || next.handle(ctx);\n  }\n}\n\n// Wiring the chain\nOrderHandler chain = new StockCheckHandler();\nchain.linkWith(new PaymentValidationHandler())\n     .linkWith(new AddressValidationHandler());\n\n// Processing\nboolean valid = chain.handle(orderCtx);\nif (!valid) {\n  // reject order\n}\n</code></pre> <p>Why It Fits Zomato:</p> <ul> <li>You can add/remove/ reorder validation steps (stock, payment, address, fraud check) without changing the core order\u2011processing logic.</li> </ul>"},{"location":"DSAyy/OOPs/#16-interface-segregation-principle-isp-violation-refactor","title":"16. Interface Segregation Principle (ISP) Violation &amp; Refactor","text":"<p>Q: You have this bloated interface\u2014<code>MultiFunctionDevice</code>\u2014that forces clients to implement methods they don\u2019t need. How do you refactor it to obey ISP?</p>"},{"location":"DSAyy/OOPs/#violation","title":"Violation","text":"<pre><code>public interface MultiFunctionDevice {\n  void print(Document d);\n  void fax(Document d);\n  void scan(Document d);\n}\n\nclass OldPrinter implements MultiFunctionDevice {\n  public void print(Document d) { /* okay */ }\n  public void fax(Document d)   { throw new UnsupportedOperationException(); }\n  public void scan(Document d)  { throw new UnsupportedOperationException(); }\n}\n</code></pre> <p>Problem: <code>OldPrinter</code> is forced to implement fax/scan it doesn\u2019t support.</p>"},{"location":"DSAyy/OOPs/#refactor","title":"Refactor","text":"<pre><code>// Split into focused interfaces\npublic interface Printer {\n  void print(Document d);\n}\npublic interface Scanner {\n  void scan(Document d);\n}\npublic interface Fax {\n  void fax(Document d);\n}\n\n// Now compose only what you need\nclass SimplePrinter implements Printer {\n  public void print(Document d) { /* print logic */ }\n}\nclass MultiFunctionPrinter implements Printer, Scanner, Fax {\n  public void print(Document d) { /* ... */ }\n  public void scan(Document d)  { /* ... */ }\n  public void fax(Document d)   { /* ... */ }\n}\n</code></pre> <p>Why This Matters</p> <ul> <li> <p>Clients depend only on the methods they use.</p> </li> <li> <p>Future devices can implement just <code>Printer</code> or <code>Scanner</code> without stub methods.</p> </li> </ul>"},{"location":"DSAyy/OOPs/#17-dependency-inversion-principle-dip-in-practice","title":"17. Dependency Inversion Principle (DIP) in Practice","text":"<p>Q: Show how to apply DIP so a high\u2011level module doesn\u2019t depend on a low\u2011level implementation.</p>"},{"location":"DSAyy/OOPs/#before-violation","title":"Before (Violation)","text":"<pre><code>class EmailService {\n  private final SmtpClient smtp = new SmtpClient(\"smtp.zomato.com\");\n  void sendEmail(String to, String body) {\n    smtp.connect();\n    smtp.send(to, body);\n  }\n}\n</code></pre> <p>Problem: <code>EmailService</code> is tightly coupled to <code>SmtpClient</code>.</p>"},{"location":"DSAyy/OOPs/#after-adheres-to-dip","title":"After (Adheres to DIP)","text":"<pre><code>// Abstraction\npublic interface MessageSender {\n  void send(String to, String body);\n}\n\n// Low\u2011level module\npublic class SmtpSender implements MessageSender {\n  public void send(String to, String body) {\n    // SMTP logic\n  }\n}\n\n// High\u2011level module depends on abstraction\npublic class NotificationService {\n  private final MessageSender sender;\n  public NotificationService(MessageSender sender) {\n    this.sender = sender;\n  }\n  public void notifyUser(String user, String msg) {\n    sender.send(user, msg);\n  }\n}\n\n// Wiring (e.g., in a DI container)\nMessageSender smtp = new SmtpSender();\nNotificationService svc = new NotificationService(smtp);\n</code></pre> <p>Why This Matters</p> <ul> <li> <p>Swapping to an SMS or push\u2011notification provider requires no changes in <code>NotificationService</code>.</p> </li> <li> <p>Improves testability by injecting mocks for <code>MessageSender</code>.</p> </li> </ul>"},{"location":"DSAyy/OOPs/#18-generics-wildcards-in-java-pecs","title":"18. Generics &amp; Wildcards in Java (\u201cPECS\u201d)","text":"<p>Q: Explain covariance/contravariance in Java generics and the PECS mnemonic.</p>"},{"location":"DSAyy/OOPs/#key-concepts","title":"Key Concepts","text":"<ul> <li> <p>Producer Extends (<code>? extends T</code>): You can read <code>T</code> out safely, but cannot write.</p> </li> <li> <p>Consumer Super (<code>? super T</code>): You can write <code>T</code> into it, but reading gives <code>Object</code>.</p> </li> </ul> <pre><code>List&lt;Integer&gt; ints = List.of(1,2,3);\nList&lt;? extends Number&gt; producers = ints;\n// producers.add(4);              // \u274c compile\u2011error\nNumber n = producers.get(0);       // \u2705 safe\n\nList&lt;Object&gt; objs = new ArrayList&lt;&gt;();\nList&lt;? super Integer&gt; consumers = objs;\nconsumers.add(42);                 // \u2705 safe\nObject o = consumers.get(0);       // \u2705 gives Object\nInteger i = consumers.get(0);      // \u274c need cast\n</code></pre>"},{"location":"DSAyy/OOPs/#use-cases","title":"Use Cases","text":"<ul> <li> <p><code>? extends</code> for read\u2011only inputs (e.g., passing a <code>List&lt;Integer&gt;</code> to a method expecting numbers).</p> </li> <li> <p><code>? super</code> for write\u2011only outputs (e.g., collecting elements).</p> </li> </ul> <p>Why This Matters</p> <ul> <li>Correct use of wildcards avoids unsafe casts and maximizes API flexibility.</li> </ul>"},{"location":"DSAyy/OOPs/#19-decorator-pattern-for-menu-item-pricing","title":"19. Decorator Pattern for Menu Item Pricing","text":"<p>Q: You need to add optional toppings (cheese, olives, etc.) to a base pizza and calculate the total price dynamically. How do you use the Decorator pattern?</p>"},{"location":"DSAyy/OOPs/#implementation","title":"Implementation","text":"<pre><code>// Component\ninterface MenuItem {\n  String getDescription();\n  double getPrice();\n}\n\n// Concrete Component\nclass PlainPizza implements MenuItem {\n  public String getDescription() { return \"Plain Pizza\"; }\n  public double getPrice() { return 5.00; }\n}\n\n// Base Decorator\nabstract class ToppingDecorator implements MenuItem {\n  protected final MenuItem item;\n  public ToppingDecorator(MenuItem item) { this.item = item; }\n}\n\n// Concrete Decorators\nclass Cheese extends ToppingDecorator {\n  public Cheese(MenuItem item) { super(item); }\n  public String getDescription() {\n    return item.getDescription() + \", Cheese\";\n  }\n  public double getPrice() {\n    return item.getPrice() + 1.25;\n  }\n}\n\nclass Olives extends ToppingDecorator {\n  public Olives(MenuItem item) { super(item); }\n  public String getDescription() {\n    return item.getDescription() + \", Olives\";\n  }\n  public double getPrice() {\n    return item.getPrice() + 0.75;\n  }\n}\n\n// Usage\nMenuItem order = new Olives(new Cheese(new PlainPizza()));\nSystem.out.println(order.getDescription()); // Plain Pizza, Cheese, Olives\nSystem.out.println(order.getPrice());       // 7.00\n</code></pre> <p>Why This Matters</p> <ul> <li> <p>You can stack any combination of toppings at runtime without exploding the class count.</p> </li> <li> <p>Promotes the open/closed principle\u2014new toppings are new decorators, no changes to existing code.</p> </li> </ul>"},{"location":"DSAyy/OOPs/#20-adapter-pattern-for-legacy-payment-integration","title":"20. Adapter Pattern for Legacy Payment Integration","text":"<p>Q: You have an existing <code>PaymentGateway</code> interface but need to integrate a legacy processor with an incompatible API. How do you adapt it?</p>"},{"location":"DSAyy/OOPs/#existing-interface","title":"Existing Interface","text":"<pre><code>interface PaymentGateway {\n  Receipt pay(CreditCard card, double amount);\n}\n</code></pre>"},{"location":"DSAyy/OOPs/#legacy-class","title":"Legacy Class","text":"<pre><code>class LegacyProcessor {\n  public TransactionResult processPayment(String cardNum, String exp, double amt) {\n    // old style logic\u2026\n  }\n}\n</code></pre>"},{"location":"DSAyy/OOPs/#adapter","title":"Adapter","text":"<pre><code>class LegacyPaymentAdapter implements PaymentGateway {\n  private final LegacyProcessor legacy;\n  public LegacyPaymentAdapter(LegacyProcessor legacy) {\n    this.legacy = legacy;\n  }\n  @Override\n  public Receipt pay(CreditCard card, double amount) {\n    TransactionResult res = legacy.processPayment(\n      card.getNumber(),\n      card.getExpiry(),\n      amount\n    );\n    return new Receipt(res.getId(), res.isSuccessful());\n  }\n}\n\n// Usage\nPaymentGateway gateway = new LegacyPaymentAdapter(new LegacyProcessor());\nReceipt rcpt = gateway.pay(card, 100.00);\n</code></pre> <p>Why This Matters</p> <ul> <li> <p>The adapter shields the rest of your codebase from the legacy API.</p> </li> <li> <p>You can replace the adapter later when you migrate to a modern processor without touching business logic.</p> </li> </ul>"},{"location":"DSAyy/OOPs/#21-builder-pattern-for-complex-object-construction","title":"21. Builder Pattern for Complex Object Construction","text":"<p>Q: You need to construct an <code>Order</code> object that has dozens of optional parameters (promo code, special instructions, tip, delivery window, etc.). How do you apply the Builder pattern to keep construction readable and safe?</p>"},{"location":"DSAyy/OOPs/#answer_9","title":"Answer","text":"<ul> <li>Intent: Separate the construction of a complex object from its representation, allowing step\u2011by\u2011step creation and immutability.</li> </ul> <pre><code>public class Order {\n  private final long    orderId;\n  private final long    userId;\n  private final List&lt;Item&gt; items;\n  private final String  promoCode;\n  private final String  instructions;\n  private final double  tip;\n  private final LocalDateTime deliverBy;\n\n  private Order(Builder b) {\n    this.orderId      = b.orderId;\n    this.userId       = b.userId;\n    this.items        = List.copyOf(b.items);\n    this.promoCode    = b.promoCode;\n    this.instructions = b.instructions;\n    this.tip          = b.tip;\n    this.deliverBy    = b.deliverBy;\n  }\n\n  // Getters omitted for brevity\u2026\n\n  public static class Builder {\n    // Required\n    private final long    orderId;\n    private final long    userId;\n    private final List&lt;Item&gt; items;\n\n    // Optional \u2013 initialized to defaults\n    private String          promoCode    = \"\";\n    private String          instructions = \"\";\n    private double          tip          = 0.0;\n    private LocalDateTime   deliverBy    = LocalDateTime.now().plusHours(1);\n\n    public Builder(long orderId, long userId, List&lt;Item&gt; items) {\n      this.orderId = orderId;\n      this.userId  = userId;\n      this.items   = new ArrayList&lt;&gt;(items);\n    }\n\n    public Builder promoCode(String code) {\n      this.promoCode = code; return this;\n    }\n    public Builder instructions(String instr) {\n      this.instructions = instr; return this;\n    }\n    public Builder tip(double t) {\n      this.tip = t; return this;\n    }\n    public Builder deliverBy(LocalDateTime dt) {\n      this.deliverBy = dt; return this;\n    }\n\n    public Order build() {\n      // Validate invariants if needed\n      if (items.isEmpty()) {\n        throw new IllegalStateException(\"Order must have at least one item\");\n      }\n      return new Order(this);\n    }\n  }\n}\n\n// Usage:\nOrder order = new Order.Builder(1001, 2002, itemsList)\n    .promoCode(\"ZOM10\")\n    .tip(2.50)\n    .instructions(\"Leave at door\")\n    .build();\n</code></pre> <p>Why It Matters:</p> <ul> <li> <p>Keeps constructors concise even with many parameters.</p> </li> <li> <p>Ensures immutability and validation before object creation.</p> </li> <li> <p>Fluent API makes client code readable and maintainable.</p> </li> </ul>"},{"location":"DSAyy/OOPs/#22-template-method-pattern-for-order-processing","title":"22. Template Method Pattern for Order Processing","text":"<p>Q: You have a generic algorithm for processing orders (validate \u2192 charge \u2192 notify) but want to allow subclasses to customize individual steps. How does Template Method help?</p>"},{"location":"DSAyy/OOPs/#answer_10","title":"Answer","text":"<ul> <li>Intent: Define the skeleton of an algorithm in a base class, deferring specific steps to subclasses.</li> </ul> <pre><code>// Abstract template\npublic abstract class OrderProcessor {\n  // Template method\n  public final void process(Order o) {\n    validate(o);\n    charge(o);\n    notifyCustomer(o);\n  }\n\n  protected abstract void validate(Order o);\n\n  protected void charge(Order o) {\n    // default charge logic, e.g., call payment gateway\n    System.out.println(\"Charging order \" + o.getId());\n  }\n\n  protected abstract void notifyCustomer(Order o);\n}\n\n// Concrete subclass\npublic class DigitalOrderProcessor extends OrderProcessor {\n  @Override\n  protected void validate(Order o) {\n    // e.g., check digital SKU stock\n  }\n\n  @Override\n  protected void notifyCustomer(Order o) {\n    // e.g., send email with download link\n  }\n}\n</code></pre> <p>Why It Matters:</p> <ul> <li> <p>Enforces overall workflow while permitting customization at well\u2011defined \u201chooks.\u201d</p> </li> <li> <p>Prevents duplication of common steps across multiple processors.</p> </li> </ul>"},{"location":"DSAyy/OOPs/#23-proxy-pattern-for-lazyloading-customer-profile","title":"23. Proxy Pattern for Lazy\u2011Loading Customer Profile","text":"<p>Q: Loading a <code>Customer</code> object eagerly pulls in a large <code>Profile</code> from a remote service. How can you use Proxy to defer that call until actually needed?</p>"},{"location":"DSAyy/OOPs/#answer_11","title":"Answer","text":"<ul> <li>Intent: Provide a surrogate or placeholder for another object to control access, e.g., lazy initialization.</li> </ul> <pre><code>// Subject interface\npublic interface Customer {\n  String getName();\n  Profile getProfile();\n}\n\n// Real subject\nclass RealCustomer implements Customer {\n  private final Profile profile;\n  // constructor loads the profile immediately\u2026\n  public RealCustomer(int id) {\n    this.profile = remoteService.fetchProfile(id);\n  }\n  public String getName() { /* \u2026 */ }\n  public Profile getProfile() { return profile; }\n}\n\n// Proxy\nclass CustomerProxy implements Customer {\n  private final int id;\n  private Profile profile;           // initially null\n\n  public CustomerProxy(int id) { this.id = id; }\n  public String getName() {\n    // name is cached or cheap; load if necessary\n    return remoteService.fetchName(id);\n  }\n  public Profile getProfile() {\n    if (profile == null) {\n      profile = remoteService.fetchProfile(id);  // lazy load\n    }\n    return profile;\n  }\n}\n\n// Usage\nCustomer cust = new CustomerProxy(42);\nSystem.out.println(cust.getName());          // no profile call\nProfile p = cust.getProfile();               // remote fetch happens here\n</code></pre> <p>Why It Matters:</p> <ul> <li> <p>Reduces remote calls and memory when profile data is seldom used.</p> </li> <li> <p>Transparently swaps in the proxy without changing client code.</p> </li> </ul>"},{"location":"DSAyy/OOPs/#24-flyweight-pattern-for-menu-items","title":"24. Flyweight Pattern for Menu Items","text":"<p>Q: Zomato caches menu items for millions of restaurants, yet many share identical metadata (name, description). How do you use Flyweight to reduce memory?</p>"},{"location":"DSAyy/OOPs/#answer_12","title":"Answer","text":"<ul> <li>Intent: Share as much intrinsic data as possible among similar objects, storing only extrinsic state externally.</li> </ul> <pre><code>// Flyweight\nclass MenuItemType {\n  private final String name;\n  private final String description;\n  // shared across many restaurants\n  public MenuItemType(String name, String desc) {\n    this.name = name; this.description = desc;\n  }\n  // getters\u2026\n}\n\n// Factory to manage shared types\nclass MenuItemFactory {\n  private static final Map&lt;String, MenuItemType&gt; cache = new ConcurrentHashMap&lt;&gt;();\n\n  public static MenuItemType getType(String name, String desc) {\n    return cache.computeIfAbsent(name, k -&gt; new MenuItemType(name, desc));\n  }\n}\n\n// Context objects\nclass MenuItem {\n  private final MenuItemType type;  // intrinsic (shared)\n  private final double price;       // extrinsic (varies by restaurant)\n  public MenuItem(String name, String desc, double price) {\n    this.type  = MenuItemFactory.getType(name, desc);\n    this.price = price;\n  }\n  // getters delegate to type\u2026\n}\n</code></pre> <p>Why It Matters:</p> <ul> <li> <p>Intrinsic data (name, description) stored once per unique item, not per restaurant.</p> </li> <li> <p>Dramatically cuts memory for large, global catalogs.</p> </li> </ul>"},{"location":"DSAyy/OOPs/#25-visitor-pattern-for-diverse-operations","title":"25. Visitor Pattern for Diverse Operations","text":"<p>Q: You have a hierarchy (<code>Pizza</code>, <code>Burger</code>, <code>Sushi</code>) and need to perform operations like pricing, nutrition calculation, and serialization without cluttering classes. How does Visitor help?</p>"},{"location":"DSAyy/OOPs/#answer_13","title":"Answer","text":"<ul> <li>Intent: Encapsulate operations on a set of object structures by moving them into visitor classes.</li> </ul> <pre><code>// Element interface\ninterface MenuElement {\n  &lt;R&gt; R accept(MenuVisitor&lt;R&gt; visitor);\n}\n\nclass Pizza implements MenuElement {\n  // fields\u2026\n  public &lt;R&gt; R accept(MenuVisitor&lt;R&gt; v) {\n    return v.visit(this);\n  }\n}\n\nclass Burger implements MenuElement {\n  public &lt;R&gt; R accept(MenuVisitor&lt;R&gt; v) {\n    return v.visit(this);\n  }\n}\n\n// Visitor interface\ninterface MenuVisitor&lt;R&gt; {\n  R visit(Pizza p);\n  R visit(Burger b);\n  // ... other menu types\n}\n\n// Concrete visitor: price calculator\nclass PriceCalculator implements MenuVisitor&lt;Double&gt; {\n  public Double visit(Pizza p) {\n    return basePrice(p) + toppingCost(p);\n  }\n  public Double visit(Burger b) {\n    return basePrice(b) + extrasCost(b);\n  }\n}\n\n// Usage\nList&lt;MenuElement&gt; menu = List.of(new Pizza(...), new Burger(...));\ndouble total = menu.stream()\n    .mapToDouble(e -&gt; e.accept(new PriceCalculator()))\n    .sum();\n</code></pre> <p>Why It Matters:</p> <ul> <li> <p>Adds new operations without modifying element classes.</p> </li> <li> <p>Separates algorithms from data structures, supporting open/closed.</p> </li> </ul>"},{"location":"DSAyy/OS/","title":"OS","text":""},{"location":"DSAyy/OS/#operating-systems-interview-prep","title":"Operating Systems Interview Prep","text":""},{"location":"DSAyy/OS/#index","title":"Index","text":"<ol> <li> <p>Process &amp; Thread Management</p> </li> <li> <p>CPU Scheduling</p> </li> <li> <p>Memory Management</p> </li> <li> <p>Process Synchronization &amp; Concurrency</p> </li> <li> <p>Deadlocks</p> </li> <li> <p>File Systems</p> </li> <li> <p>I/O &amp; Device Management</p> </li> <li> <p>OS Structures &amp; System Calls</p> </li> <li> <p>Security &amp; Protection</p> </li> <li> <p>Virtualization &amp; Distributed OS</p> </li> </ol>"},{"location":"DSAyy/OS/#1-process-thread-management","title":"1. Process &amp; Thread Management","text":""},{"location":"DSAyy/OS/#what-is-a-process","title":"What Is a Process?","text":"<ul> <li> <p>Definition: An instance of a program in execution, with its own address space, resources, and execution context.</p> </li> <li> <p>Process Control Block (PCB): OS data structure containing PID, state, CPU registers, memory pointers, I/O info, accounting.</p> </li> <li> <p>Process States:</p> <ol> <li>New \u2192 2. Ready \u2192 3. Running \u2192 4. Blocked \u2192 back to Ready \u2192 Terminated.</li> </ol> </li> <li> <p>Process Creation (Unix example):</p> <pre><code>pid_t pid = fork();\nif (pid == 0) {\n  // child process\n  execve(...);\n} else {\n  // parent continues\n}\n</code></pre> </li> </ul>"},{"location":"DSAyy/OS/#threads-vs-processes","title":"Threads vs. Processes","text":"Aspect Process Thread Address Space Own memory space Shared within process Overhead High (context switch, memory) Low Communication IPC (pipes, sockets, shared mem) Direct via shared vars <ul> <li> <p>Types of Threads:</p> <ul> <li> <p>Kernel Threads (managed by OS).</p> </li> <li> <p>User Threads (managed by a runtime library).</p> </li> <li> <p>Hybrid (both).</p> </li> </ul> </li> </ul>"},{"location":"DSAyy/OS/#context-switch","title":"Context Switch","text":"<ul> <li> <p>What Happens: Save CPU registers to PCB of old process; load registers from PCB of next process.</p> </li> <li> <p>Cost: Hundreds to thousands of CPU cycles.</p> </li> </ul>"},{"location":"DSAyy/OS/#common-interview-queries","title":"Common Interview Queries","text":"<ul> <li> <p>\u201cDescribe the contents of a PCB.\u201d</p> </li> <li> <p>\u201cExplain the difference between preemptive and non\u2011preemptive context switch.\u201d</p> </li> <li> <p>\u201cHow does <code>fork()</code> differ from <code>exec()</code> in Unix?\u201d</p> </li> <li> <p>\u201cWhen would you use threads over processes?\u201d</p> </li> <li> <p>Whiteboard Exercise: Draw the process state diagram and show transitions on I/O request and completion.</p> </li> </ul>"},{"location":"DSAyy/OS/#2-cpu-scheduling","title":"2. CPU Scheduling","text":""},{"location":"DSAyy/OS/#scheduling-criteria","title":"Scheduling Criteria","text":"<ul> <li> <p>CPU Utilization: Keep CPU busy \u2265 90%.</p> </li> <li> <p>Throughput: Processes completed per unit time.</p> </li> <li> <p>Turnaround Time: Finish \u2212 Submit time.</p> </li> <li> <p>Waiting Time: Time spent in the ready queue.</p> </li> <li> <p>Response Time: Time from submission to first response.</p> </li> </ul>"},{"location":"DSAyy/OS/#common-scheduling-algorithms","title":"Common Scheduling Algorithms","text":"<ol> <li> <p>FCFS (First\u2011Come, First\u2011Served)</p> <ul> <li> <p>Simple queue.</p> </li> <li> <p>Drawback: Convoy effect; long jobs delay short ones.</p> </li> </ul> </li> <li> <p>SJF (Shortest Job First)</p> <ul> <li> <p>Chooses process with smallest next CPU burst.</p> </li> <li> <p>Optimal for average waiting time but needs burst prediction.</p> </li> </ul> </li> <li> <p>Priority Scheduling</p> <ul> <li> <p>Each process has priority; lower priority may starve.</p> </li> <li> <p>Solution: Aging (increase priority over time).</p> </li> </ul> </li> <li> <p>Round Robin (RR)</p> <ul> <li> <p>Time quantum q; processes cycle through ready queue.</p> </li> <li> <p>q too small \u2192 too many context switches; too large \u2192 approximates FCFS.</p> </li> </ul> </li> <li> <p>Multilevel Queue</p> <ul> <li>Separate queues for foreground (RR) vs. background (FCFS).</li> </ul> </li> <li> <p>Multilevel Feedback Queue</p> <ul> <li>Processes can move between queues based on their behavior (I/O\u2011bound vs. CPU\u2011bound).</li> </ul> </li> </ol>"},{"location":"DSAyy/OS/#example-rr-calculation","title":"Example: RR Calculation","text":"<p>Given processes P1\u2013P3 with burst times (5, 3, 8) and quantum = 2:</p> Time Running Ready Queue 0\u20132 P1 P2, P3 2\u20134 P2 P3, P1(3 remains) 4\u20136 P3 P1(3), P2(1) \u2026 \u2026 \u2026 <p>Compute waiting and turnaround times from the Gantt chart.</p>"},{"location":"DSAyy/OS/#common-interview-queries_1","title":"Common Interview Queries","text":"<ul> <li> <p>\u201cHow do you compute average waiting time for these algorithms?\u201d</p> </li> <li> <p>\u201cExplain how aging prevents starvation in priority scheduling.\u201d</p> </li> <li> <p>\u201cWhat\u2019s the effect of quantum size in Round Robin?\u201d</p> </li> <li> <p>\u201cDesign a hybrid scheduler for an interactive system.\u201d</p> </li> </ul>"},{"location":"DSAyy/OS/#1-cpu-scheduling-roundrobin-metrics","title":"1. CPU Scheduling: Round\u2011Robin Metrics","text":"<p>Q: Given four processes with arrival time &amp; CPU burst (in ms):</p> <pre><code>P1: (AT=0, BT=5)  \nP2: (AT=1, BT=3)  \nP3: (AT=2, BT=8)  \nP4: (AT=3, BT=6)\n</code></pre> <p>Using Round\u2011Robin with time quantum = 4\u202fms, draw the Gantt chart, then compute each process\u2019s waiting time and turnaround time, and the average of each.</p> <ol> <li> <p>Gantt Chart Construction</p> <ul> <li> <p>At t=0: only P1\u2192 runs 4\u202fms \u2192 [0\u20134]</p> </li> <li> <p>t=4: P1 has 1\u202fms remaining; ready queue = {P2, P3, P4, P1}</p> </li> <li> <p>t=4\u20137: P2 (entire 3\u202fms) \u2192 completes at 7</p> </li> <li> <p>t=7\u201311: P3 runs 4\u202fms (4\u202fms remaining)</p> </li> <li> <p>t=11\u201315: P4 runs 4\u202fms (2\u202fms remaining)</p> </li> <li> <p>t=15\u201316: P1 runs final 1\u202fms \u2192 completes at 16</p> </li> <li> <p>t=16\u201320: P3 runs final 4\u202fms \u2192 completes at 20</p> </li> <li> <p>t=20\u201322: P4 runs final 2\u202fms \u2192 completes at 22</p> </li> </ul> <p>Gantt:</p> <pre><code>|P1|P2|P3|P4|P1|P3|P4|\n 0  4  7 11 15 16 20 22\n</code></pre> </li> <li> <p>Turnaround Time (TAT = completion \u2212 arrival)</p> <ul> <li> <p>TAT\u2081 = 16 \u2212 0 = 16</p> </li> <li> <p>TAT\u2082 = 7 \u2212 1 = 6</p> </li> <li> <p>TAT\u2083 = 20 \u2212 2 = 18</p> </li> <li> <p>TAT\u2084 = 22 \u2212 3 = 19</p> </li> </ul> </li> <li> <p>Waiting Time (WT = TAT \u2212 burst)</p> <ul> <li> <p>WT\u2081 = 16 \u2212 5 = 11</p> </li> <li> <p>WT\u2082 = 6 \u2212 3 = 3</p> </li> <li> <p>WT\u2083 = 18 \u2212 8 = 10</p> </li> <li> <p>WT\u2084 = 19 \u2212 6 = 13</p> </li> </ul> </li> <li> <p>Averages</p> <ul> <li> <p>Avg TAT = (16 + 6 + 18 + 19) / 4 = 59 / 4 = 14.75\u202fms</p> </li> <li> <p>Avg WT = (11 + 3 + 10 + 13) / 4 = 37 / 4 = 9.25\u202fms</p> </li> </ul> </li> </ol> <p>Why it matters: Demonstrates handling of time\u2011slice preemption and how RR balances fairness vs. context\u2011switch overhead.</p>"},{"location":"DSAyy/OS/#2-page-replacement-fifo-lru-opt","title":"2. Page Replacement: FIFO, LRU &amp; OPT","text":"<p>Q: For the reference string</p> <pre><code>7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2\n</code></pre> <p>and 3 page frames, calculate the total page faults under:</p> <ol> <li> <p>FIFO</p> </li> <li> <p>LRU</p> </li> <li> <p>OPT (Optimal).</p> </li> </ol> Ref Frame State (FIFO) Fault? Frame State (LRU) Fault? Frame State (OPT) Fault? 7 [7,\u2013,\u2013] Y [7,\u2013,\u2013] Y [7,\u2013,\u2013] Y 0 [7,0,\u2013] Y [7,0,\u2013] Y [7,0,\u2013] Y 1 [7,0,1] Y [7,0,1] Y [7,0,1] Y 2 [2,0,1] (evict 7) Y [2,0,1] (evict 7) Y [2,0,1] (evict 7) Y 0 [2,0,1] N [2,0,1] N [2,0,1] N 3 [3,0,1] (evict 2) Y [3,0,1] (evict 2) Y [3,0,1] (evict 2) Y 0 [3,0,1] N [3,0,1] N [3,0,1] N 4 [4,0,1] (evict 3) Y [4,0,1] (evict 3) Y [4,0,1] (evict 1) Y 2 [4,2,1] (evict 0) Y [4,2,1] (evict 0) Y [4,2,1] (evict 0) Y 3 [4,2,3] (evict 1) Y [4,2,3] (evict 1) Y [4,2,3] (evict 4) Y 0 [0,2,3] (evict 4) Y [0,2,3] (evict 4) Y [0,2,3] (evict 2) Y 3 [0,2,3] N [0,2,3] N [0,2,3] N 2 [0,2,3] N [0,2,3] N [0,2,3] N <ul> <li> <p>FIFO faults: 9</p> </li> <li> <p>LRU faults: 9</p> </li> <li> <p>OPT faults: 8</p> </li> </ul> <p>Why it matters: Shows trade\u2011offs between implementability (FIFO), recency awareness (LRU), and theoretical optimality (OPT).</p>"},{"location":"DSAyy/OS/#3-producerconsumer-with-semaphores","title":"3. Producer\u2013Consumer with Semaphores","text":"<p>Q: Write pseudocode using semaphores to solve the bounded buffer Producer\u2013Consumer problem (one producer, one consumer, buffer size = N).</p> <pre><code>semaphore empty = N;        // counts empty slots\nsemaphore full  = 0;        // counts filled slots\nsemaphore mutex = 1;        // binary mutual exclusion\nbuffer B[N];\nint in = 0, out = 0;\n\n// Producer\nvoid produce(item x) {\n  empty.wait();             // wait for empty slot\n  mutex.wait();             // enter critical section\n    B[in] = x;\n    in = (in + 1) % N;\n  mutex.signal();           // exit critical section\n  full.signal();            // increment full count\n}\n\n// Consumer\nitem consume() {\n  full.wait();              // wait for filled slot\n  mutex.wait();             // enter critical section\n    x = B[out];\n    out = (out + 1) % N;\n  mutex.signal();           // exit critical section\n  empty.signal();           // increment empty count\n  return x;\n}\n</code></pre> <p>Explanation:</p> <ul> <li> <p><code>empty</code> ensures the producer blocks when buffer is full.</p> </li> <li> <p><code>full</code> ensures the consumer blocks when buffer is empty.</p> </li> <li> <p><code>mutex</code> provides mutual exclusion on buffer indices.</p> </li> </ul> <p>Why it matters: Core concurrency problem\u2014tests understanding of semaphores, mutual exclusion, and deadlock avoidance.</p>"},{"location":"DSAyy/OS/#4-readerswriters-second-problem","title":"4. Readers\u2013Writers (Second Problem)","text":"<p>Q: Provide a solution to the \u201csecond\u201d Readers\u2013Writers problem (no writer should starve).</p> <pre><code>semaphore rw_mutex = 1;       // for writers\nsemaphore mutex   = 1;       // for reader count\nsemaphore queue    = 1;       // FIFO queue for fairness\nint reader_count = 0;\n\n// Reader\nvoid reader() {\n  queue.wait();               // join the queue\n  mutex.wait();               // protect reader_count\n    if (++reader_count == 1)\n      rw_mutex.wait();        // first reader locks out writers\n  mutex.signal();\n  queue.signal();\n\n  // --- reading happens ---\n\n  mutex.wait();\n    if (--reader_count == 0)\n      rw_mutex.signal();      // last reader releases writers\n  mutex.signal();\n}\n\n// Writer\nvoid writer() {\n  queue.wait();               // join the queue\n  rw_mutex.wait();            // exclusive access\n  queue.signal();\n\n  // --- writing happens ---\n\n  rw_mutex.signal();\n}\n</code></pre> <p>Why it works:</p> <ul> <li> <p><code>queue</code> semaphore enforces arrival order, preventing writer starvation.</p> </li> <li> <p>First/last reader logic allows multiple readers concurrently while blocking writers.</p> </li> </ul> <p>Why it matters: Demonstrates handling fairness and starvation in concurrent access patterns.</p>"},{"location":"DSAyy/OS/#5-deadlock-detection-bankers-algorithm","title":"5. Deadlock Detection: Banker's Algorithm","text":"<p>Q: Given 3 resource types A, B, C and 5 processes with:</p> <ul> <li> <p>Available = [3,\u202f3,\u202f2]</p> </li> <li> <p>Max and Allocation matrices:</p> </li> </ul> Proc Max Alloc P0 [7,5,3] [0,1,0] P1 [3,2,2] [2,0,0] P2 [9,0,2] [3,0,2] P3 [2,2,2] [2,1,1] P4 [4,3,3] [0,0,2] <p>Determine if the system is in a safe state, and if so, give one safe sequence.</p> <ol> <li>Compute Need = Max \u2212 Alloc:</li> </ol> Proc Need P0 [7,4,3] P1 [1,2,2] P2 [6,0,0] P3 [0,1,1] P4 [4,3,1] <ol> <li> <p>Find safe sequence via \u201cwork &amp; finish\u201d</p> <ul> <li> <p>Work = Available = [3,3,2]</p> </li> <li> <p>Look for a process whose Need \u2264 Work:</p> <ul> <li> <p>P1: [1,2,2] \u2264 [3,3,2]? Yes \u2192 Work += Alloc\u2081 = [3+2,3+0,2+0] = [5,3,2]; Finish\u2081= true</p> </li> <li> <p>P3: [0,1,1] \u2264 [5,3,2]? Yes \u2192 Work += Alloc\u2083 = [5+2,3+1,2+1] = [7,4,3]; Finish\u2083= true</p> </li> <li> <p>P0: [7,4,3] \u2264 [7,4,3]? Yes \u2192 Work += Alloc\u2080 = [7+0,4+1,3+0] = [7,5,3]; Finish\u2080= true</p> </li> <li> <p>P2: [6,0,0] \u2264 [7,5,3]? Yes \u2192 Work += Alloc\u2082 = [7+3,5+0,3+2] = [10,5,5]; Finish\u2082= true</p> </li> <li> <p>P4: [4,3,1] \u2264 [10,5,5]? Yes \u2192 Work += Alloc\u2084 = [10+0,5+0,5+2] = [10,5,7]; Finish\u2084= true</p> </li> </ul> </li> </ul> </li> <li> <p>Safe Sequence: \u27e8P1, P3, P0, P2, P4\u27e9 (one valid example)</p> </li> </ol> <p>Why it matters: Shows ability to detect safe states and prevent deadlocks in resource\u2011allocation systems.</p>"},{"location":"DSAyy/OS/#6-twolevel-paging-address-translation","title":"6. Two\u2011Level Paging Address Translation","text":"<p>Q: A system uses 32\u2011bit virtual addresses, 4\u202fKB pages, and a two\u2011level page table. Both levels use 10\u202fbits to index (so 12\u202fbit offset). Given a virtual address <code>0xCAFEBABE</code>, show how you\u2019d extract:</p> <ol> <li> <p>Level\u20111 index</p> </li> <li> <p>Level\u20112 index</p> </li> <li> <p>Offset     And, assuming the L1 entry for that index points to a second\u2011level table at physical frame <code>0x00123</code>, and the L2 entry for the L2 index contains physical frame <code>0x00456</code>, compute the final physical address.</p> </li> <li> <p>Break the 32\u2011bit VA</p> <ul> <li> <p>Offset = low 12\u202fbits = <code>0xABE</code> (<code>0xCAFEBABE &amp; 0xFFF = 0xABE</code>)</p> </li> <li> <p>L2 index = next 10\u202fbits = bits [12..21]</p> <pre><code>0xCAFEBABE &gt;&gt; 12 = 0xCAFEB (20\u202fbits)  \n0xCAFEB &amp; 0x3FF = 0x2EB  \n</code></pre> </li> <li> <p>L1 index = bits [22..31] = top 10\u202fbits of VA</p> <pre><code>0xCAFEBABE &gt;&gt; 22 = 0x32  (decimal\u00a050)  \n</code></pre> </li> </ul> </li> <li> <p>Walk page tables</p> <ul> <li> <p>L1[0x32] \u2192 pointer to second\u2011level at PFN <code>0x00123</code></p> </li> <li> <p>L2 table base = <code>0x00123 &lt;&lt; 12</code> = <code>0x00123000</code></p> </li> <li> <p>L2[0x2EB] \u2192 PFN <code>0x00456</code></p> </li> </ul> </li> <li> <p>Final physical address = <code>(0x00456 &lt;&lt; 12) | 0xABE</code></p> <pre><code>0x00456 &lt;&lt; 12 = 0x456000\n+ 0x00ABE      = 0x456ABE\n</code></pre> </li> </ol> <p>So VA <code>0xCAFEBABE</code> maps to 0x00456ABE in physical memory.</p> <p>Why it matters: Two\u2011level (or multi\u2011level) page tables scale to large address spaces without huge contiguous tables, and VA\u2192PA translation is fundamental to virtual memory.</p>"},{"location":"DSAyy/OS/#7-clock-secondchance-page-replacement","title":"7. Clock (Second\u2011Chance) Page Replacement","text":"<p>Q: Simulate the Clock algorithm for the reference string</p> <pre><code>1, 2, 3, 2, 4, 1, 5, 2, 1, 2, 3, 4\n</code></pre> <p>with 3 frames. Show pointer movements, reference bits, and count page faults.</p> <ul> <li> <p>Initialize frames = [\u2013,\u2013,\u2013], ref\u2011bits = [0,0,0], hand at frame\u202f0.</p> </li> <li> <p>Step\u2011by\u2011step:</p> <ol> <li> <p>1 \u2192 fault; place in f0; bit0=1; hand\u2192f1</p> </li> <li> <p>2 \u2192 fault; place in f1; bit1=1; hand\u2192f2</p> </li> <li> <p>3 \u2192 fault; place in f2; bit2=1; hand\u2192f0</p> </li> <li> <p>2 \u2192 hit (bit1=1\u2192refresh bit1=1); no fault; hand stays</p> </li> <li> <p>4 \u2192 fault</p> <ul> <li> <p>hand@f0: bit0=1\u2192clear bit0, advance\u2192f1</p> </li> <li> <p>f1: bit1=1\u2192clear, advance\u2192f2</p> </li> <li> <p>f2: bit2=1\u2192clear, advance\u2192f0</p> </li> <li> <p>f0: bit0=0\u2192evict 1, place 4, bit0=1; advance\u2192f1</p> </li> </ul> </li> <li> <p>1 \u2192 fault</p> <ul> <li>hand@f1: bit1=0\u2192evict 2, place 1, bit1=1; hand\u2192f2</li> </ul> </li> <li> <p>5 \u2192 fault</p> <ul> <li>hand@f2: bit2=0\u2192evict 3, place 5, bit2=1; hand\u2192f0</li> </ul> </li> <li> <p>2 \u2192 fault</p> <ul> <li> <p>f0: bit0=1\u2192clear\u2192f1</p> </li> <li> <p>f1: bit1=1\u2192clear\u2192f2</p> </li> <li> <p>f2: bit2=1\u2192clear\u2192f0</p> </li> <li> <p>f0: bit0=0\u2192evict 4; place 2; bit0=1; hand\u2192f1</p> </li> </ul> </li> <li> <p>1 \u2192 hit (frame\u202f1), bit1=1</p> </li> </ol> </li> <li> <p>2 \u2192 hit (frame\u202f0), bit0=1</p> </li> <li> <p>3 \u2192 fault</p> <ul> <li> <p>f1: bit1=1\u2192clear\u2192f2</p> </li> <li> <p>f2: bit2=0\u2192evict 5; place\u00a03; bit2=1; hand\u2192f0</p> </li> </ul> </li> <li> <p>4 \u2192 fault</p> <ul> <li> <p>f0: bit0=1\u2192clear\u2192f1</p> </li> <li> <p>f1: bit1=0\u2192evict\u00a01; place\u00a04; bit1=1; hand\u2192f2</p> </li> </ul> </li> <li> <p>Total page faults: 9</p> </li> </ul> <p>Why it matters: Clock approximates LRU with O(1) overhead, essential for OSes to manage memory efficiently without full recency lists.</p>"},{"location":"DSAyy/OS/#8-workingset-thrashing-detection","title":"8. Working\u2011Set &amp; Thrashing Detection","text":"<p>Q: Explain how the Working\u2011Set model can be used to detect and avoid thrashing. Given a process\u2019s page\u2011reference string and window \u0394=4, show how you\u2019d compute the working set over time and decide if it exceeds available frames (M=3).</p> <p>Reference: <code>A B C A B D A C B E</code></p> <ol> <li> <p>Working\u2011Set WS(t,\u202f\u0394) = set of distinct pages referenced in the last \u0394 references.</p> </li> <li> <p>Slide window (\u0394=4) at each reference:     | t (ref) | Last\u202f4 refs | WS | |WS| |     |---------|------------------|----|------|     | 1 (A) | [A] | {A} | 1 |     | 2 (B) | [A,B] | {A,B}| 2 |     | 3 (C) | [A,B,C] | {A,B,C}|3 |     | 4 (A) | [A,B,C,A] | {A,B,C}|3 |     | 5 (B) | [B,C,A,B] | {A,B,C}|3 |     | 6 (D) | [C,A,B,D] | {A,B,C,D}|4 &gt; M \u21d2 thrashing risk |     | 7 (A) | [A,B,D,A] | {A,B,D,A}|3 |     | 8 (C) | [B,D,A,C] | {A,B,C,D}|4 &gt; M \u21d2 thrashing risk |     | 9 (B) | [D,A,C,B] | {A,B,C,D}|4 &gt; M \u21d2 thrashing risk |     |10 (E) | [A,C,B,E] | {A,B,C,E}|4 &gt; M \u21d2 thrashing risk |</p> </li> <li> <p>Decision: Whenever |WS| &gt; M, the process\u2019s demand exceeds its allocated frames \u2192 risk of thrashing. OS can respond by:</p> <ul> <li> <p>Reduce multiprogramming (swap out some processes).</p> </li> <li> <p>Allocate more frames if available.</p> </li> </ul> </li> </ol> <p>Why it matters: The working\u2011set algorithm formalizes locality; OS can preemptively adjust to avoid the drastic performance drop of thrashing.</p>"},{"location":"DSAyy/OS/#9-disk-scheduling-scan-vs-cscan","title":"9. Disk Scheduling: SCAN vs. C\u2011SCAN","text":"<p>Q: The disk head is at track\u202f50 on a 0\u2013199 track disk. Pending requests:</p> <pre><code>95, 180, 34, 119, 11, 123, 62, 64\n</code></pre> <p>Compute total head movement for:</p> <ol> <li> <p>Elevator (SCAN) moving initially toward track\u202f0</p> </li> <li> <p>Circular SCAN (C\u2011SCAN) toward 0</p> </li> <li> <p>SCAN (toward 0 then back to 199)</p> <ul> <li> <p>Order when moving \u2193: 50 \u2192 34 \u2192 11 \u2192 0 (hit end) \u2192 then \u2191: 62 \u2192 64 \u2192 95 \u2192 119 \u2192 123 \u2192 180</p> </li> <li> <p>Movements:</p> <pre><code>|50\u201334| + |34\u201311| + |11\u20130| + |0\u201362| + |62\u201364| + |64\u201395| + |95\u2013119| + |119\u2013123| + |123\u2013180|\n= 16 + 23 + 11 + 62 + 2 + 31 + 24 + 4 + 57\n= 230 tracks\n</code></pre> </li> </ul> </li> <li> <p>C\u2011SCAN (toward 0, jump to 199, then toward 0 again)</p> <ul> <li> <p>\u2193: 50 \u2192 34 \u2192 11 \u2192 0</p> </li> <li> <p>Jump: 0 \u2192 199 (no count)</p> </li> <li> <p>\u2193 again: 199 \u2192 180 \u2192 123 \u2192 119 \u2192 95 \u2192 64 \u2192 62</p> </li> <li> <p>Movements:</p> <pre><code>|50\u201334| + |34\u201311| + |11\u20130| + (jump) + |199\u2013180| + |180\u2013123| + |123\u2013119|\n+ |119\u201395| + |95\u201364| + |64\u201362|\n= 16 + 23 + 11 + 19 + 57 + 4 + 24 + 31 + 2\n= 187 tracks\n</code></pre> </li> </ul> </li> </ol> <p>Why it matters: SCAN reduces starvation and provides more uniform wait times; C\u2011SCAN gives even better fairness by treating the disk as a circular list.</p>"},{"location":"DSAyy/OS/#10-inode-structure-maximum-file-size","title":"10. Inode Structure &amp; Maximum File Size","text":"<p>Q: A Unix\u2011style inode has 12 direct block pointers, 1 single\u2011indirect, 1 double\u2011indirect, and 1 triple\u2011indirect. Block size = 4\u202fKB, pointer size = 4\u202fbytes. What is the maximum file size supported?</p> <ol> <li> <p>Direct blocks: 12 \u00d7 4\u202fKB = 48\u202fKB</p> </li> <li> <p>Single\u2011indirect:</p> <ul> <li>One block holds 4\u202fKB/4\u202fB = 1024 pointers \u2192 1024 \u00d7 4\u202fKB = 4\u202fMB</li> </ul> </li> <li> <p>Double\u2011indirect:</p> <ul> <li>1024 pointers to single\u2011indirect blocks, each 1024 pointers to data \u2192 1024\u00b2 \u00d7 4\u202fKB \u2248 4\u202fGB</li> </ul> </li> <li> <p>Triple\u2011indirect:</p> <ul> <li>1024\u00b3 \u00d7 4\u202fKB \u2248 4\u202fTB</li> </ul> </li> </ol> <p>Total max size \u2248</p> <pre><code>48\u202fKB + 4\u202fMB + 4\u202fGB + 4\u202fTB\n\u2248 4\u202fTB + 4\u202fGB + 4\u202fMB + 48\u202fKB\n</code></pre> <p>Roughly 4\u202fterabytes (plus a few\u2011gig overhead).</p> <p>Why it matters: Shows how multi\u2011level indirection scales file size, and demonstrates understanding of pointer arithmetic and FS metadata design.</p>"},{"location":"DSAyy/OS/#11-dining-philosophers-with-monitors","title":"11. Dining Philosophers with Monitors","text":"<p>Q: Five philosophers sit around a table with one fork between each pair. Each must pick up both forks to eat, then put them down. Provide a monitor\u2011based solution that avoids deadlock and starvation.</p> <pre><code>monitor DiningPhilosophers {\n  enum { THINKING, HUNGRY, EATING } state[5];\n  condition self[5];\n\n  // Helper to test if philosopher i can eat\n  void test(int i) {\n    if (state[i] == HUNGRY &amp;&amp;\n        state[(i+4)%5] != EATING &amp;&amp;\n        state[(i+1)%5] != EATING) {\n      state[i] = EATING;\n      self[i].signal();\n    }\n  }\n\n  // Called by philosopher i to pick up forks\n  void pickup(int i) {\n    state[i] = HUNGRY;            \n    test(i);                       // try to go to EATING\n    if (state[i] != EATING)       \n      self[i].wait();             // block until signaled\n  }\n\n  // Called by philosopher i to put down forks\n  void putdown(int i) {\n    state[i] = THINKING;\n    // allow hungry neighbors to eat\n    test((i+4)%5);\n    test((i+1)%5);\n  }\n}\n</code></pre> <ul> <li> <p>Why it works:</p> <ol> <li> <p>Only a philosopher with both neighbors not eating moves to EATING.</p> </li> <li> <p>No circular wait: a waiter (the monitor) ensures at most one transition per test.</p> </li> <li> <p>Starvation is prevented because putting down always tests both neighbors, so waiting philosophers eventually proceed.</p> </li> </ol> </li> </ul> <p>Why it matters: Demonstrates monitor use, condition synchronization, and starvation freedom in classic concurrency.</p>"},{"location":"DSAyy/OS/#12-buddy-memory-allocation-simulation","title":"12. Buddy Memory Allocation Simulation","text":"<p>Q: A system has 1\u202fMB of RAM managed by a buddy allocator with minimum block size 16\u202fKB. Show the free lists after these operations:</p> <ol> <li> <p>Allocate 100\u202fKB (A)</p> </li> <li> <p>Allocate 200\u202fKB (B)</p> </li> <li> <p>Allocate 32\u202fKB (C)</p> </li> <li> <p>Free B</p> </li> <li> <p>Allocate 128\u202fKB (D)</p> </li> <li> <p>Initial: one free block of 1\u202fMB</p> </li> <li> <p>Alloc A (100\u202fKB) \u2192 round up to next power of two = 128\u202fKB.</p> <ul> <li> <p>Split 1\u202fMB \u2192 two 512\u202fKB; split one 512\u202fKB \u2192 two 256\u202fKB; split one 256\u202fKB \u2192 two 128\u202fKB; allocate one 128\u202fKB to A.</p> </li> <li> <p>Free lists: 128\u202fKB: 1 free; 256\u202fKB: 1; 512\u202fKB: 1; 1\u202fMB: 0.</p> </li> </ul> </li> <li> <p>Alloc B (200\u202fKB) \u2192 round up = 256\u202fKB.</p> <ul> <li> <p>Take the free 256\u202fKB block.</p> </li> <li> <p>Free lists: 128\u202fKB: 1; 256\u202fKB: 0; 512\u202fKB: 1.</p> </li> </ul> </li> <li> <p>Alloc C (32\u202fKB) \u2192 round up = 32\u202fKB (fits exactly).</p> <ul> <li> <p>Split 128\u202fKB free \u2192 two 64\u202fKB; split one 64\u202fKB \u2192 two 32\u202fKB; allocate one 32\u202fKB to C.</p> </li> <li> <p>Free lists: 32\u202fKB: 1; 64\u202fKB: 1; 128\u202fKB: 0; 256\u202fKB: 0; 512\u202fKB: 1.</p> </li> </ul> </li> <li> <p>Free B (256\u202fKB)</p> <ul> <li> <p>Return 256\u202fKB; its buddy is the other 256\u202fKB? No, that was split earlier. So 256\u202fKB has no buddy free \u2192 just added.</p> </li> <li> <p>Free lists: 32\u202fKB: 1; 64\u202fKB: 1; 128\u202fKB: 0; 256\u202fKB: 1; 512\u202fKB: 1.</p> </li> </ul> </li> <li> <p>Alloc D (128\u202fKB) \u2192 need 128\u202fKB.</p> <ul> <li> <p>No free 128\u202fKB block: split free 256\u202fKB (the one returned) \u2192 two 128\u202fKB; allocate one to D.</p> </li> <li> <p>Free lists end up: 32\u202fKB: 1; 64\u202fKB: 1; 128\u202fKB: 1; 256\u202fKB: 0; 512\u202fKB: 1.</p> </li> </ul> </li> </ol> <p>Why it matters: Shows how splitting &amp; coalescing maintain power\u2011of\u2011two free lists for fast allocation/deallocation with minimal fragmentation.</p>"},{"location":"DSAyy/OS/#13-slab-allocator-design","title":"13. Slab Allocator Design","text":"<p>Q: Describe how a slab allocator works in a kernel to efficiently allocate frequently used object types (e.g., process structs).</p> <ol> <li> <p>Caches per Object Type</p> <ul> <li>For each type (e.g., <code>task_struct</code>), maintain a cache with multiple slabs.</li> </ul> </li> <li> <p>Slab Structure</p> <ul> <li>A slab is one or more contiguous pages, subdivided into equal\u2011sized objects, with a freelist.</li> </ul> </li> <li> <p>Allocation Path</p> <ul> <li> <p>To allocate an object:</p> <ul> <li> <p>Look in cache\u2019s partial slabs (some free objects).</p> </li> <li> <p>If none, grab a new slab (from buddy allocator), carve objects, add to partial.</p> </li> <li> <p>Pop one object from freelist; serve it.</p> </li> </ul> </li> </ul> </li> <li> <p>Deallocation Path</p> <ul> <li> <p>Return object to its slab\u2019s freelist; if slab becomes fully free, move to empty list.</p> </li> <li> <p>Optionally, free empty slabs back to buddy allocator when under memory pressure.</p> </li> </ul> </li> <li> <p>Benefits</p> <ul> <li> <p>No per\u2011allocation metadata (object size known).</p> </li> <li> <p>Cache coloring and alignment reduce cache\u2011line conflicts.</p> </li> <li> <p>Constructor/Destructor callbacks allow object initialization and cleanup.</p> </li> </ul> </li> </ol> <p>Why it matters: Kernel\u2011level allocator optimized for speed, space, and low fragmentation when allocating many same\u2011sized objects.</p>"},{"location":"DSAyy/OS/#14-tlb-shootdown-in-smp-systems","title":"14. TLB Shootdown in SMP Systems","text":"<p>Q: On an SMP machine, when one CPU updates a page table entry (e.g., unmaps a page), explain how the OS ensures other CPUs\u2019 TLBs don\u2019t hold stale entries.</p> <ol> <li> <p>Local TLB Flush</p> <ul> <li>CPU writing its page tables executes an architecture\u2011specific instruction (e.g., <code>invlpg</code> on x86) to flush its own TLB entry for that VA.</li> </ul> </li> <li> <p>Inter\u2011Processor Interrupt (IPI)</p> <ul> <li>OS sends a TLB shootdown IPI to all other CPUs that might have cached that mapping.</li> </ul> </li> <li> <p>Remote Flush Handlers</p> <ul> <li>Each target CPU\u2019s interrupt handler executes its own <code>invlpg</code> (or global TLB flush) to invalidate the stale entry.</li> </ul> </li> <li> <p>Synchronization</p> <ul> <li>Originating CPU waits for acknowledgments (IPI completion) before proceeding\u2014ensures all TLBs are coherent.</li> </ul> </li> <li> <p>Optimizations</p> <ul> <li> <p>Batching: coalesce multiple unmaps and send a single IPI for a range.</p> </li> <li> <p>Per\u2011CPU freelists: avoid frequent shootdowns by reusing address space per CPU when possible.</p> </li> </ul> </li> </ol> <p>Why it matters: Critical for correctness in virtual memory on multicore\u2014stale TLB entries can lead to use\u2011after\u2011free or security breaches.</p>"},{"location":"DSAyy/OS/#15-journaling-file-systems-crash-consistency","title":"15. Journaling File Systems &amp; Crash Consistency","text":"<p>Q: Explain how a journaling file system like ext4 uses its journal to ensure consistency, and compare its three journaling modes.</p> <ol> <li> <p>Journal Structure</p> <ul> <li>A circular log where filesystem metadata (and optionally data) updates are recorded before being applied.</li> </ul> </li> <li> <p>Two\u2011Phase Commit</p> <ul> <li> <p>Write intent: log a transaction header + associated blocks.</p> </li> <li> <p>Commit record: mark transaction as committed.</p> </li> <li> <p>Apply: background thread flushes logged changes to their final on\u2011disk locations.</p> </li> <li> <p>Checkpoint: mark journal entries as free for reuse.</p> </li> </ul> </li> <li> <p>Modes</p> <ul> <li> <p>Writeback:</p> <ul> <li>Only metadata is journaled; data blocks may be written after metadata commit \u2192 highest performance, risk of stale data.</li> </ul> </li> <li> <p>Ordered (default):</p> <ul> <li>Metadata journaled; data blocks must be written before metadata commit \u2192 no stale data pointers, balanced performance.</li> </ul> </li> <li> <p>Journal:</p> <ul> <li>Both metadata and data are journaled \u2192 strongest consistency, safest for data, but highest overhead.</li> </ul> </li> </ul> </li> <li> <p>Crash Recovery</p> <ul> <li> <p>On mount after crash, FS scans the journal:</p> <ul> <li> <p>Committed transactions are replayed (redo).</p> </li> <li> <p>Uncommitted or partially committed are discarded.</p> </li> </ul> </li> <li> <p>Ensures on\u2011disk metadata is always in a consistent state.</p> </li> </ul> </li> </ol> <p>Why it matters: Journaling avoids lengthy fsck at boot, guarantees atomic updates, and lets you tune performance vs. safety for a high\u2011volume service like Zomato.</p>"},{"location":"DSAyy/Strings/","title":"Strings","text":""},{"location":"DSAyy/Strings/#palindrome-string","title":"Palindrome String","text":"<p>Given a string, determine if its palindrome.</p> <pre><code>def isPalindrome(A):\n    i = 0\n    j = len(A) - 1\n    while i &lt; j:\n        while i &lt; j and not isalnum(A[i]):\n            i += 1\n        while i &lt; j and not isalnum(A[j]):\n            j -= 1\n        if tolower(A[i]) != tolower(A[j]):\n            return 0\n        i += 1\n        j -= 1\n    return 1\n</code></pre>"},{"location":"DSAyy/Strings/#vowel-and-consonant-substrings","title":"Vowel and Consonant Substrings","text":"<p>Given string A of lowercase characters. Find the number of substrings in A which start with a vowel and end with a consonant, or vice-versa.</p> <pre><code>def substrings(A):\n    MOD = 10**9 + 7\n    V = 0 #vowels\n    for char in A:\n        if char in ['a', 'e', 'i', 'o', 'u']:\n            V += 1\n    C = len(A) - V\n    return (V * C) % MOD\n</code></pre>"},{"location":"DSAyy/Strings/#remove-consecutive-characters","title":"Remove Consecutive Characters","text":"<p>Given a string, and an int <code>B</code>, remove all consecutive identical characters that have length exactly <code>B</code>.</p> <p>Ex: <code>aabbccd</code> Output = <code>d</code></p> <pre><code>def remCon(A,B):\n    runs = []\n    for c in A:\n        if not runs or runs[-1][0] != c: #if its not the same as last seen char\n            runs.append([c,1])\n        else:\n            runs[-1][1] += 1\n    ans = \"\"\n    for char, count in runs:\n        if count == B:\n            continue\n        ans += char * count\n    return ans\n</code></pre>"},{"location":"DSAyy/Strings/#serialize","title":"Serialize","text":"<p>Given an array of strings. Serialize the array and return the resulting substring.</p> <p>To serialize, append: 1. og string s 2. its length 3. a delimiter(~).</p> <p>Ex: \"interviewbit\" = \"interviewbit12\"</p> <p>[<code>scaler</code>,<code>academy</code>] -&gt; scaler6~academy7~</p> <pre><code>def serialize(A):\n    result = \"\"\n    for s in A:\n        result += s\n        result += to_string(len(s))\n        result += '~'\n    return result\n</code></pre>"},{"location":"DSAyy/Strings/#deserialize","title":"Deserialize","text":"<p>Given a serialized string, deserialize it. <pre><code>def deserialize(A):\n    res = []\n    i = 0\n    while i &lt; len(A):\n        #get word\n        j = i\n        while j &lt; len(A) and A[j].isalpha():\n            j += 1\n        #get digit\n        k = j\n        while k &lt; len(A) and A[k].isdigit():\n            k += 1\n        #A[k] should be delimiter\n        res.append(A[i:j])\n        i = k + 1\n    return res\n</code></pre></p>"},{"location":"DSAyy/Strings/#string-and-its-frequency","title":"String and Its Frequency","text":"<p>Given a string of lowercase chars, return a string in which for each character, its total freq is written immediately after its appearance.</p> <p>Ex: <code>abbhuabcfghh</code> Output: <code>a2b3h3u1c1f1g1</code></p> <pre><code>def strFreq(A):\n    freq = [0]*26\n    seen = [False]*26\n    order = []\n    for c in A:\n        idx = ord(c) - ord('a')\n        freq[idx] += 1\n        if not seen[idx]:\n            seen[idx] = True\n            order.append(c)\n    ans = \"\"\n    for c in order:\n        idx = ord(c) - ord('a')\n        ans += c + str(freq[idx])\n    ans\n</code></pre>"},{"location":"DSAyy/Strings/#bulls-and-cows","title":"Bulls and Cows","text":"<p>Write down a secret number, your friend makes a guess (of equal length, all digits). For each guess, provide a hint. - Bulls: Digits that match both value and position. - Cows: Digits in the guess that are in the secret but in the wrong position. - Each digit can be counted only once, as a bull or as a cow. - Output is formatted as \"xAyB\" where \\(x\\) is bulls, and \\(y\\) is cows. - Both strings contain digits only.</p> <p>Input: - secret: string of digits - guess: string of digits Output: - A string of format \"xAyB\"</p> <p>Ex: secret: \"1807\", guess = \"7810\". Output = \"1A3B\"</p> <pre><code>def bullsCows(secret, guess):\n    bulls = 0\n    cows = 0\n    cnt = [0]*10\n    for i in range(len(secret)):\n        s = int(secret[i])\n        g = int(secret[i])\n        if s == g:\n            bulls += 1\n        else:\n            if cnt[g] &gt; 0:\n                cows += 1\n            if cnt[s] &lt; 0:\n                cows += 1\n            cnt[s] += 1\n            cnt[g] -= 1\n    return f\"{bulls}A{cows}B\"\n</code></pre>"},{"location":"DSAyy/Strings/#self-permutation","title":"Self Permutation","text":"<p>Given 2 strings A and B, determine if there exists a permutation where bot A and B are equal.</p> <p>Basically check if they are anagrams.</p> <pre><code>def permuteStrings(A,B):\n    if len(A) != len(B):\n        return 0\n    freq = [0]*26\n    for c in A:\n        freq[ord(c) - ord('a')] += 1\n    for c in B:\n        freq[ord(c) - ord('a')] -= 1\n        if freq[ord(c) - ord('a')] &lt; 0:\n            return 0\n    return 1\n</code></pre>"},{"location":"DSAyy/Strings/#longest-common-prefix","title":"Longest Common Prefix","text":"<p>A = abcde, aefg, asdasd, Output = <code>a</code></p>"},{"location":"DSAyy/Strings/#how","title":"How","text":"<ol> <li>Find length of the shortest string.</li> <li>Stop and return the prefix so far on the first mismatch.</li> </ol> <pre><code>def longestCommonPrefix(A):\n    if not A:\n        return \"\"\n    minLen = min(len(s) for s in A)\n    for i in range(minLen):\n        c = A[0][i]\n        for s in A:\n            if s[i] != c:\n                return A[0][:i]\n    return A[0][:minLen]\n</code></pre>"},{"location":"DSAyy/Strings/#count-and-say","title":"Count and Say","text":"<ol> <li>Start with 1</li> <li>Then say the count and the key of the count.</li> <li>1211 -&gt; 111221</li> <li>21 -&gt; 1211 Given int <code>n</code>, generate the nth term, in the count and say sequence. So</li> <li>n = 2, output = 11</li> <li>n = 5, 111221<ul> <li>1; 11; 21; 1211; 111221</li> <li>Each term describes the previous term. <pre><code>def countAndSay(n):\n    res = \"1\"\n    for seq in range(2,n+1):\n        next = \"\"\n        i = 0\n        while i &lt; len(res):\n            count = 1 #count the freq of cur el\n            while i + 1 &lt; len(res) and res[i] = res[i+1]:\n                i += 1\n                count += 1\n            next += str(count) + res[i] #add it to the res\n            i += 1\n        res = next\n    return res\n</code></pre></li> </ul> </li> </ol>"},{"location":"DSAyy/Strings/#amazing-subarrays","title":"Amazing Subarrays","text":"<p>Given a string, find the num of amazing substrings.</p> <p>Subtring is amazing if it starts with a vowel. Substrings are continuous.</p>"},{"location":"DSAyy/Strings/#how_1","title":"How","text":"<p>For each index i, if \\(A[i]\\) is a vowel, add (n-i) to the answer. Since there are (n-i) substrings starting fron i.</p> <pre><code>def amazingSubs(A):\n    MOD = 10003\n    ans = 0\n    for i,c in enumerate(A):\n        if c.lower() in ['a','e','i','o','u']:\n            ans += len(A) - i\n            if ans &gt;= MOD: ans %= MOD\n    return ans % MOD\n</code></pre>"},{"location":"DSAyy/Strings/#implement-strstr","title":"Implement StrStr","text":"<p>Given a string (haystack) and another string (needle), return the index of the first occurence of <code>B</code> in <code>A</code>, or <code>-1</code> if <code>B</code> does not occur in <code>A</code>.</p>"},{"location":"DSAyy/Strings/#how_2","title":"How","text":"<p>Knuth Morris Pratt algorithm. Precompute an <code>LPS</code> (longest prefix suffix) of the needle in the haystack. Slide this pattern over the haystack, when a mismatch occurs, jump using the LPS array to avoid unnecesarry comparisons.</p> <pre><code>def strStr(A,B):\n    if len(B) == 0:\n        return -1\n    if len(A) == 0 or len(B) &gt; len(A):\n        return -1\n    lps = buildLPS(B)\n    i = j = 0\n    while i &lt; len(A):\n        if A[i] == B[j]:\n            i += 1\n            j += 1\n            if j == len(B):\n                return i - j\n        else:\n            if j != 0:\n                j = lps[j-1]\n            else:\n                i += 1\n    return -1\ndef buildLPS(pat):\n    lps = [0]*len(pat)\n    length = 0 #len of the longest prefix suffix\n    i = 1\n    while i &lt; len(pat):\n        if pat[i] == pat[length]:\n            length += 1\n            lps[i] = length\n            i+= 1\n        else :\n            if length != 0:\n                length = lps[length - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    return lps\n</code></pre>"},{"location":"DSAyy/Strings/#stringoholics","title":"Stringoholics","text":"<p>Given arr of strings, each made only from <code>a</code> and <code>b</code>. At each time i, every string is circularly rotated to the left by (<code>i</code> % <code>length</code>) letters.</p> <p>After some time, a string returns to its original form.</p> <p>Goal: Find the min time <code>t</code> where all strings in A are at their original state simultaneously. Output: t mod \\(10^9 + 7\\) </p> <p>Example: 1. A = a, ababa, aba; Output = 4 2. A = a, aa; Output = 1</p>"},{"location":"DSAyy/Strings/#how_3","title":"How","text":"<ol> <li>For each string , find the first time <code>t</code> such that repeated by that time it returns to its starting form.</li> <li>For each string, its reset period p is found via KMP (smallest period of repetition in the string)</li> <li>For each p, find minimal t such that \\(\\frac{t(t+1)}{2}\\) mod p = 0 (the net number of rotations modulo p is 0)</li> <li>The answer is lcm(all t) (smallest time that aligns)</li> </ol> <pre><code>from math import gcd\nfrom functools import reduce\nMOD = 10**9 + 7\ndef lcm(a,b):\n    return a* b//gcd(a,b)\ndef lcm_list(lst):\n    return reduce(lcm,lst)\ndef buildLPS(s):\n    n = len(s)\n    lps = [0]*n\n    length = 0\n    i = 1\n    while i &lt; n:\n        if s[i] == s[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            if length != 0:\n                length = lps[length - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    return lps\ndef get_period(s):\n    lps = buildLPS(s)\n    n = len(s)\n    length = lps[-1]\n    if length &gt; 0 and n % (n - length) == 0:\n        return n - length\n    else:\n        return n\ndef minimal_t(p):\n    t = 1\n    while (t * (t+1))//2 % p != 0:\n        t += 1\n    return t\ndef stringoholics(A):\n    t_list = []\n    for s in A:\n        p = get_period(s)\n        t = minimal_t(p)\n        t_list.append(t)\n    return lcm_list(t_list) % MOD\n</code></pre>"},{"location":"DSAyy/Strings/#min-characters-to-make-a-string-palindrome","title":"Min Characters to Make a string palindrome.","text":"<p>Given a string, the only allowed operation is to insert chars at the beginning of the string. Find the min chars that must be inserted to make A a palindrome.</p> <p>A = <code>ABC</code>, Output = <code>2</code></p>"},{"location":"DSAyy/Strings/#how_4","title":"How","text":"<p>Intuition - To minimize the insertions, find the longest palindromic prefix of A. - All the characters after this prefix must be mirrored at the front. KMP - Let B be reverse of A - Build T = A + <code>#</code> + reverse(A) - Compute the LPS(T) - L = lps(end) gives length of the longest palindromic prefix in A - answer = n - L, where \\(n = |A|\\) .</p> <pre><code>def buildLPS(s):\n    n = len(s)\n    lps = [0]*n\n    length = 0\n    i = 1\n    while i &lt; n:\n        if s[i] == s[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            if length != 0:\n                length = lps[length - 1]\n            else:\n                lps[i] = 0\n                i += 1\n    return lps\ndef minCharsToMakePalindrome(A):\n    revA = A[::-1]\n    T = A + '#' + revA\n    lps = buildLPS(T)\n    LPS_len = lps[-1]\n    return len(A) - LPS_len\n</code></pre>"},{"location":"DSAyy/Strings/#convert-to-palindrome","title":"Convert to Palindrome","text":"<p>Given a string of lowercase chars, determine if it is possible to make it a palindrome by removing exactly one character.</p> <p>A = <code>abcba</code>, Output = 1</p> <p>A = <code>abecbea</code>, Output = 0</p> <pre><code>def isConvertable(A):\n    l,r = 0, len(A) - 1\n    while l &lt; r:\n        if A[l] == A[r]:\n            l += 1\n            r -= 1\n        else:\n            return isPalindrome(A, l+1, r) or isPalindrome(A,l, r-1)\n    return 1\ndef isPalindrome(A,i,j):\n    while i &lt; j:\n        if A[i] != A[j]: return False\n        i += 1\n        j -= 1\n    return True\n</code></pre>"},{"location":"DSAyy/Strings/#min-appends-for-palindrome","title":"Min Appends for Palindrome","text":"<p>Given a string, find min appends at the end of the string to make it a palindrome.</p>"},{"location":"DSAyy/Strings/#how_5","title":"How","text":"<p>We want to append as little as possible. So find the longest common palindromic suffix of A.</p> <p>Part before this suffix must be mirrored and appended.</p> <p>How do we do this. 1. Let R = reverse(A) 2. Build string T = R + <code>#</code> + A 3. Compute LPS (longest prefix suffix array) for T. 4. L = lps(T.length - 1) is the length of the longest palindromic suffix in A. 5. min appends is n - L</p> <pre><code>def computeLPS(s):\n    lps = [0]*len(s)\n    length = 0 #len of prev longest prefix suffix\n    for i in range(1,len(s)):\n        while length &gt; 0 and s[i] != s[length]:\n            length = lps[length - 1]\n        if s[i] == s[length]:\n            length += 1\n            lps[i] = length\n    return lps\ndef minAppendsForPalindrome(A):\n    R = A[::-1]\n    T = R + '#' + A\n    lps = computeLPS(T)\n    L = lps[-1]\n    return len(A) - L\n</code></pre>"},{"location":"DSAyy/Strings/#min-parentheses","title":"Min Parentheses","text":"<p>Given a string containing bracket sequence or <code>(</code> and <code>)</code>. Find the min number of parenthesis you must add at any position to make A a valid sequence.</p> <pre><code>def minParents(A):\n    open = 0\n    inserts = 0\n    for c in A:\n        if c == '(':\n            open += 1\n        else:\n            if open &gt; 0:\n                open -=1\n            else:\n                inserts += 1\n    return inserts + open\n</code></pre>"},{"location":"DSAyy/Strings/#longest-palindromic-substring-lps","title":"Longest Palindromic Substring (LPS)","text":"<p>Given a string, find and return the longest palindromic substring in A. If multiple answers exist, return the one with least starting index.</p>"},{"location":"DSAyy/Strings/#how_6","title":"How","text":"<ul> <li>For every center, expand outwards while left/right match.</li> <li>Track the longest palindrome seen.</li> <li>Return the first in case of tie.</li> </ul> <pre><code>def longestPalindrome(A):\n    n = len(A)\n    if n == 0: return \"\"\n    bestLen = 1\n    bestStart = 0\n    def expand(left, right):\n        nonlocal bestLen, bestStart\n        while left &gt;= 0 and right &lt; n and A[left] == A[right]:\n            curLen = right - left + 1\n            if curLem &gt; bestLen or (curLen == bestLen and left &lt; bestStart):\n                bestLen = curLen\n                bestStart = left\n            left -=1\n            right += 1\n    for i in range(n):\n        expand(i,i) #odd len palindrome\n        expand(i,i+1)\n    return A[bestStart: bestStart + bestLen]\n</code></pre>"},{"location":"DSAyy/Strings/#salutes","title":"Salutes","text":"<p>Given a string, representing soldiers walking in a hallway: - <code>\u00bf</code> : soldier walking from left to right. - <code>\u00a1</code> : soldier walking right to left. Whenever two soldiers cross, they both salute. Return the total number of salute. <pre><code>def countSalutes(A):\n    rightCount = 0\n    salutes = 0\n    for c in A:\n        if c == '&gt;': rightCount += 1\n        elif c == '&lt;': salutes += rightCount\n    return salutes\n</code></pre></p>"},{"location":"DSAyy/Strings/#integer-to-roman","title":"Integer to Roman","text":"<p>Given a number, convert it to roman numeral.</p> <pre><code>def intToRoman(A):\n    table = [\n        (1000, \"M\"),\n        (900, \"CM\"),\n        (500, \"D\"),\n        (400, \"CD\"),\n        (100, \"C\"),\n        (90, \"XC\"),\n        (50, \"L\"),\n        (40, \"XL\"),\n        (10, \"X\"),\n        (9, \"IX\"),\n        (5, \"V\"),\n        (4, \"IV\"),\n        (1, \"I\")\n    ]\n    res = \"\"\n    for value, symbol in table:\n        while A &gt;= value:\n            res += symbol\n            A -= value\n    return res\n</code></pre>"},{"location":"DSAyy/Strings/#roman-to-integer","title":"Roman to Integer","text":"<pre><code>def romanToInt(A):\n    value = {\n        'I': 1,\n        'V': 5,\n        'X': 10,\n        'L': 50,\n        'C': 100,\n        'D': 500,\n        'M': 1000\n    }\n    res = 0\n    n = len(A)\n    for i in range(n):\n        v = value[A[i]]\n        if i + 1 &lt; n and v &lt; value[A[i+1]]:\n            res -= v\n        else:\n            res += v\n    return res\n</code></pre>"},{"location":"DSAyy/Strings/#add-binary-strings","title":"Add Binary Strings","text":"<p>Given two binary strings, add them and return the result binary string. <pre><code>def addBinary(A,B):\n    i,j = len(A) - 1, len(B) - 1\n    carry = 0\n    res = []\n    while i &gt;= 0 or j &gt;= 0 or carry:\n        total = carry\n        if i &gt;= 0:\n            total += ord(A[i]) - ord('0')\n            i -= 1\n        if j &gt;= 0:\n            total += ord(B[j]) - ord('0')\n            j -= 1\n        res.append(str(total % 2))\n        carry = total // 2\n    result.reverse()\n    return ' '.join(result)\n</code></pre></p>"},{"location":"DSAyy/Strings/#power-of-2","title":"Power of 2","text":"<p>Given a string representing non-negative int (extremely large). Determine if it can be written as a power of 2 : \\(2^k\\) for some \\(k \\geq 1\\) How: 1. Simulate division by 2, use a big integer algorithm.     - Remove leading zeroes.     - If string is <code>1</code>, okk, else <code>0</code>? \\(2^0\\) is not allowed.     - Convert string to vector of base \\(10^9\\) chunks     - While number is not 1, check for oddness.     - If divisible by 2 down to 1, it is a power of 2. <pre><code>def isPowerOfTwoString(A):\n    A = A.lstrip('0')\n    if A == \"1\": return False\n    #convert A into base-1e9 chunks (little endian)\n    def parse_chunks(A):\n        chunks = []\n        while s:\n            s, chunk = s[:-9], s[-9:]\n            chunks.append(int(chunk))\n        return chunks\n    def remove_leading_zeroes(limbs):\n        while len(limbs) &gt; 1 and limbs[-1] == 0:\n            limbs.pop()\n    def divide_by_two(limbs):\n        carry = 0\n        for i in reversed(range(len(limbs))):\n            current = limbs[i] + carry*10**9\n            limbs[i] = current // 2\n            carry = current % 2\n        remove_leading_zeroes(limbs)\n        return carry #return remainder\n    limbs = parse_chunks(A)\n    while limbs != 0:\n        if limbs[0] % 2 == 1:\n            return False\n        divide_by_two(limbs)\n    return True\n</code></pre></p>"},{"location":"DSAyy/Strings/#multiply-strings","title":"Multiply Strings","text":"<p>Given two numbers as strings, return their product as a string with no leading zeroes.</p>"},{"location":"DSAyy/Strings/#how_7","title":"How","text":"<p>Simulating elementary school multiplication. <pre><code>def multiply(A,B):\n    if A == \"0\" or B == \"0\":\n        return \"0\"\n    m,n = len(A), len(B)\n    res = [0]*(m+n)\n    for i in range(m-1,-1,-1):\n        for j in range(n-1,-1,-1):\n            res[i+j+1] += int(A[i])*int(B[j])\n    #handle carry\n    for k in range(m+n - 1, 0, -1):\n        carry = res[k] // 10\n        res[k] %= 10\n        res[k-1] += carry\n    #no leading zeroes\n    i = 0\n    while i &lt; len(res) and res[i] == 0:\n        i += 1\n    return ''.join(map(str, res[i:]))\n</code></pre></p>"},{"location":"DSAyy/Strings/#convert-the-amount-in-number-to-words","title":"Convert the Amount in Number to Words","text":"<p>Given an amount, write its number name. Check if it matches with B. <pre><code>def solve(A,B):\n    A = lstrip('0') or '0'\n    if A == '0':\n        return 1 if B == 'zero' else 0\n    num = int(A)\n    crores = num // 10**7\n    lakhs = (num // 10**5)% 100\n    thousands = (num // 10**3) % 100\n    rem = num % 1000\n    tok = []\n    def num_to_words(n):\n        units = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\",\n                 \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n                 \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n        tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\",\n                \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n        if n == 0:\n            return \"\"\n        elif n &lt; 20:\n            return units[n]\n        else:\n            return tens[n//10] + (\"-\" + units[n%10] if n % 10 != 0 else \"\")\n    def process_group(value, label):\n        if value:\n            tok.append(num_to_words(value) + '-' + label)\n    process_group(crores,\"crore\")\n    process_group(lakhs,\"lakh\")\n    process_group(thousands,\"thousand\")\n    if rem:\n        hundreds = rem // 100\n        tens_ones = rem % 100\n        part = \"\"\n        if hundreds:\n            part += num_to_words(hundreds) + \"-hundred\"\n            if tens_ones:\n                part += num_to_words(tens_ones)\n        if part:\n            tok.append(part)\n    formed = '-'.join(tok)\n    return 1 if formed == B else 0\n</code></pre></p>"},{"location":"DSAyy/Strings/#compare-version-numbes","title":"Compare Version Numbes","text":"<p>Given two versions of number <code>A</code> and <code>B</code>, Compare them if: - Return \\(1\\) if \\(A &gt; B\\) - Return \\(-1\\) if \\(A &lt; B\\) - Return \\(0\\) if they are equal</p> <ol> <li>Version contains digits and <code>.</code></li> <li>Can have leading zeroes</li> <li>Compare them left to right</li> <li>MIssing are treated as 0</li> </ol> <p>Example: <code>\"0.1\" &lt; \"1.1\" &lt; \"1.2\" &lt; \"1.13\" &lt; \"1.13.4\"</code></p>"},{"location":"DSAyy/Strings/#how_8","title":"How","text":"<ul> <li>Parse each segment between the dots</li> <li>Remove leading zeroes</li> <li>Compare int values of each segment.</li> <li>If one string has more segments, the missing one is treated as <code>0</code>.</li> </ul> <pre><code>def compareVersion(A,B):\n    i,j = 0,0\n    n,m = len(A), len(B)\n    while i &lt; n and j &lt; m:\n        #parse next numeric segment from A\n        segA = \"\"\n        while i &lt; n and A[i] != '.':\n            segA += A[i]\n            i += 1\n        i+= 1 #skip the .\n\n        segB = \"\"\n        while j &lt; m and B[j] != '.':\n            segB += B[j]\n            j += 1\n        j += 1 #skip .\n\n        segA = segA.lstrip('0') or '0'\n        segB = segB.lstrip('0') or '0'\n        if len(segA) &lt; len(segB):\n            return -1\n        elif len(segA) &gt; len(segB):\n            return 1\n        else:\n            #lexographical comparison\n            if segA &lt; segB:\n                return -1\n            elif segA &gt; segB:\n                return 1\n    return 0\n</code></pre>"},{"location":"DSAyy/Strings/#atoi-string-to-int-conversion","title":"Atoi (string to int conversion)","text":"<p>Return INT_MAX or INT_MIN if overflow. <pre><code>def atoi(A):\n    INT_MAX = 2**31 - 1\n    INT_MIN = -2**31\n    i = 0\n    n = len(A)\n    res = 0\n    sign = 1\n    #slip leading whitespace\n    while i &lt; n and A[i].isspace():\n        i += 1\n    #parse sign if there is\n    if i &lt; n and A[i] in ['+', '-']:\n        sign = -1 if A[i] == 'i' else 1\n        i += 1\n    digit_seen = False\n    while i &lt; n and A[i].isdigit():\n        digit = int(A[i])\n        digit_seen = True\n        #check overflow\n        if result &gt; (INT_MAX - digit) // 10:\n            return INT_MAX if sign == 1 else INT_MIN\n        result = result*10 + digit\n        i += 1\n    if not digit_seen:\n        return 0\n    return sign* result\n</code></pre></p>"},{"location":"DSAyy/Strings/#valid-ip-addresses","title":"Valid IP Addresses","text":"<p>Given a string only containing digits, restore it by returning all possible valid IP address combinations, in sorted order.</p> <p>Valid IP is in the form of A.B.C.D, where each segment is an int from 0 to 255, with: - No segment has leading zeroes, except itself is <code>0</code> - 1 \\(\\leq |A| \\leq 12\\)</p>"},{"location":"DSAyy/Strings/#how_9","title":"How","text":"<p>DFS - At each step, choose next segment of length \\(\\leq 3\\) digits - Check if the segment is valid (value, and no leading zeroes) - Recur to form the next segment - WHen 4 segments formed, all digs used, add to the result.</p> <p>Prune early if it is impossible to form 4 segments.</p> <pre><code>def restoreIPAddresses(A):\n    result = []\n    def dfs(pos,segs):\n        if len(segs) == 4:\n            if pos == len(A):\n                result.append('.'.join(segs))\n            return\n        for length in [1,2,3]:\n            if pos + length &gt; len(A):\n                break\n            segment = A[pos:pos + length]\n            #no leading zeroes\n            if segment[0] == '0' and length &gt; 1:\n                break\n            if int(segment) &gt; 255:\n                continue\n            dfs(pos + length, segs + [segment])\n    dfs(0,[])\n    result.sort()\n    return result\n</code></pre>"},{"location":"DSAyy/Strings/#length-of-last-word","title":"Length of Last Word","text":"<p>Given a string of alphabets and space characters, return the length of the last word in the string.</p> <pre><code>def lenOfLastWord(A):\n    i = len(A) - 1\n    #skip trailing spaces\n    while i &gt;= 0 and A[i] == ' ':\n        i -= 1\n    length = 0\n    #count chars\n    while i &gt;= 0 and A[i] != ' ':\n        length += 1\n        i -=1\n    return length\n</code></pre>"},{"location":"DSAyy/Strings/#reverse-the-string-word-by-word","title":"Reverse The String (Word by Word)","text":"<p>Given string, return the string reversed word by word. String will be a sentence.</p> <p>A = teri maa ki chut, Output: chut ki maa teri</p> <p>Output must have no leading or trailing spaces. Multiple space becomes single space.</p> <pre><code>def reversedWords(A):\n    i = len(A) - 1\n    result = \"\"\n    while i &gt;= 0:\n        #skip trail zeroes\n        while i &gt;= 0 and A[i] == ' ':\n            i -= 1\n        if i &lt; 0:\n            break\n        end= i\n        #move to the start of the word\n        while i &gt;= 0 and A[i] != ' ':\n            i -= 1\n        start = i + 1\n        if result:  result += ' '\n        result += A[start:end + 1]\n    return result   \n</code></pre>"},{"location":"DSAyy/Strings/#zigzag-string-conversion","title":"Zigzag String Conversion","text":"<p>Given a string and an int, write A in zigzag order on B rows and then read the pattern row by row.</p> <p>A = \"PAYPALISHIRING\", B = 3, Output = \"PAHNAPLSIIGYIR\" How? Row 0: P   A   H   N Row 1: A P L S I I G Row 2: Y   I   R</p>"},{"location":"DSAyy/Strings/#how_10","title":"How","text":"<p>Simulate writing in zigzag move down row by row, if bottom, change the direction</p> <pre><code>def convert(A,B):\n    if B &lt;= 1 or B &gt;= len(A):\n        return A\n    rows = [\"\"]*B\n    cur = 0\n    direction = 1\n    for c in A:\n        rows[cur] += c\n        if cur == 0:\n            direction = 1\n        elif curr == B-1:\n            direction = -1\n        cur += direction\n    return ''.join(rows)\n</code></pre>"},{"location":"DSAyy/Strings/#justified-text","title":"Justified Text","text":"<p>Justifiy the string (indentation). Format such that: - Each line has exactly B characters. - Each line is left and right justified. - Distribute spaces as evenly as possible between words     - if uneven, left gets more spaces - Last line is left justified.  - No word is ever split, must fit in B.</p> <p>Input: A: list of strings, B = line width.</p> <p>Output: List of justified lines, each of len B.</p>"},{"location":"DSAyy/Strings/#how_11","title":"How","text":"<ul> <li>Greedily fit as many words as possible per line.</li> <li>For each line<ul> <li>IF it is the last line or has only one word: left-justify, pad right.</li> <li>Else: distribute space evenly, starting from left to right.</li> </ul> </li> </ul> <pre><code>def fullJustify(words, L):\n    result = []\n    idx = 0\n    while idx &lt; len(words):\n        start = idx\n        lineLen = len(words[idx])\n        idx += 1\n        while idx &lt; len(words) and lineLen + 1 + len(words[idx]) &lt;= L:\n            lineLen += 1 + len(words[idx])\n            idx += 1\n        cnt = idx - start\n        isLast = idx == len(words)\n        lineWords = words[start:idx]\n        if cnt == 1 or isLast:\n            line = ' '.join(lineWords).ljust(L)\n        else:\n            totalLen = sum(len(w) for w in lineWords)\n            totalSpaces = L - totalLen\n            gaps = cnt - 1\n            spaceWidth, extra = divmod(totalSpaces, gaps)\n            line = ''\n            for i in range(gaps):\n                line += linewords[i]+' '*(spacewidth + (1 if i &lt; extra else 0))\n            line += lineWords[-1]\n        result.append(line)\n    return result\n</code></pre>"},{"location":"DSAyy/Strings/#pretty-json-formatter","title":"Pretty JSON Formatter","text":"<p>Given a string representing a JSON object, return an array with proper indentation: - Every inner brace increases the indentation - Every closing brace decreases the indentation - Braces: only <code>{}</code> and <code>[]</code> are valid. - Spaces may be ignored. <pre><code>def prettyJSON(A):\n    result = []     # Final list of formatted lines\n    indent = 0      # Current indentation level\n    cur = \"\"        # Current line being built\n    i = 0\n    n = len(A)\n\n    while i &lt; n:\n        c = A[i]\n\n        # If opening bracket/brace\n        if c in ['{', '[']:\n            if cur.strip():                # Flush any existing line\n                result.append(cur)\n            cur = '\\t' * indent + c        # Add opening with current indent\n            result.append(cur)\n            indent += 1                    # Increase indentation for next level\n            cur = \"\"\n\n        # If closing bracket/brace\n        elif c in ['}', ']']:\n            if cur.strip():                # Flush current buffer if not empty\n                result.append(cur)\n            indent -= 1                    # Decrease indent before printing\n            line = '\\t' * indent + c       # Start line with correct indent\n            if i + 1 &lt; n and A[i + 1] == ',':\n                line += ','                # Append comma if it follows immediately\n                i += 1                     # Skip the comma\n            result.append(line)\n            cur = \"\"\n\n        # If comma separating elements\n        elif c == ',':\n            cur += ','                     # Add comma to current line\n            result.append(cur)             # Flush the line\n            cur = \"\"\n\n        # Any other character (part of key, value, etc.)\n        else:\n            if not cur:\n                cur = '\\t' * indent        # Begin new line with indent\n            cur += c                       # Add character to current line\n\n        i += 1\n\n    # Append any remaining content\n    if cur.strip():\n        result.append(cur)\n\n    return result\n</code></pre></p>"},{"location":"DSAyy/TwoPointers/","title":"Two Pointers","text":""},{"location":"DSAyy/TwoPointers/#pair-with-given-difference","title":"Pair with Given Difference","text":"<p>Given 1D arr <code>A</code> of <code>N</code> integers, and an int <code>B</code>, determine if there is a pair of elements whose difference in B. </p> <p>A = 5 10 3 2 50 80, B = 78. Ans? Yes</p> <p>Keep a hash set, just \\(O(n)\\) time complexity.</p> <pre><code>def pairSum(A,B):\n    seen = set()\n    for x in A:\n        if (x-B) in seen or (x+B) in seen:\n            return 1\n        seen.insert(x)\n    return 0\n</code></pre>"},{"location":"DSAyy/TwoPointers/#3-sum-closest","title":"3 Sum closest.","text":"<p>Given an arr <code>A</code>, find 3 int in A such that their sum is the closest to a given num <code>B</code>. Return sum of those 3 int.</p> <p>A = -1 2 1 -4, B = 1. Output = 2</p>"},{"location":"DSAyy/TwoPointers/#how","title":"How","text":"<p>Sort the arr and use 2 pointers method. Iterate one pointer, <code>l</code> and <code>r</code> the other 2 to moderate.</p> <pre><code>def threeSumClosest(A,B):\n    sort(A)\n    N = len(A)\n    best = A[0] + A[1] + A[2]\n    for i in range(0,N-2):\n        l = i+1, r = N-1\n        while l &lt; r:\n            sm = A[i] + A[l] + A[r]\n            if sm == B: return B\n            if abs(sm - B) &lt; abs(best - B): best = sm\n            if sm &lt; B: l += 1\n            if sm &gt; B: r -= 1\n    return best\n</code></pre>"},{"location":"DSAyy/TwoPointers/#counting-triangles","title":"Counting Triangles","text":"<p>Given arr <code>A</code> of non-neg numbers. Each \\(A_i\\) represents length of a line segment. Count num of distinct triangles that can be formed from these edge lengths.</p> <p>A = 1 1 1 2 2 Output: 4</p>"},{"location":"DSAyy/TwoPointers/#how_1","title":"How","text":"<p>$$ a + b &gt; c $$ We just have to find all values that satisfy this. - Sort the arr - For each pos largest side \\(A_k\\) , use two pointers     - i starts from 0, j from k-1     - for each k, count pairs (\\(A_i,A_j\\)) such that \\(A_i + A_j  &gt; A_k\\)      - if thats true, all ind from i to j-1 also satisfy the condition. <pre><code>def nTriang(A):\n    sort(A)\n    count = 0\n    for k in range(N-1,1,-1): #n-1 down to 2\n        i,j = 0, k-1\n        while i &lt; j:\n            if A[i] + A[j] &gt; A[k]:\n                count += (j-i)\n                j -= 1\n            else:\n                i += 1\n    return count % (10**9 + 7)\n</code></pre></p>"},{"location":"DSAyy/TwoPointers/#diffk-find-pair-with-given-diff-in-a-sorted-arr","title":"Diffk (Find pair with given diff in a sorted arr)","text":"<p>Given a sorted arr A of int, and non neg <code>B</code>. Find whether there exists two indices sucht that their el diff is B $$ A[j] - A[i] = B,\\space i \\neq j $$ Return 1 if exists warna 0</p> <pre><code>def diffPossible(A,B):\n    i, j = 0 , 1\n    N = len(A)\n    while i &lt; N and j &lt; N:\n        if i != j:\n            diff = A[j] - A[i]\n            if diff == B: return 1\n            if diff &lt; B: j += 1\n            else : i += 1\n        else:\n            j += 1\n    return 0\n</code></pre>"},{"location":"DSAyy/TwoPointers/#max-1s-after-modification-sliding-window","title":"Max 1's after modification. (sliding window)","text":"<p>Given bin arr <code>A</code>, and an int <code>B</code>. Find length of longest subseg of consec 1's you can obtain, by changing at most B zeroes in A to ones.</p> <pre><code>def maxOnes(A,B):\n    N = len(A)\n    l = 0\n    zeroes = 0\n    best = 0\n    for right in range(N):\n        if A[right] == 0:\n            zeroes += 1\n        while zeroes &gt; B:\n            if A[left] == 0:\n                zeroes -= 1\n            left += 1\n        best = max(best, right - left + 1)\n    return best\n</code></pre>"},{"location":"DSAyy/TwoPointers/#counting-subarrays","title":"Counting Subarrays","text":"<p>Given array of non-neg arr, and a non-neg int <code>B</code>, find num of subarrs whose sum \\(&lt;\\) B</p> <p>A = 2 5 6, B = 10  Ans = 4 (2 5 6 (2 5) )</p>"},{"location":"DSAyy/TwoPointers/#how_2","title":"How","text":"<p>Sliding window baby If the window is valid, count += (right - left + 1)</p> <pre><code>def countSubarrs(A,B):\n    left,sm,count = 0\n    for right in range(N):\n        sm += A[right]\n        while left &lt;= right and sm &gt;= B:\n            sm -= B\n            left += 1\n        count += (right - left + 1)\n    return count\n</code></pre>"},{"location":"DSAyy/TwoPointers/#subarrs-with-distinct-int","title":"Subarrs with Distinct Int","text":"<p>Given an arr with pos int, count subarrays (continuous) which are good. Good meaning num of distinct int is exactly <code>B</code>. Return the number of good subarrays.</p> <pre><code>from collections import defaultdict\ndef subarrays_with_k_distinct(A,K):\n    return countAtMostK(A,K) - countAtMostK(A,K-1)\ndef countAtMostK(A,K):\n    freq = defaultdict(int)\n    left,count,distinct = 0\n    for right in range(len(A)):\n        if freq[A[right]] == 0:\n            distinct += 1\n        freq[A[right]] += 1\n        while distinct &gt; K:\n            freq[A[left]] -= 1\n            if freq[A[left]] == 0:\n                distinct -= 1\n            left += 1\n        count += right - left + 1\n    return count\n</code></pre>"},{"location":"DSAyy/TwoPointers/#max-cont-series-of-1s","title":"Max Cont Series of 1s","text":"<p>Given binary array, find max sequence of continuous 1s, that can be formed by replacing atmost <code>B</code> zeroes with ones.</p> <p>Return the indices of max cont series of 1s in order. If multiple soln exists, return the sequence with min starting index.</p> <p>A = 1 1 0 1 1 0 0 1 1 1, B = 1, Output = (0,1,2,3,4)</p>"},{"location":"DSAyy/TwoPointers/#how_3","title":"How","text":"<p>Sliding window. Window is valid is zero_count &gt; B <pre><code>def maxone(A,B):\n    left = zeroes = 0\n    bestLen = bestLeft = 0\n    for right in range(len(A)):\n        if A[right] == 0:\n            zeros += 1\n        while zeros &gt; B:\n            if A[left] == 0:\n                zeros -= 1\n            left += 1\n        if right - left + 1 &gt; bestLen:\n            bestLen = right - left + 1\n            bestLeft = left\n    ans = [bestLeft + i for i in range(bestLen)]\n    return ans\n</code></pre></p>"},{"location":"DSAyy/TwoPointers/#array-3-pointers","title":"Array 3 Pointers","text":"<p>Given 3 sorted arrays, A, B, C. Find indices i,j,k such that $$ max(|A[i] - B[j]|, |B[j] - C[k]|, |C[k] - A[i]|) $$ is minimized.</p> <p>Return the min value.</p>"},{"location":"DSAyy/TwoPointers/#how_4","title":"How?","text":"<p>take i,j,k = 0, then calc the curMax - curMin, of all elements.</p> <p>Advance the ptr to the min element, since we need to decrease the gap.</p> <pre><code>def minimize(A,B,C):\n    i = j = k = 0\n    ans = 10**18\n    while i &lt; len(A) and j &lt; len(B) and k &lt; len(C):\n        x,y,z = A[i], B[j], C[k]\n        curMax = max(x,y,z)\n        curMin = min(x,y,z)\n        ans = min(ans, curMax - curMin)\n        if curMin == x: i += 1\n        else if curMin == y: j +=1 \n        else: k += 1\n    return ans\n</code></pre>"},{"location":"DSAyy/TwoPointers/#container-with-most-water-trapping-rain-water","title":"Container With Most Water (Trapping rain water)","text":"<p>Given arr of non-neg int <code>A</code>, where  \\(A_i\\) is a wall's height. Find the area of most water you can contain in this.</p> <p>A = 1 5 4 3, Output = 6 (trap between 5 and 3)</p>"},{"location":"DSAyy/TwoPointers/#how_5","title":"How","text":"<ol> <li>left = 0, right = n-1</li> <li>Area between left and right is: height =  \\(min(a_{left},a_{right})\\), width = right - left.</li> <li>Move pointer of the shorter wall inwards, since it is holding us back.</li> <li>Repeat until left \\(\\leq\\) right.</li> </ol> <pre><code>def maxArea(A):\n    left,right = 0, len(A) - 1\n    maxAr = 0\n    while left &lt; right:\n        height = min(A[left],A[right])\n        width = right - left\n        maxAr = max(maxAr, height * width)\n        if A[left] &lt; A[right]: left += 1\n        else: right -= 1\n    return maxAr\n</code></pre>"},{"location":"DSAyy/TwoPointers/#merge-two-sorted-lists-ii","title":"Merge Two Sorted Lists II","text":"<p>Given two sorted arrs, modify first one inplace to contain the merged sorted arr of both.</p>"},{"location":"DSAyy/TwoPointers/#how_6","title":"How","text":"<ol> <li>Expand A to size \\(m + n\\) </li> <li>Merge from the end, to avoid overwriting in A that hasn't been moved.</li> <li>Use 3 pointers:<ol> <li>i = m-1 (end of old A)</li> <li>j = n-1 (end of B)</li> <li>k = m+n -1 (end of expanded A)</li> </ol> </li> <li>Compare <code>A[i]</code> and <code>B[j]</code>, put the larger at <code>A[k]</code>.</li> <li>If B has more elements left, just copy them over. <pre><code>def merge(A,B):\n    m,n = len(A), len(B)\n    i,j,k = m-1,n-1,m+n - 1\n    while i&gt;= 0 and j &gt;= 0:\n        if A[i] &gt; B[j]:\n            A[k] = A[i]\n            i -= 1\n        else:\n            A[k] = B[j]:\n            j -= 1\n        k -= 1\n    while j &gt;= 0:\n        A[k] = B[j]\n        k -= 1\n        j -= 1\n</code></pre></li> </ol>"},{"location":"DSAyy/TwoPointers/#intersection-of-sorted-arrays","title":"Intersection of Sorted Arrays","text":"<p>Given two sorted arrays A and B, Find their intersection and preserve element's frequencies.</p>"},{"location":"DSAyy/TwoPointers/#how_7","title":"How","text":"<ol> <li>i = 0, j = 0</li> <li>if <code>A[i]</code> &lt; <code>B[j]</code>: incr i</li> <li><code>A[i]</code> &gt; <code>B[j]</code>, incr j</li> <li>equal? add to the res <pre><code>def intersect(A,B):\n    i=j=0\n    res = []\n    while i &lt; len(A) and j &lt; len(B):\n        if A[i] &lt; B[j]:\n            i += 1\n        elif A[i] &gt; B[j]:\n            j += 1\n        else: \n            res.append(A[i])\n            i += 1\n            j += 1\n    return res\n</code></pre></li> </ol>"},{"location":"DSAyy/TwoPointers/#remove-duplicated-from-sorted-array","title":"Remove Duplicated From Sorted Array","text":"<p>Remove all duplicates inplace from the sorted array, and return the length of sorted array with only distinct elements. Also update A inplace.</p>"},{"location":"DSAyy/TwoPointers/#how_8","title":"How","text":"<p>Use 2 pointers, read and write. First read then write.</p> <pre><code>def removeDuplicates(A):\n    if not A: return 0\n    write = 1 #where we write next unique\n    for read in range(1,n):\n        if A[read] != A[read -1]: #whenever we see new value\n            A[write] = A[read]\n            write += 1\n    return write\n</code></pre>"},{"location":"DSAyy/TwoPointers/#remove-duplicates-from-sorted-array-ii","title":"Remove Duplicates From Sorted Array II","text":"<p>Remove duplicates from sorted array in-place, so that each element appears atmost twice. Return the new length. Update A in-place and return the new length.</p> <p>A = 1 1 1 2, it becomes A = 1 1 2, and output is 3</p>"},{"location":"DSAyy/TwoPointers/#how_9","title":"How","text":"<ol> <li>Duplicates are adjacent.</li> <li>Use a write ptr</li> <li>For every \\(A[read] \\neq A[write - 2]\\) (current el is not equal to two elements before it), copy it to \\(A[write]\\) <pre><code>def removeDuplicatesII(A):\n    n = len(A)\n    if n &lt;= 2: return n\n    write = 2\n    for read in range(2,n):\n        if A[read] != A[write -2]:\n            A[write] = A[read]\n            write += 1\n    return write\n</code></pre></li> </ol>"},{"location":"DSAyy/TwoPointers/#remove-element-from-array","title":"Remove Element From Array","text":"<p>Remove all instances of <code>B</code> from <code>A</code>. Update array in place, and return the num of elements left after operation.</p> <p>if \\(A[read] \\neq B\\) , then \\(A[write] = A[read]\\) <pre><code>def removeElement(A,B):\n    write = 0\n    for read in range(len(A)):\n        if A[read] != B:\n            A[write] = A[read]\n            write += 1\n    return write\n</code></pre></p>"},{"location":"DSAyy/TwoPointers/#sort-by-color-dutch-national-flag-problem","title":"Sort by Color (dutch national flag problem)","text":"<p>Sort the array, consisting only of 0 1 2. </p> <p>Let <code>low</code> be boundary between 0 and 1, let mid be cur el, right be boundary between 1 and 2</p> <pre><code>def sortColors(A):\n    low = mid = 0\n    high = len(A) - 1\n    while mid &lt;= high:\n        if A[mid] == 0:\n            A[low],A[mid] = A[mid],A[low]\n            low += 1\n            mid += 1\n        elif A[mid] == 1:\n            mid += 1\n        else:\n            A[mid],A[high] = A[high],A[mid]\n            high -= 1\n</code></pre>"},{"location":"DSAyy/arrays/","title":"Array Simulation","text":""},{"location":"DSAyy/arrays/#spiral-order-matrix","title":"Spiral Order Matrix","text":""},{"location":"DSAyy/arrays/#question-kya-hai","title":"Question kya hai","text":"<p>Matrix A: Size M x N, return all elements in the spiral order. (clockwise starting from top-left)</p> <p>Matrix A:</p> 1 2 3 4 5 6 7 8 9 <p>the output would be \\(1,2,3,6,9,8,7,4,5\\)</p>"},{"location":"DSAyy/arrays/#how-to-do-this","title":"How to do this","text":"<p>Take 4 pointers and continuously run for loops on that bitch.  Bas run top first, then right, then down, then left</p> <pre><code>vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt; &amp;A){\n    int M = A.size(), N = A[0].size();\n    int u = 0, d = M-1, l = 0, r = N-1;\n    vector&lt;int&gt; spiral;\n    while (l &lt;= r &amp;&amp; u &lt;= d){\n        for (int i = l; i &lt;= r; ++i)\n            spiral.push_back(A[u][i]);\n        ++u;\n        for (int i = u; i &lt;= d; ++i)\n            spiral.push_back(A[i][r]);\n        --r;\n        if (u &lt;= d){\n            for (int i = r; i &gt;= l; --i)\n                spiral.push_back(A[d][i]);\n            --d;\n        }\n        if (l &lt;= r){\n            for (int i = d; i &gt;= u; --i)\n                spiral.push_back(A[i][l]);\n            ++l;\n        }\n    }\n    return spiral;\n}\n</code></pre> <p>Iski time complexity is \\(O(n \\times m)\\) Space complexity bhi same</p>"},{"location":"DSAyy/arrays/#large-factorial","title":"Large Factorial","text":""},{"location":"DSAyy/arrays/#question","title":"Question","text":"<p>Given integer A, compute A ! as a string, coz kuch zyaada hi bada number hai.</p>"},{"location":"DSAyy/arrays/#kaise-karna-hai-ye","title":"Kaise karna hai ye","text":"<p>Dekh bro as a string return karna hai answer toh legit make a multiply function for strings and karle solve. Kya hi dumb shit hai ye. Just know ki digits would be reversed for the convenience of the carry shit.  Toh reverse pointer se string meh add kariyo.</p> <pre><code>string factorial(int A){\n    vector&lt;int&gt; digits {1}; // har factorial meh 1 toh hota hi hai\n\n    auto multiply = [&amp;](int i) {\n        int carry = 0;\n        for (int &amp;d : digits){\n            long long prod = (long long)d * i + carry;\n            d = prod % 10; // same time digit update kar diya\n            carry = prod / 10;\n        }\n        while (carry){\n            digits.push_back(carry % 10);\n            carry /= 10;\n        }\n    };\n\n    for (int i = 2; i &lt;= A; ++i) // multiply sabkuch from 2 to A\n    {\n        multiply(i); // multiple every number into 2\n    }\n    string s;\n    // put all the digits into a string\n    for (auto it = digits.rbegin(); it != digits.rend(); ++it){\n        s.push_back('0' + *it); \n    }\n    return s;\n}\n</code></pre>"},{"location":"DSAyy/arrays/#max-non-negative-subarray","title":"Max Non-Negative Subarray","text":""},{"location":"DSAyy/arrays/#question-kya-hai_1","title":"Question kya hai","text":"<p>Array A of N integers, find the subarray with max sum. agar tied, choose the longer one. still tied? smallest starting index</p> <p>Sunn BEHENCHOD, Subarray means continuous, sab kuch subsequence nahi hota</p>"},{"location":"DSAyy/arrays/#karna-kaise-hai","title":"Karna kaise hai","text":"<p>kadane kadane khelenge agar negative number mila, that is where we stop and process the answer. By process i mean, bas compare karke check karlenge if its max</p> <p>End meh bhi ek baar check kar lena coz when the loop ends, ek baar remaining computation bhi toh update karni hai.</p> <pre><code>vector&lt;int&gt; maxSet(vector&lt;int&gt; &amp;A){\n    int n = A.size();\n    long long bestSum = -1, curSum = 0;\n    int bestStart = 0, bestEnd = -1, bestLen = 0;\n    int curStart = 0;\n    for (int i = 0; i &lt; n; ++i){\n        if (A[i] &gt;= 0)\n            curSum += A[i];\n        else {\n            int curLen = i - curStart;\n            if (curSum &gt; bestSum || (curSum == bestSum &amp;&amp; curLen &gt; bestLen)){\n                bestSum = curSum;\n                bestStart = curStart;\n                bestEnd = i - 1;\n                bestLen = curLen;\n            }\n            curSum = 0;\n            curStart = i+1;\n        }\n    }\n    if (curStart &lt; n){\n        int curLen = n - curStart;\n        if (curSum &gt; bestSum || (curSum == bestSum &amp;&amp; curLen &gt; bestLen)){\n            bestSum = curSum;\n            bestStart = curStart;\n            bestEnd = n - 1;\n            bestLen = curLen;\n        }\n    }\n    if (bestEnd &lt; bestStart) return {};\n    return vector&lt;int&gt;(A.begin()+bestStart, A.begin()+bestEnd + 1);\n}\n</code></pre> <p>Time complexity is O(n), space complexity is O(1)</p>"},{"location":"DSAyy/arrays/#pick-from-both-sides","title":"Pick from Both Sides","text":"<p>Array A of N elements. Pick exactly B elements from either left ya right end, and just get the max sum.</p>"},{"location":"DSAyy/arrays/#karna-kaise-hai_1","title":"Karna kaise hai","text":"<p>Imagine kar ek sexy sa sliding window, but instead on inside the array, ye saala bahar se aa raha hai. like the right pointer is left meh and left wala is right meh. ye leke bas max sum with B elements karle. Start the right pointer at B - i, and keep the left wala at n - i, and baaju baaju shift and update karte ja. Keep a sum of first B elements, and fir middle se ek hata and right end wala ek daal.</p> <pre><code>int pickBothSides(vector&lt;int&gt; &amp;A, int B){\n    int n = A.size();\n    int window = accumulate(A.begin(), A.begin() + B, 0);\n    int ans = window;\n    for (int i = 1; i &lt;= B; ++i){\n        window = window - A[B-i] + A[n-i];\n        ans = max(ans, window);\n    }\n    return ans;\n}\n</code></pre> <p>Time complexity is O(n) and space complexity is O(1)</p>"},{"location":"DSAyy/arrays/#min-steps-in-infinite-grid","title":"Min Steps in Infinite Grid","text":"<p>2D infinite grid. Every move can be 8D (diagonals too). Given points to visit, find min steps needed to cover all points.</p> <p>A has x coods, B has y coods. </p> <p>Ex: A = 0 1 1, B = 0 1 2. Toh the points would be (0,0), (1,1), (1,2). Min Steps: 2  <pre><code>def coverPoints(A,B):\n    n = len(A)\n    steps = 0\n    for  i in range(1,n):\n        steps += max(abs(A[i] - A[i-1]), abs(B[i] - B[i-1]))\n    return steps\n</code></pre> Time waste hai bhai aise questions.</p>"},{"location":"DSAyy/arrays/#min-lights-to-activate","title":"Min Lights to activate","text":"<p>Given a corridor of length \\(N\\), \\(A[i]\\) means light on \\(i\\)'th tile \\(i\\) working, and can light up positions \\([i - B + 1, i + B - 1]\\).</p> <p>Find the min lights to turn on to light up the whole corridor.</p> <p>Ex: A = 0 0 1 1 1 0 0 1, B = 3</p> <p>Ans: 2 (light up 2 and 7, they cover the whole length of the corridor yaar ganja chahiye).</p>"},{"location":"DSAyy/arrays/#how","title":"How?","text":"<ol> <li>For every working light, record uska covering range.</li> <li>Sort the intervals by first point.</li> <li>Start at the left light, choose the one that covers the farthest to the right, but starts before or at your current position.</li> <li>Bas yahi bhai, completely greedy.</li> </ol> <pre><code>def minLights(A,B):\n    N = len(A)\n    intervals = []\n    #build intervals from working lights\n    for i in range(N):\n        if A[i] == 1:\n            left = max(0, i - (B-1))\n            right = max(N-1, i + (B-1))\n            intervals.append(left,right)\n    intervals.sort()\n    res,i,end,farthest = 0,0,0,0\n    #greedy covering\n    while end &lt; N:\n        found = False\n        while i &lt; len(intervals) and intervals[i][0] &lt;= end:\n            farthest = max(farthest, intervals[i][1])\n            i += 1\n            found = True\n        if not found:\n            return -1 #cant cover the whole\n        res += 1\n        end = farthest + 1\n    return res\n</code></pre>"},{"location":"DSAyy/arrays/#maximum-sum-triplet","title":"Maximum Sum Triplet","text":"<p>Given an array of numbers, find the max sum of a triplet such that \\(0 \\leq i &lt; j &lt; N\\) and \\(A_i &lt; A_j &lt; A_k\\) If no such triplet exists, return 0. </p> <p>A = 2 5 3 1 4 9, output: 16 . (3,4,9) hai ek sexy triplet.</p>"},{"location":"DSAyy/arrays/#how_1","title":"How??","text":"<p>For each j (\\(1 \\leq j \\leq N-2\\)) find: 1. Best \\(A_i &lt; A_j\\) for \\(i &lt; j\\) (use a set to track efficiently) 2. Best \\(A_k &gt; A_j\\) for \\(k &gt; j\\) (use suffix array)</p> <pre><code>def maxSumTrip(A):\n    n = len(A)\n    if n &lt; 3: return 0\n    #right max array\n    right_max = [0]*n\n    right_max[-1] = A[-1]\n    for i in range(n-2,-1,-1):\n        right_max[i] = max(A[i], right_max[i+1])\n    seen = [A[0]]\n    mxSum = 0\n    for j in range(1,n-1):\n        if right_max[j+1] &lt;= A[j]:\n            bisect.insort(seen,A[j])\n            continue\n        best_r = right_max[j+1]\n        idx = bisect.bisect_left(seen, A[j])\n        if idx == 0:\n            bisect.insort(seen,A[j])\n            continue\n        best_l = seen[idx-1]\n        mxSum = max(mxSum, best_l + A[j] + best_r)\n        bisect.insort(seen,A[j])\n    return mxSum\n</code></pre>"},{"location":"DSAyy/arrays/#max-sum-continguous-subarray","title":"Max Sum Continguous Subarray","text":"<p>Given array, find max possible sum of any continuous subarray. <pre><code>def maxSubArray(A):\n    curr = A[0]\n    best = A[0]\n    for i in A:\n        curr = max(A[i], curr + A[i])\n        best = max(best, curr)\n    return best\n</code></pre></p>"},{"location":"DSAyy/arrays/#add-one-to-the-number","title":"Add one to the Number","text":"<p>Given a non neg number as an array of digits, add 1 to the number. Return the resulting array.</p> <pre><code>def plusOne(A):\n    c = 1\n    n = len(A)\n    A.reverse()\n    A.append(0)\n    for i in A:\n        res = c + i\n        i = res % 10\n        c = res//10\n    while A[-1] == 0: A.pop()\n    A.reverse()\n    return A    \n</code></pre>"},{"location":"DSAyy/arrays/#max-absolute-difference","title":"Max Absolute Difference","text":"<p>Given integer array of length N, compute  $$ max_{1 \\leq i,j \\leq N} (|A[i] - A[j]| + |i-j|) $$</p> <p>Example: A = 1 3 -1, Ans = 5</p>"},{"location":"DSAyy/arrays/#how_2","title":"How","text":"<p>Okay firstly toh iss chutiye se equation ko simplify kar. $$ \\text{Answer = } max(max_i(A[i] + i) - min_i(A[i] + i), max_i(A[i] - i) - min_i(A[i] - i)) $$</p> <pre><code>def maxArr(A):\n    INT_MAX = 10**18\n    INT_MIN = -10**18\n    minB = INT_MAX, minC = INT_MAX\n    maxB = INT_MIN, maxC = INT_MIN\n    for idx,x in enumerate(A):\n        B = x + idx\n        C = x - idx\n        maxB = max(maxB,B)\n        minB = min(minB,B)\n        maxC = max(maxC,C)\n        minC = min(minC, C)\n    return max(maxB - minB, maxC - minC)\n</code></pre>"},{"location":"DSAyy/arrays/#partitions-split-array-into-3-with-equal-sums","title":"Partitions (Split array into 3 with equal sums)","text":"<p>Given an array, count ways to split it into 3 contiguous parts such that unka sum is equal.</p> <p>Ex: B = 1 2 3 0 3, Ans = 2. Kyu? (1,2), (3), (0,3) and (1,2), (3,0), (3).</p>"},{"location":"DSAyy/arrays/#how_3","title":"How?","text":"<ol> <li>Pehle toh it needs to be divisible by 3, warna toh hoga hi nahi.</li> <li>Let S be the total sum array ka, we want \\(T = \\frac{S}{3}\\) . This is humara target sum for each array.</li> <li>So in the prefix array, if we find T and 2T, then remaining would directly be T. Kyu? Abe chutiye \\(S = 3T\\) so (\\(S - 2T = T\\)). </li> <li>Count the number of psum jaha prefix sum is T.</li> <li>For each prefix jaha sum = 2T, number of valid splits at that point is equal to the number of T before (utne possible combinations honge na) <pre><code>def partitions(B):\n    N = len(A)\n    S = sum(A)\n    if S % 3 == 1: return 0\n    T = S // 3\n    prefix = 0\n    countT = 0\n    ways = 0\n    for i in A:\n        prefix += A\n        if prefix == 2*T: ways += countT\n        if prefix == T: countT += 1\n    return ways\n</code></pre></li> </ol>"},{"location":"DSAyy/arrays/#maximum-area-of-triangle","title":"Maximum Area Of Triangle.","text":"<p>Given 2D matrix, each cell colored 'r', 'g' ya 'b'. Find the largest triangle (with vertices of different colors) such that one side is vertical (i.e parallel to y-axis).</p> <p>Return the maximum possible area. ![[Pasted image 20250702235235.png]]</p>"},{"location":"DSAyy/arrays/#how_4","title":"How?","text":"<p>Valid Triangle tab hai jab: 1. Three vertices at coordinates (\\(x_1,y\\)) (\\(x_2,y\\)) and (\\(x_3,y_3\\)), where colors at each vertex are all different. Notice first two points same y pe hai (vertical). 2. The base is vertical segment \\(|x_1 - x_2|\\) (diff rows in y) 3. Third point is  at any column, as far from y as possible.</p> <p>$$ Area = \\frac{1}{2} \\times base \\times height $$ Preprocessing: 1. For each column, track min/max of 'r','g' and 'b' 2. leftmost/rightmost column for each color. Ab try vertical sides in each column: 3. Sab meh max/min dhund allowed color ka, use it as longest base. (agar i niche hai, toh (min) upar wala le, agar i upar toh (max) neeche wala le). 4. Then bas farthest dhund 3rd color ka, and area update kar diyo.</p> <pre><code>import math\nfrom collections import defaultdict\n\ndef max_triangle_area(grid):\n    n = len(grid)\n    m = len(grid[0])\n    colors = ['r','g','b']\n    #min, max in each row for each color\n    min_row = {c : [float('inf')] * m for c in colors}\n    max_row = {c : [-1] * m for c in colors}\n    left_most = {c : float('inf') for c in colors} #farthest columns for color\n    right_most = {c : -1 for c in colors}\n    #fill upar ke arrays\n    for i in range(n):\n        for j in range(m):\n            color = grid[i][j]\n            min_row[color][j] = min(min_row[color][j], i)\n            max_row[color][j] = max(max_row[color][j], i)\n            left_most[color] = min(left_most[color], j)\n            right_most[color] = max(right_most[color], j)\n    best_area = 0\n    for c in range(m):\n        for i in range(3):\n            for j in range(i+1,3):\n                a,b = colors[i], colors[j]\n                t = colors[3 - i -j] #third color\n                h1 = max_row[a][c] - min_row[b][c] #check for neeche\n                h2 = max_row[b][c] - min_row[a][c] #check upar\n                h = max(h1,h2)\n                if h &lt;= 0:\n                    continue\n                #find farthest position\n                d = max(abs(c - left_most[t]), abs(c - right_most[t]))\n                if d == 0:\n                    continue\n                area = ((h+1)*d + 1)// 2\n                best_area = max(best_area, area)\n    return best_area\n</code></pre>"},{"location":"DSAyy/arrays/#flip","title":"Flip","text":"<p>Given a binary string. In one single operation, you can choose <code>L</code> and <code>R</code> and flip the bits in that range. Aim is to perform atmost one operation such that the final string number of 1s is maximised.</p> <p>Return an array of range <code>[L,R]</code> (possibly empty), such that final number of <code>1s</code> in the string is maximised.</p> <p>If many exists, return lexicographically smallest.</p> <p>Example: 010, output <code>[1,1]</code></p>"},{"location":"DSAyy/arrays/#how_5","title":"How","text":"<p>Instead of counting directly, make it a max subarray kadane problem where:</p> <ul> <li> <p><code>0</code> contributes +1 (because flipping it gives a 1)</p> </li> <li> <p><code>1</code> contributes -1 (because we dont want 0 when flipped) <pre><code>def flip(A: str):\n    n = len(A)\n    best_sum = 0\n    best_l, best_r = -1,-1\n    curr_sum = 0\n    start = 0\n    for i in range(n):\n        val = 1 if A[i] == '0' else -1\n        curr_sum += val\n        if curr_sum &gt; best_sum:\n            best_sum = curr_sum\n            best_l = start\n            best_r = i\n        elif curr_sum == best_sum and best_sum &gt; 0:\n            if start &lt; best_l or (start == best_l and i &lt; best_r):\n                best_l = start\n                best_r = i\n        if curr_sum &lt; 0:\n            curr_sum = 0\n            start = i+1\n    if best_sum == 0:\n        return []\n    return [best_l + 1, best_r + 1]\n</code></pre></p> </li> </ul>"},{"location":"DSAyy/arrays/#merge-intervals","title":"Merge Intervals","text":"<p>Given a set of non-overlapping intervals, and a new interval. Insert it into the set of intervals (merge if necessary).</p> <p>Assume that they were sorted initially based on the start times.</p> <p>Ex: 1,3 6,9, newInt = 2,5; output = 1,5 6,9</p>"},{"location":"DSAyy/arrays/#how_6","title":"How","text":"<p>Bruteforce <pre><code>from typing import List\nclass Interval:\n    def __init__(self, start = 0, end = 0):\n        self.start = start\n        self.end = end\n    def __repr__(self):\n        return f\"[{self.start}, {self.end}]\"\ndef insert(intervalsL: List[Interval], newInterval: Interval) -&gt; List[Interval]:\n    res = []\n    placed = False\n    for cur in intervals:\n        if cur.end &lt; newInterval.start:\n            res.append(cur)\n        elif curr.start &gt; newInterval.end:\n            if not placed:\n                res.append(newInterval)\n                placed = True\n            res.append(cur)\n        else:\n            newInterval.start = min(newInterval.start, cur.start)\n            newInterval.end = max(newInterval.end, cur.end)\n    if not placed:\n        res.append(newInterval)\n    return res\n</code></pre></p>"},{"location":"DSAyy/arrays/#merge-overlapping-intervals","title":"Merge Overlapping Intervals","text":"<p>Given a collection of intervals, merge all overlapping intervals.</p> <p>Ex: 1,3 2,6 8,10 15,18 ; Output = 1,6 8,10 15,18</p>"},{"location":"DSAyy/arrays/#how_7","title":"How","text":"<ul> <li> <p>Okay so we sort the intervals by starting time.</p> </li> <li> <p>Iterate through the sorted list, if the current interval ovelaps with last added interval, we just update the end.</p> </li> <li> <p>Return the merged list.</p> </li> </ul> <pre><code>from typing import List\nclass Interval:\n    def __init__(self, start = 0, end = 0):\n        self.start = start\n        self.end = end\n    def __repr__(self):\n        return f\"[{self.start}, {self.end}]\"\ndef merge(intervals: List[Interval]) -&gt; List[Interval]:\n    if not intervals:\n        return []\n    intervals.sort(key = lambda x: x.start)\n    merged = [intervals[0]]\n    for i in range(1,len(intervals)):\n        last = merged[-1]\n        current = intervals[i]\n        if last.end &gt;= current.start:\n            last.end = max(last.end, current.start)\n        else:\n            merged.append(current)\n    return merged\n</code></pre>"},{"location":"DSAyy/arrays/#perfect-peak-of-the-array","title":"Perfect Peak of the array.","text":"<p>Given an integer array, check whether there is an element that is strictly greater than all on the left and smaller than all on the right.</p> <p>Ex: 5 1 4 3 6 8 10 7 9, Output = 1</p> <p>Basically we are finding a pothole that is the deepest.</p> <pre><code>from typing import List\ndef perfect_peak(A: List[int]) -&gt; int:\n    n = len(A)\n    if n &lt; 3:\n        return 0\n    right_min = [0]*n\n    right_min[-1] = A[-1]\n    for i in range(n-2,-1,-1):\n        right_min = A[i] if A[i] &lt; right_min[i+1] else right_min[i+1]\n    left_max = A[0]\n    for i in range(1,n-1):\n        if left_max &lt; A[i] &lt; right_min[i+1]:\n            return 1\n        if A[i] &gt; left_max:\n            left_max = A[i]\n    return 0\n</code></pre>"},{"location":"DSAyy/arrays/#move-zeroes","title":"Move Zeroes","text":"<p>Given an int array, move all 0's to the end while maintaining the relative order of the non-zero elements.</p> <p>A = 0 1 0 3 12, Output: 1 3 12 0 0</p> <pre><code>def moveZeroes(A):\n    n = len(A)\n    j = 0 #where next non-zero should go\n    for i in range(n):\n        if A[i] != 0:\n            A[i],A[j] = A[j], A[i]\n            j += 1\n    return A\n</code></pre>"},{"location":"DSAyy/arrays/#make-equal-elements-array","title":"Make equal elements array.","text":"<p>Given an array of pos int, and an element x. Find whether whether all the elements can be made equal to x, by following the below operations:</p> <ul> <li>Add x to any element in array.</li> <li>subtract x from any element in array.</li> <li>Do nothing.</li> </ul>"},{"location":"DSAyy/arrays/#how_8","title":"How","text":"<p>Think of it like a chain reaction, can we reach the end with our only options being \\(A[i] \\pm B\\). If we can reach the end, then yes it can be made equal.</p> <pre><code>from typing import List\ndef makeEqual(A: List[int], B: int) -&gt; int:\n    N = len(A)\n    if N == 0:\n        return 0 #we have no elements to make equal\n    C = [A[0], A[0] + B, A[0] - B] #possible target values\n    #filter possible targets\n    for i in range(1,N):\n        c_next = []\n        for t in c:\n            diff = abs(A[i] - t)\n            if diff == 0 or diff == B:\n                c_next.append(t)\n        c = c_next\n        if not c:\n            return 0\n    return 1\n</code></pre>"},{"location":"DSAyy/arrays/#segregate-0s-and-1s-in-an-array","title":"Segregate 0s and 1s in an array.","text":"<p>Given array of 0, 1 and 2. Segregate 0 to the left, 1 to the right.</p>"},{"location":"DSAyy/arrays/#how_9","title":"How","text":"<p>Dutch national flag 2 pointer approach.</p> <pre><code>from typing import List\ndef segs(A: List[int]) -&gt; List[int]:\n    n = len(A)\n    low = 0, high = n-1\n    while low &lt; high:\n        if A[low] == 0:\n            low += 1\n        else:\n            A[low], A[high] = A[high], A[low]\n            high -= 1\n    return A\n</code></pre>"},{"location":"DSAyy/arrays/#array-sum","title":"Array Sum","text":"<p>Given two numbers, in the form of arrays. Perform addition and return in terms of array of digits.</p> <pre><code>def typing import List\ndef add(A: List[int], B: List[int]) -&gt; List[int]:\n    R = []\n    i = len(A) - 1\n    j = len(B) - 1\n    carry = 0\n    while i &gt;= 0 or j &gt;= 0:\n        sm = carry\n        if i &gt;= 0:\n            sm += A[i]\n            i -= 1\n        if j &gt;= 0:\n            sm += A[j]\n            j -= 1\n        carry = sm // 10\n        sm = sm % 10\n        R.append(sm)\n    if carry != 0: R.append(carry)\n    return reversed(R)\n</code></pre>"},{"location":"DSAyy/arrays/#kth-row-in-pascals-triangle","title":"Kth Row in Pascal's Triangle","text":"<p>Given an index k, return the kth row of pascal triangle.</p> <p>Input: k = 3; output = 1 3 3 1</p>"},{"location":"DSAyy/arrays/#how_10","title":"How","text":"<p>$$ C(A,r) = C(A,r-1) \\times \\frac{A-(r-1)}{r} $$ <pre><code>from typing import List\ndef getRow(A: int) -&gt; List[int]:\n    row = [0]*(A + 1)\n    row[0] = 1\n    for r in range(1,A+1):\n        prev = row[r-1]\n        numer = prev*(A-(r-1))\n        row[r] = numer // r\n    return row\n</code></pre></p>"},{"location":"DSAyy/arrays/#spiral-order-ii","title":"Spiral Order II","text":"<p>Given an int A, generate a square matrix filled with elements from 1 to \\(A^2\\) in spiral order. And return the generated square matrix.</p> <p>Ex: Inp = 2</p> <p>Output:  <pre><code>1 2\n4 3\n</code></pre></p> <p>brute force just keep a pointer and update the boundaries. <pre><code>from typing from List\ndef generateMatrix(N: int) -&gt; List[List[int]]:\n    num = 1;\n    A = [[0]*N for _ in range(N)]\n    l,r = 0, N-1\n    u,d = 0, N-1\n    while l &lt;= r and u &lt;= d:\n        #fill top\n        for i in range(l,r+1):\n            A[u][i] = num\n            num += 1\n        u += 1\n        #fill right\n        for i in range(u,d+1):\n            A[i][r] = num\n            num += 1\n        r -= 1\n        #fill bottom\n        if u &lt;= d:\n            for i in range(r,l-1,-1):\n                A[d][i] = num\n                num += 1\n            d -= 1\n        if l &lt;= r:\n            for i in range(d,u-1,-1):\n                A[i][l] = num\n                num += 1\n            l += 1\n    return A\n</code></pre></p>"},{"location":"DSAyy/arrays/#pascals-triangle","title":"Pascal's Triangle","text":"<p>Given the number of rows <code>numRows</code>, generate first <code>numRows</code> rows of pascal triangle.</p> <pre><code>from typing import List\ndef pascalRows(A: int) -&gt; List[List[int]]:\n    res = []\n    if A &lt;= 0: return res\n    res.append([1])\n    for i in range(1,A):\n        row = [0]*(i+1)\n        row[0] = row[i] = 1\n        for j in range(1,i):\n            row[j] = res[i-1][j] + res[i-1][j-1]\n        res.append(row)\n    return res\n</code></pre>"},{"location":"DSAyy/arrays/#anti-diagonals-of-a-square-matrix","title":"Anti Diagonals of a square matrix.","text":"<p>Given a square matrix, return all its anti-diagonals. Each anti diagonal contains elements where sum of row and column is constant.</p> <p><pre><code>A = 1 2 3\n    4 5 6\n    7 8 9\n</code></pre> Ans: {1}, {2,4}, {3,5,7}, {6,8}, {9} Okay so har square matrix of size \\(N\\) has \\(2 \\times N - 1\\) anti diagonals. <pre><code>def diagonal(A):\n    N = len(A)\n    res = [0]*(2*N - 1)\n    for i in range(N):\n        for j in range(N):\n            res[i+j].append(A[i][j])\n    return res\n</code></pre></p>"},{"location":"DSAyy/arrays/#bucketing","title":"Bucketing","text":""},{"location":"DSAyy/arrays/#triplets-with-sum-between-given-range","title":"Triplets with Sum between Given Range","text":"<p>Given an array, find triplet (a,b,c) such that $$ 1 &lt; a + b+ c &lt; 2 $$ Return 1 if yes warna 0</p>"},{"location":"DSAyy/arrays/#fun-fact","title":"Fun Fact","text":"<p>Basically any triplet sum can be as small as \\(3 \\times\\) smallest number or as large as \\(3 \\times\\) largest number.  But for  \\(a + b + c\\) to land between 1 and 2, atleast one of a,b,c must be \\(&lt; 1\\), and at least one should be \\(&gt; 0\\)</p> <p>Define buckets: \\(A \\in (0,\\frac{2}{3})\\) , \\(B \\in [\\frac{2}{3},1]\\), \\(C \\in (1,2)\\)</p>"},{"location":"DSAyy/arrays/#how-to-find-a-valid-triplet","title":"How to find a valid triplet.","text":"<p>Either pick 1. Three from A: Pick the three largest in A (since small numbers). If sum valid, return true. 2. Two from A, one from B: Pick two largest in A and one in B 3. Two from A, one from C: Pick two smallest in A and smallest in C (to avoid going over 2) 4. Two from B, one from A: Twoo smallest in B and one smallest in A. 5. One from each bucket: The smallest in A,B,C</p> <p>Input: 0.6 0.7 0.8 1.2 0.4</p> <p>A: \\(0.6\\space 0.4\\) B: \\(0.7 \\space 0.8\\) C: \\(1.2\\) Output: YES YES OH YESSSS</p> <pre><code>def solve(a):\n    A,B,C = [],[],[]\n    for s in a:\n        x = float(s)\n        if 0 &lt; x &lt; 2.0/3:\n            A.append(x)\n        elif 2.0/3 &lt;= x &lt;= 1.0:\n            B.append(x)\n        elif 1.0 &lt; x &lt; 2.0:\n            C.append(x)\n    A.sort()\n    B.sort()\n    # case1: 3 from A\n    if len(A) &gt;= 3 and  1 &lt; sum(A[-3:]) &lt; 2:\n        return 1\n    # case2: 2 from A and 1 from B\n    if len(A) &gt;= 2 and len(B) &gt;= 1 and A[-1] + A[-2] + B[0] &lt; 2:\n        return 1\n    #case 3: 2 from A and 1 from C\n    if len(A) &gt;= 2 and len(C) &gt;= 1 and A[0] + A[1] + C[0] &lt; 2:\n        return 1\n    #case 4: 2 from B, 1 from A\n    if len(B) &gt;= 2 and len(A) &gt;= 1 and B[0] + B[1] + A[0] &lt; 2:\n        return 1\n    #case 5: 1 from each\n    if A and B and C and 1 &lt; A[0] + B[0] + C[0] &lt; 2:\n        return 1\n    return 0\n</code></pre>"},{"location":"DSAyy/arrays/#balance-array","title":"Balance Array","text":"<p>Given an array of int. Count the special elements. Element is special if removing it makes the sum of elements at even indices is equal to sum at odd indices.</p> <p>Formally: $$ \\sum_{\\text{even j}} A_j^<code>= \\sum_{\\text{odd j}}A_j^</code> $$</p>"},{"location":"DSAyy/arrays/#how_11","title":"How","text":"<p>Simulate parity flipping.</p> <p>Let - leftEven/leftOdd: Sum of even/odd indices to the left of i (before removal) - rightEven/rightOdd: Sum of even/odd indices to the right of i (before removal)</p> <p>After Removal of \\(A_i\\): All right side elements swap parity. - New even sum = leftEven + rightOdd - New odd sum = leftOdd + rightEven</p> <pre><code>def countSpecial(A):\n    n = len(A)\n    totalEven, totalOdd = 0,0\n    for i in range(n):\n        if i % 2 == 0:\n            totalEven += A[i]\n        else:\n            totalOdd += A[i]\n    leftEven, leftOdd = 0,0\n    special = 0\n    for i in range(n):\n        if i % 2 == 0:\n            totalEven -= A[i]\n        else:\n            totalOdd -= A[i]\n        #swap\n        newEven = leftEven + totalOdd\n        newOdd = leftOdd + totalEven\n        if newEven == newOdd: count += 1\n        #update\n        if i % 2 == 0:\n            leftEven += A[i]\n        else:\n            leftOdd += A[i]\n    return count\n</code></pre>"},{"location":"DSAyy/arrays/#find-duplicate-in-the-array","title":"Find duplicate in the array.","text":"<p>Given a read only array of n+1 int between 1 and n, find any repeated number in A in \\(O(n)\\) time and \\(O(1)\\) space.</p> <p>If no duplicate, return -1</p> <p>Example: A = 3 4 1 4 2, Output = 4 </p>"},{"location":"DSAyy/arrays/#how_12","title":"How?","text":"<p>View A as linked list.  - For every \\(i\\), next node is \\(A[i]\\). Since there are only \\(n+1\\) elements and only n values, the pigeonhole principle ensures there is a cycle. The repeated number is the start of the cycle.</p> <ul> <li> <p>Use tortoise and hare, the moment slow and fast meet, reset slow to \\(A[0]\\).</p> </li> <li> <p>When they meet again, that is the position of the duplicate number.</p> </li> </ul> <pre><code>def find_duplicates(nums):\n    slow,fast = nums[0],nums[0]\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n    #find the head of the cycle\n    slow = nums[0]\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n    return slow\n</code></pre>"},{"location":"DSAyy/arrays/#max-consecutive-gap-linear-time-bucketing","title":"Max Consecutive Gap (Linear Time Bucketing)","text":"<p>Given an non-neg int array, find max difference between successive elements in the sorted array. Return \\(0\\) if \\(n &lt; 2\\). Do this is \\(O(n)\\) time and \\(O(n)\\) space.</p> <p>Note the array is not sorted.</p>"},{"location":"DSAyy/arrays/#how_13","title":"How","text":"<p>Insight: If array has n elements, spread min to max, the min possible maximum gap (if numbers are evenly spaced) is: $$ gap = \\frac{max- min}{n - 1} $$ Idea: Divide the range \\([min,max]\\) into \\(n-1\\) buckets of size \\(\\geq\\) gap. Place each element in the bucket. The max gap is the difference between the min of the next non-empty bucket and the max of previous.</p> <pre><code>import math\ndef maximum_gap(nums):\n    n = len(nums)\n    if n &lt; 2: return 0\n    minA = min(nums)\n    maxA = max(nums)\n    if minA == maxA: return 0\n    #step 1 compute the bucket size\n    gap = max(1,math.ceil((maxA - minA)/(n-1)))\n    bucket_count = (maxA - minA) // gap + 1\n    #step 2: Init the buckets\n    buckets = [[math.inf, -math.inf] for _ in range(bucket_count)]\n    #step 3: place each num into bucket\n    for x in nums:\n        idx = (x - minA) // gap\n        buckets[idx][0] = min(bucket[idx][0],x) #min\n        buckets[idx][1] = max(bucket[idx][1],x) #max\n    #step 4: scan buckets to find the maximum gap\n    max_gap = 0\n    prev_max = minA\n    for b_min, b_max in buckets:\n        if b_min == math.inf: #Empty bucket\n            continue\n        max_gap = max(max_gap, b_min - prev_max)\n        prev_max = b_max\n    return max_gap\n</code></pre>"},{"location":"DSAyy/arrays/#arrangements","title":"Arrangements","text":""},{"location":"DSAyy/arrays/#sort-array-with-squares","title":"Sort Array with Squares!","text":"<p>Given a sorted array on numbers, return a new array of squares of all elements sorted in non-decreasing order. Do this in \\(O(n)\\) time.</p> <p>Ex: A = -6 - 3 -1 2 4 5, Output: 1,4,9,16,25,36</p> <p>Basic two pointer. Just compare left and right, and compute the output from the end in descending order. <pre><code>def sorted_squares(A):\n    n = len(A)\n    res = [0]*n\n    left,right = 0,n-1\n    idx = n-1\n    while left &lt;= right:\n        if A[left]**2 &gt; A[right]**2:\n            res[idx] = A[left]**2\n            left += 1\n        else:\n            res[idx] = A[right] ** 2\n            right -= 1\n        idx -= 1\n    return res\n</code></pre></p>"},{"location":"DSAyy/arrays/#largest-number-from-array","title":"Largest Number from Array","text":"<p>Given array of non-neg numbers, arrange them to form the largest possible number. Return the result as a string.</p> <p>Example: <code>3 30 34 5 9</code>, Output: <code>9534330</code></p> <p>Largest Number is not the one with the largest number first, but with the largest concatenation first.</p> <p>Compare function \\(ab\\) vs \\(ba\\)</p> <pre><code>from functools import cmp_to_key\ndef largestNumber(nums):\n    #convert int to str\n    nums = list(map(str,nums))\n    #custom comparator\n    def compare(a,b):\n        return(int(b+a) - int(a + b))\n    nums.sort(key = cmp_to_key(compare))\n    #edge case\n    if nums[0] == \"0\":\n        return \"0\"\n    return ''.join(nums)\n</code></pre>"},{"location":"DSAyy/arrays/#rotate-matrix-in-place","title":"Rotate Matrix (in Place)","text":"<p>Given \\(N \\times N\\) matrix A, rotate it by \\(90 \\degree\\) in place.</p> <p>Ex:  1 2  -&gt; 3 1</p> <p>3 4  -&gt; 4 2</p> <p>Bas transpose the matrix and  reverse every row.</p> <pre><code>def rotate(A):\n    n = len(A)\n    for i in range(n):\n        for j in range(n):\n            A[i][j], A[j][i] = A[j][i],A[i][j]\n    for i in range(n):\n        reverse(A[i])\n</code></pre>"},{"location":"DSAyy/arrays/#next-permutation-in-place-lexicographically-next","title":"Next Permutation (In-place, Lexicographically Next)","text":"<p>Given an int array, give the next lexicographically next permutation.</p> <p>If not possible, rearrange as lowest possible order ever (next_permutation literally)</p> <p>A = 1 3 5 4 2 -&gt; 1 4 2 3 5</p>"},{"location":"DSAyy/arrays/#how_14","title":"How","text":"<ol> <li>Find the first decreasing element from the right.</li> <li>If such element exists at i, Find the largest index j (farthest), such that it is greater than this element. Fir swap karde inhe.</li> <li>Reverse the subarray from \\(A[i+1]\\) to the end.</li> </ol> <pre><code>def next_permutation(A):\n    n = len(A)\n    i = n-2\n    while i &gt; 0 and A[i] &gt;= A[i+1]:\n        i -= 1\n    if i &gt;= 0:\n        j = n-1\n        while A[j] &lt;= A[i]:\n            j -= 1\n        A[i],A[j] = A[j],A[i]\n    A[i+1:] = reversed(A[i+1:])\n    return A\n</code></pre>"},{"location":"DSAyy/arrays/#find-permutation-given-di-string","title":"Find Permutation Given D/I String","text":"<p>Given int n and a string s of length n-1, consisting of D (Decrease), and I (increase), construct any permutation of 1..n so that - \\(s[i] = I ? perm[i] &lt; perm[i+1]\\) - \\(s[i] = D ?\\) \\(perm[i] &gt; perm[i+1\\)] Return in \\(O(n)\\) time.</p> <p>Ex: s = ID, output = 1 3 2</p>"},{"location":"DSAyy/arrays/#how_15","title":"How?","text":"<p>Greedy nigga. Keep two pointers low = 1, and high = n-1. For each character in s: If I, put the smallest unused number, If D, put the largest unused number. </p> <p>In the end there would be one number left, put that in the last position.</p> <pre><code>def findPerm(S):\n    n = len(S) + 1\n    low,high = 1,n\n    ans = []\n    for c in S:\n        if c == 'I':\n            ans.append(low)\n            low += 1\n        else:\n            ans.append(high)\n            high -= 1\n    ans.append(low)\n    return ans\n</code></pre>"},{"location":"DSAyy/arrays/#occurence-of-each-number","title":"Occurence of Each Number","text":"<p>Given an array, output the number of times each unique number occurs in A (sorted by their values themselves). Return the list of occurences.</p> <p>A = 4 3 3, Output =  2 1</p> <pre><code>def occ(A):\n    freq = {}\n    for x in A:\n        freq[x] = freq.get(x,0) + 1\n    keys = sorted(freq.keys())\n    return [freq[k] for k in keys]\n</code></pre>"},{"location":"DSAyy/arrays/#noble-integer","title":"Noble Integer","text":"<p>Given array on integers. Is there an integer<code>p</code> in there such that the number of elements strictly greater than <code>p</code> is exactly <code>p</code>? Return 1 if yes else -1</p> <p>Ex: 3 2 1 3, ans = 2</p>"},{"location":"DSAyy/arrays/#how_16","title":"How","text":"<p>Facts: p must be \\geq 0 since num of els greater cannot be negative. Multiple p may exist.</p> <ol> <li>Count freq of each value</li> <li>For all p from \\(N-1\\) to \\(0\\), maintain <code>bigger</code> = number of elements \\(&gt;\\) <code>p</code></li> <li>If bigger = <code>p</code>, return 1</li> <li>else -1 <pre><code>def noble(A):\n    N = len(A)\n    freq = [0]*(N+1)\n    for x in A:\n        if 0 &lt;= x &lt; N:\n            freq[x] += 1\n        elif x &gt;= N: freq[N] += 1\n    bigger = freq[N]\n    for p in range(N-1,-1,-1):\n        if freq[p] &gt; 0 and bigger == p:\n            return 1\n        bigger += freq[p]\n    return -1\n</code></pre></li> </ol>"},{"location":"DSAyy/arrays/#reorder-data-in-log-files","title":"Reorder Data in Log Files","text":"<p>Given an array of logs (strings with identifier and words), reorder as follows: 1. Letter-logs (word after identifier are all lowercase letters) come before digit logs. 2. Letter-logs are sorted lexicographically by content, then by identifier. 3. Digit-logs (words after the identifier are all digits) remain in original order.</p> <p>Letter logs: let1 art can Digit Logs: dig1 8 1 5 1</p>"},{"location":"DSAyy/arrays/#how_17","title":"How","text":"<ol> <li>Step 1: Parse Each log into its identifier and body.</li> <li>Step 2: Classify as letter-log or digit-log using first char of body.</li> <li>Step 3: Sort all logs by rules above. (stable-sort for digit logs)</li> </ol> <pre><code>from typing import List\ndef reorderLogFiles(logs: List[str]) -&gt; List[str]:\n    def get_key(log):\n        identifier, rest = log.split(\" \",1)\n        is_digit = rest[0].isdigit()\n        return (1,) if is_digit else (0, rest, identifier)\n    return sorted(logs, key = get_key)\n</code></pre>"},{"location":"DSAyy/arrays/#set-intersection-at-least-two-per-interval","title":"Set Intersection (At least Two Per Interval)","text":"<p>Given N intervals \\([L_i, R_i]\\), find the length smallest set S of integers such that every interval contains at least two elements from S.</p> <p>Ex: A = (1,3) (1,4) (2,5) (3,5). Answer 2 (els are 3 and 5)</p>"},{"location":"DSAyy/arrays/#how_18","title":"How","text":"<p>Greedy sorting. - Sort intervals by right endpoint b (ascending), breaking ties by endpoint a (descending).  - For each interval, always try to use the largest available numbers (right points) to minimize with future overlap.</p> <p>Algorithm 1. Sort intervals by end (right endpoint), breaking ties by start (descending). 2. Track the two largest selected points so far \\((p_1 &lt; p_2)\\). 3. For each interval \\([a,b]\\):     - If \\(a &gt; p_2\\): no points in \\([a,b]\\) in our set -&gt; pick \\(b-1\\) and \\(b\\)     - If \\(a &gt; p_1\\): only \\(p_2\\) in \\([a,b]\\) -&gt; b     - Else: both \\(p_1\\) and \\(p_2\\) in \\([a,b]\\) : do nothing</p> <pre><code>from typing import List\ndef setIntersection(intervals: List[List[int]]) -&gt; int:\n    intervals.sort(key = lambda x: (x[1], -x[0]))\n    p1,p2 = float('-inf'), float('inf') #last two selected points\n    ans = 0\n    for a,b in intervals:\n        if a &gt; p2:\n            #no selected points in [a,b]L pick b-1 and b\n            ans += 2\n            p1, p2 = b-1, b\n        elif a &gt; p1:\n            #only one selected element in [a,b]: pick b\n            ans += 1\n            p1,p2 = p2, b\n    return ans\n</code></pre>"},{"location":"DSAyy/arrays/#wave-array-lexicographically-smallest-counting-sort-values","title":"Wave Array (Lexicographically Smallest, Counting Sort Values)","text":"<p>Given array of int, rearrange such that:  $$ A_1 \\geq A_2 \\leq A_3 \\geq A_4 \\leq ... $$ Among all possible answers, output the lexicographically smallest.</p>"},{"location":"DSAyy/arrays/#how_19","title":"How","text":"<ol> <li>Lexicographically Smallest wave: sort karde.</li> <li>For large \\(N\\) but small values, use counting sort instead of comparison sort.</li> <li>Swap adjacent pair \\((i-1,i)\\) for  \\(i = 1,3,5..\\) Basically bas: \\(A_2, A_1, A_4, A_3, ..\\) after sorting</li> </ol> <p><pre><code>from typing import List\ndef waveArray(A: List[int])-&gt; List[int]:\n    n = len(A)\n    if n &lt; 2: return A[:]\n    maxV = max(A)\n    cnt = [0]*(maxV + 1)\n    for x in A: cnt[x] += 1\n    B = []\n    for v in range(maxV + 1):\n        while cnt[v] &gt; 0:\n            B.append(v)\n            cnt[v] -= 1\n    for i in range(1,n,2):\n        B[i], B[i-1] = B[i-1],B[i]\n    return B\n</code></pre> \\(O(N+V)\\) Time complexity.</p>"},{"location":"DSAyy/arrays/#hotel-bookings-possible","title":"Hotel Bookings Possible","text":"<p>Given \\(A\\) (arrival dates) and \\(B\\) (departure dates) of \\(N\\) bookings, can a hotel with \\(C\\) rooms serve all without conflict. <pre><code>from typing import List\ndef hotel(arrive: List[int], depart: List[int], K: int) -&gt; bool:\n    arrive.sort()\n    arrive.sort()\n    rooms_in_use = 0\n    i = j = 0\n    N = len(arrive)\n    while i &lt; N:\n        if arrive[i] &lt; depart[j]:\n            rooms_in_use += 1\n            if rooms_in_use &gt; K:\n                return False\n            i += 1\n        else:\n            rooms_in_use -= 1\n            j += 1\n    return True\n</code></pre></p>"},{"location":"DSAyy/arrays/#max-distance-a_i-leq-a_j-two-pointer-method","title":"Max Distance (\\(A_i \\leq A_j\\)) - Two Pointer Method","text":"<p>Given array of integers, find largest \\(j - i\\) such that \\(A[i] \\leq A[j]\\)</p> <p>Ex: 3 5 4 2, Answer : 2</p> <p>Key idea: preprocess so you can, for each i, quickly find the farthest j such that \\(A_i \\leq A_j\\). 1. Build \\(LMin[i]\\) as min value for \\(0\\) to \\(i\\) 2. Similarly build \\(RMax[i]\\) for max from \\(j\\) to \\(N-1\\) 3. Use two pointers, always ensuring \\(LMin[i] \\leq RMax[j]\\) 4. For every valid pair, record \\(j - i\\) as candidate answer.</p> <pre><code>def maximumGap(A):\n    N = len(A)\n    if N &gt; 2: return 0\n    LMin = [0]*N\n    RMax = [0]*N\n    LMin[0] = A[0]\n    for i in range(1,N):\n        LMin[i] = min(LMin[i-1], A[i])\n    RMax[N-1] = A[N-1]\n    for i in range(N-2,-1,-1):\n        RMax[i] = max(RMax[i+1], A[i])\n    #two pointer traversal\n    i = j = 0\n    maxDiff = 0\n    while i &lt; N and j &lt; N:\n        if LMin[i] &lt;= RMax[j]:\n            maxDiff = max(maxDIff, j - i)\n            j += 1\n        else:\n            i += 1\n    return maxDiff\n</code></pre>"},{"location":"DSAyy/arrays/#maximum-unsorted-subarray-linear-approach","title":"Maximum Unsorted Subarray (Linear Approach)","text":"<p>Given an array of length N, find smallest interval \\([l,r]\\) such that sorting \\(A[l...r]\\) sorts the entire array. If A is already sorted, return \\([-1]\\).</p>"},{"location":"DSAyy/arrays/#how_20","title":"How","text":"<p>Any unsorted part will be where an element is something to its left, or larger than something on its right. So traverse left to right, tracking max seen so far to find the right boundary. Tracking left to right, tracking min seen so far to find the left boundary.</p> <ol> <li>Sweep left -&gt; right, track max_seen. For \\(A[i] &lt; max_seen\\), set \\(r = i\\)</li> <li>Same right -&gt; left for min_seen. For \\(A[i] &gt; min_seen\\), set \\(l = i\\)</li> <li>If \\(l &gt; r\\), array already sorted, output \\(- 1\\)</li> <li>otherwise output \\([l,r]\\)</li> </ol> <pre><code>def sub_unsort(A):\n    N = len(A)\n    if N &lt; 2: return [-1]\n    start,end = -1, -2 #ensure end &lt; start if already sorted\n    maxSeen = A[0]\n    minSeen = A[-1]\n    #left to right\n    for i in range(1,N):\n        maxSeen = max(maxSeen, A[i])\n        if A[i] &lt; maxSeen:\n            end = i\n    #right to left\n    for i in range(N-2,-1,-1):\n        minSeen = max(minSeen, A[i])\n        if A[i] &gt; minSeen:\n            start = i\n    if start &gt; end: return [-1]\n    return [start,end]\n</code></pre>"},{"location":"DSAyy/arrays/#set-matrix-zeroes-in-place","title":"Set Matrix Zeroes. (in place)","text":"<p>Given matrix of size \\(M \\times N\\), If any element is 0, set its entire row and column to 0.</p> <p>Just use first row and columns as marker.</p> <pre><code>def setZeroes(matrix):\n    rows,cols = len(matrix), len(matrix[0])\n    row0 = any(matrix[0][j] == 0 for j in range(cols))\n    for i in range(1,rows):\n        for j in range(cols):\n            if matrix[i][j] == 0:\n                matrix[i][0] = matrix[0][j] = 0\n    for i in range(1,rows):\n        if matrix[i][0] == 0:\n            for j in range(cols):\n                matrix[i][j] = 0\n    for j in range(cols):\n        if matrix[0][j] == 0:\n            for i in range(rows):\n                matrix[i][j] = 0\n    if row0:\n        for j in range(cols):\n            matrix[0][j] = 0\n</code></pre>"},{"location":"DSAyy/arrays/#maximum-sum-square-submatrix","title":"Maximum Sum Square SubMatrix","text":"<p>Given a matrix A, and an int B. Find the submatrix \\(B \\times B\\) submatrix with the largest sum of elements.</p> <p>2D prefix sum easy.</p> <pre><code>def max_sum_submatrix(A,B):\n    N,M = len(A), len(A[0])\n    #build psum array\n    P = [[0]*M for _ in range(N)]\n    for i in range(N):\n        for j in range(M):\n            P[i][j] = A[i][j]\n            if i &gt; 0: P[i][j] += P[i-1][j]\n            if j &gt; 0: P[i][j] ++ P[i][j-1]\n            if i &gt; 0 and j &gt; 0: P[i][j] -= P[i-1][j-1]\n    max_sum = float('-inf')\n    for i in range(B-1,N):\n        for j in range(B-1,M):\n            total = P[i][j]\n            if i &gt;= B: total -= P[i-B][j]\n            if j &gt;= B: total -= P[i][j-B]\n            if i &gt;= B and j &gt;= B: total += P[i-B][j-B]\n            max_sum = max(max_sum, total)\n    return max_sum\n</code></pre>"},{"location":"DSAyy/arrays/#first-missing-positive-integer","title":"First Missing Positive Integer.","text":"<p>Given an unsorted array of N integers, find smallest positive integer that does not occur in A.</p> <p>Ex: 3 4 5 1, output: 2</p> <ol> <li>Replace out of bounds: negative? set it to N+1 (max ans is N+1)</li> <li>Index Negation: if \\(A[i] \\in [1,N]\\) mark \\(A[|A[i]| - 1]\\) negative.</li> <li>First positive index. Scan A, first index k with \\(A[k] &gt; 0\\), \\(k+1\\) is missing.</li> <li>All present, return \\(N+1\\)</li> </ol> <pre><code>def firstMissingPositive(A):\n    N = len(A)\n    for i in range(N):\n        if A[i] &lt;= 0 or A[i] &gt; N: #ye to ans ke range meh hi nahi\n            A[i] = N+1 #max ans\n    #max presence using negative signs\n    for i in range(N):\n        x = abs(A[i])\n        if 1 &lt;= x &lt;= N:\n            A[x-1] = -abs(A[x-1])\n    #find the pos (saare present ko toh negative mark kar diya)\n    for i in range(N):\n        if A[i] &gt; 0: return i+1\n    return N+1\n</code></pre>"},{"location":"DSAyy/arrays/#repeat-and-missing-number","title":"Repeat and Missing Number","text":"<p>Given an array of size \\(n\\), containing number from 1 to \\(n\\), one number is missing and one number is repeated. Find both these number. (goldman sachs meh poocha mujhse last year)</p> <p>Ex: A = 1 2 3 4, Output = \\([2,3]\\)</p>"},{"location":"DSAyy/arrays/#how_21","title":"How","text":"<p>Sums and Squares bitch. $$ S_{expected} = \\frac{n(n+1)}{2} $$ $$ Q_{expected} = 1^2 + 2^2 ..n^2 = \\frac{n(n+1)(2n+1)}{6} $$ $$ S_{actual} = \\sum A[i] = S_{exp} + (A-B) $$ $$ Q_{act} = \\sum A[i]^2 = Q_{exp} + (A^2 - B^2) $$ $$ \\Delta S = S_{act} - S_{exp} = A-B $$ $$ \\Delta Q = Q_{act} - Q_{exp} = A^2 - B^2 = (A-B)(A+B) = \\Delta S \\times(A+B) $$</p> <p>So... $$ A+B = \\frac{\\Delta Q}{\\Delta S} $$ Now solve.. $$ A - B = \\Delta S $$ $$ A + B = \\frac{\\Delta Q}{\\Delta S} $$ $$ A = \\frac{\\Delta S + \\frac{\\Delta Q}{\\Delta S}}{2} $$ $$ B = A - \\Delta S $$</p> <pre><code>def repeated_missing(A):\n    N = len(A)\n    S_exp = N*(N+1)//2\n    Q_exp = N*(N+1)*(2*N+1)//6\n    S_act = sum(A)\n    Q_act = sum(x*x for x in A)\n    del_S = S_act - S_exp\n    del_Q = Q_act - Q_exp\n    sumAB = del_Q//del_S\n    A_rep = (sumAB + del_S) // 2\n    B_miss = A_rep - del_S\n    return [A_rep, B_miss]\n</code></pre>"},{"location":"DSAyy/arrays/#n3-repeat-number","title":"N/3 Repeat Number","text":"<p>Given array of integers of size N, find any integer that appears strictly more than \\(\\lfloor N/3 \\rfloor\\) times. Return -1 if none exists.</p>"},{"location":"DSAyy/arrays/#how_22","title":"How","text":"<p>Boyer-Moore Voting. - Track two candidates and their counts. - First pass: Find up to two potential candidates. - Second pass: Check if they actually appear N/3 times. <pre><code>def repeated_number(A):\n    c1 = c2 = cnt1 = cnt2 = 0\n    for x in A:\n        if x == c1: cnt1 += 1\n        elif x == c2: cnt2 += 1\n        elif cnt1 == 0: c1,cnt1 = x,1\n        elif cnt2 == 0: c2,cnt2 = x,1\n        else:\n            cnt1 -= 1\n            cnt2 -= 1\n    cnt1 = sum(x == c1 for x in A)\n    cnt2 = sum(x == c2 for x in A)\n    n = len(A)\n    if cnt1 &gt; n // 3: return c1\n    if cnt2 &gt; n // 3: return c2\n    return -1\n</code></pre></p>"},{"location":"DSAyy/backtracking/","title":"N-Queens Problem","text":""},{"location":"DSAyy/backtracking/#problem-statement","title":"Problem Statement","text":"<p>Given an integer \\(n\\), place \\(n\\) queens on an \\(n \\times n\\) chessboard so that no two queens attack each other.</p> <p>Return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration where <code>'Q'</code> and <code>'.'</code> indicate a queen and an empty space, respectively.</p>"},{"location":"DSAyy/backtracking/#constraints","title":"Constraints:","text":"<ul> <li>\\(1 \\leq n \\leq 9\\)</li> </ul>"},{"location":"DSAyy/backtracking/#key-insight","title":"Key Insight","text":"<p>A queen attacks all cells in the same: - row, - column, - diagonal (both directions).</p> <p>We use backtracking to build the solution row by row: - At each row, try placing a queen in each column - Skip columns/diagonals that are already under attack - Use sets to track columns and diagonals in use</p>"},{"location":"DSAyy/backtracking/#python-code","title":"Python Code","text":"<pre><code>def solveNQueens(n):\n    res = []\n    board = [['.'] * n for _ in range(n)]\n    cols = set()\n    pos_diag = set()  # (r + c)\n    neg_diag = set()  # (r - c)\n\n    def backtrack(r):\n        if r == n:\n            res.append([\"\".join(row) for row in board])\n            return\n        for c in range(n):\n            if c in cols or (r + c) in pos_diag or (r - c) in neg_diag:\n                continue\n            board[r][c] = 'Q'\n            cols.add(c)\n            pos_diag.add(r + c)\n            neg_diag.add(r - c)\n\n            backtrack(r + 1)\n\n            board[r][c] = '.'\n            cols.remove(c)\n            pos_diag.remove(r + c)\n            neg_diag.remove(r - c)\n\n    backtrack(0)\n    return res\n</code></pre>"},{"location":"DSAyy/backtracking/#sudoku-solver","title":"Sudoku Solver","text":""},{"location":"DSAyy/backtracking/#problem-statement_1","title":"Problem Statement","text":"<p>Fill a 9\u00d79 Sudoku board so that every row, column, and 3\u00d73 subgrid contains the digits 1 through 9 exactly once. Empty cells are represented by <code>'.'</code>.</p> <p>Modify the input board in-place to produce the solution.</p>"},{"location":"DSAyy/backtracking/#key-insight_1","title":"Key Insight","text":"<p>Sudoku is a classic constraint satisfaction problem. We use backtracking with these optimizations:</p> <ul> <li>Track used digits in each row, column, and box using bitmasks.</li> <li>At each step, pick the empty cell with minimum available choices (MRV heuristic).</li> <li>Try each valid digit, recurse, and backtrack if needed.</li> </ul>"},{"location":"DSAyy/backtracking/#python-code_1","title":"Python Code","text":"<pre><code>def solveSudoku(board):\n    N = 9\n    row_mask = [0] * N\n    col_mask = [0] * N\n    box_mask = [0] * N\n    empties = []\n\n    def get_box(r, c):\n        return (r // 3) * 3 + (c // 3)\n\n    for r in range(N):\n        for c in range(N):\n            if board[r][c] == '.':\n                empties.append((r, c))\n            else:\n                d = int(board[r][c]) - 1\n                bit = 1 &lt;&lt; d\n                row_mask[r] |= bit\n                col_mask[c] |= bit\n                box_mask[get_box(r, c)] |= bit\n\n    def dfs(idx):\n        if idx == len(empties):\n            return True\n\n        # MRV heuristic\n        best = idx\n        min_options = 10\n        for i in range(idx, len(empties)):\n            r, c = empties[i]\n            b = get_box(r, c)\n            avail = ~(row_mask[r] | col_mask[c] | box_mask[b]) &amp; 0x1FF\n            count = bin(avail).count('1')\n            if count &lt; min_options:\n                min_options = count\n                best = i\n                if count == 1:\n                    break\n\n        if min_options == 0:\n            return False\n\n        empties[idx], empties[best] = empties[best], empties[idx]\n        r, c = empties[idx]\n        b = get_box(r, c)\n        avail = ~(row_mask[r] | col_mask[c] | box_mask[b]) &amp; 0x1FF\n\n        while avail:\n            p = avail &amp; -avail\n            avail -= p\n            d = (p).bit_length() - 1\n            board[r][c] = str(d + 1)\n            row_mask[r] |= p\n            col_mask[c] |= p\n            box_mask[b] |= p\n\n            if dfs(idx + 1):\n                return True\n\n            board[r][c] = '.'\n            row_mask[r] ^= p\n            col_mask[c] ^= p\n            box_mask[b] ^= p\n\n        empties[idx], empties[best] = empties[best], empties[idx]\n        return False\n\n    dfs(0)\n</code></pre>"},{"location":"DSAyy/backtracking/#permutations-backtracking","title":"Permutations (Backtracking)","text":""},{"location":"DSAyy/backtracking/#problem-statement_2","title":"Problem Statement","text":"<p>Given a list of distinct integers \\(A\\), return all possible permutations of the elements in any order.</p>"},{"location":"DSAyy/backtracking/#example","title":"Example","text":"<pre><code>Input: A = [1, 2, 3]\nOutput:\n[\n [1, 2, 3],\n [1, 3, 2],\n [2, 1, 3],\n [2, 3, 1],\n [3, 1, 2],\n [3, 2, 1]\n]\n</code></pre>"},{"location":"DSAyy/backtracking/#key-insight_2","title":"Key Insight","text":"<p>Permutations are generated by trying every number at every position.</p> <p>At each recursion level (position in permutation):</p> <ul> <li> <p>Swap current index with every possible candidate index</p> </li> <li> <p>Recurse</p> </li> <li> <p>Swap back (backtrack)</p> </li> </ul> <p>This is an in-place backtracking strategy.</p>"},{"location":"DSAyy/backtracking/#python-code_2","title":"Python Code","text":"<pre><code>def permute(nums):\n    res = []\n    n = len(nums)\n\n    def backtrack(idx):\n        if idx == n:\n            res.append(nums[:])\n            return\n        for i in range(idx, n):\n            nums[i], nums[idx] = nums[idx], nums[i]\n            backtrack(idx + 1)\n            nums[i], nums[idx] = nums[idx], nums[i]\n\n    backtrack(0)\n    return res\n</code></pre>"},{"location":"DSAyy/backtracking/#generate-all-parentheses-well-formed-combinations","title":"Generate All Parentheses (Well-Formed Combinations)","text":""},{"location":"DSAyy/backtracking/#problem-statement_3","title":"Problem Statement","text":"<p>Given an integer \\(n\\), generate all combinations of well-formed parentheses consisting of \\(n\\) pairs.</p>"},{"location":"DSAyy/backtracking/#example_1","title":"Example","text":"<pre><code>Input: n = 3\nOutput: [\n \"((()))\",\n \"(()())\",\n \"(())()\",\n \"()(())\",\n \"()()()\"\n]\n</code></pre>"},{"location":"DSAyy/backtracking/#crazy-insight","title":"Crazy insight","text":"<p>A valid parentheses sequence must:</p> <ul> <li> <p>Never have more <code>)</code> than <code>(</code> at any point</p> </li> <li> <p>Contain exactly \\(n\\) <code>(</code> and \\(n\\) <code>)</code></p> </li> </ul> <p>We use backtracking to build the string:</p> <ul> <li> <p>Add <code>(</code> if we still have some left</p> </li> <li> <p>Add <code>)</code> only if it doesn't exceed <code>(</code> used so far</p> </li> </ul>"},{"location":"DSAyy/backtracking/#python-code_3","title":"Python Code","text":"<pre><code>def generateParenthesis(n):\n    res = []\n\n    def backtrack(open_count, close_count, current):\n        if len(current) == 2 * n:\n            res.append(current)\n            return\n        if open_count &lt; n:\n            backtrack(open_count + 1, close_count, current + '(')\n        if close_count &lt; open_count:\n            backtrack(open_count, close_count + 1, current + ')')\n\n    backtrack(0, 0, \"\")\n    return res\n</code></pre>"},{"location":"DSAyy/backtracking/#example_2","title":"Example","text":"<pre><code>generateParenthesis(2)\n# Output: [\"(())\", \"()()\"]\n</code></pre>"},{"location":"DSAyy/backtracking/#time-space-complexity","title":"Time &amp; Space Complexity","text":"<ul> <li> <p>Time: \\(O(2^{2n})\\) in the worst case (each position has 2 choices), but pruned by constraints</p> </li> <li> <p>Space: \\(O(n)\\) recursion depth; output size is Catalan number \\(C_n\\)</p> </li> </ul>"},{"location":"DSAyy/backtracking/#palindrome-partitioning","title":"Palindrome Partitioning","text":""},{"location":"DSAyy/backtracking/#problem-statement_4","title":"Problem Statement","text":"<p>Given a string \\(s\\), partition it such that every substring in the partition is a palindrome.</p> <p>Return all possible palindrome partitionings of \\(s\\).</p>"},{"location":"DSAyy/backtracking/#example_3","title":"Example","text":"<pre><code>Input: s = \"aab\"\nOutput: [\n [\"a\", \"a\", \"b\"],\n [\"aa\", \"b\"]\n]\n</code></pre>"},{"location":"DSAyy/backtracking/#key-insight_3","title":"Key Insight","text":"<p>Use backtracking to explore all substring partitions.</p> <p>At each index:</p> <ul> <li> <p>Try all substrings <code>s[i:j+1]</code></p> </li> <li> <p>If it's a palindrome, add it to current path and recurse</p> </li> <li> <p>Backtrack and try the next cut</p> </li> </ul> <p>To speed up palindrome checks, precompute a 2D table <code>is_pal[i][j]</code> that tells whether <code>s[i:j+1]</code> is a palindrome.</p>"},{"location":"DSAyy/backtracking/#python-code_4","title":"Python Code","text":"<pre><code>def partition(s):\n    n = len(s)\n    res = []\n    is_pal = [[False]*n for _ in range(n)]\n\n    for l in range(1, n + 1):\n        for i in range(n - l + 1):\n            j = i + l - 1\n            if s[i] == s[j] and (l &lt;= 2 or is_pal[i+1][j-1]):\n                is_pal[i][j] = True\n\n    def backtrack(start, path):\n        if start == n:\n            res.append(path[:])\n            return\n        for end in range(start, n):\n            if is_pal[start][end]:\n                path.append(s[start:end+1])\n                backtrack(end + 1, path)\n                path.pop()\n\n    backtrack(0, [])\n    return res\n</code></pre>"},{"location":"DSAyy/backtracking/#example_4","title":"Example","text":"<pre><code>partition(\"aab\")\n# Output: [[\"a\", \"a\", \"b\"], [\"aa\", \"b\"]]\n</code></pre>"},{"location":"DSAyy/backtracking/#time-space-complexity_1","title":"Time &amp; Space Complexity","text":"<ul> <li> <p>Time: \\(O(2^n \\cdot n)\\) in worst case (exponential partitions with substring checks)</p> </li> <li> <p>Space: \\(O(n^2)\\) for <code>is_pal</code> table and recursion</p> </li> </ul>"},{"location":"DSAyy/backtracking/#letter-combinations-of-a-phone-number","title":"Letter Combinations of a Phone Number","text":""},{"location":"DSAyy/backtracking/#problem-statement_5","title":"Problem Statement","text":"<p>Given a string of digits from 0\u20139, return all possible letter combinations based on telephone keypad mapping.</p>"},{"location":"DSAyy/backtracking/#digit-to-letter-mapping","title":"Digit to Letter Mapping:","text":"<pre><code>2 \u2192 abc 3 \u2192 def  \n4 \u2192 ghi 5 \u2192 jkl  \n6 \u2192 mno 7 \u2192 pqrs  \n8 \u2192 tuv 9 \u2192 wxyz  \n0 \u2192 0 1 \u2192 1\n</code></pre>"},{"location":"DSAyy/backtracking/#example_5","title":"Example","text":"<pre><code>Input: digits = \"23\"\nOutput: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]\n</code></pre>"},{"location":"DSAyy/backtracking/#bc-insight","title":"BC Insight","text":"<p>This is a Cartesian product of characters mapped from each digit.</p> <p>Use backtracking to build all combinations:</p> <ul> <li> <p>At each index, try every letter for the current digit</p> </li> <li> <p>Recurse to the next digit</p> </li> <li> <p>When complete, add to result</p> </li> </ul>"},{"location":"DSAyy/backtracking/#python-code_5","title":"Python Code","text":"<pre><code>def letterCombinations(digits):\n    if not digits:\n        return []\n\n    mapping = [\n        \"0\", \"1\", \"abc\", \"def\", \"ghi\",\n        \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"\n    ]\n\n    res = []\n\n    def backtrack(idx, path):\n        if idx == len(digits):\n            res.append(\"\".join(path))\n            return\n        for c in mapping[int(digits[idx])]:\n            path.append(c)\n            backtrack(idx + 1, path)\n            path.pop()\n\n    backtrack(0, [])\n    return res\n</code></pre>"},{"location":"DSAyy/backtracking/#example_6","title":"Example","text":"<pre><code>letterCombinations(\"2\")\n# Output: [\"a\", \"b\", \"c\"]\n</code></pre>"},{"location":"DSAyy/backtracking/#time-space-complexity_2","title":"Time &amp; Space Complexity","text":"<ul> <li> <p>Time: \\(O(4^n)\\) where \\(n\\) is length of input (max 4 letters per digit)</p> </li> <li> <p>Space: \\(O(n)\\) for recursion stack</p> </li> </ul>"},{"location":"DSAyy/backtracking/#gray-code-sequence","title":"Gray Code Sequence","text":""},{"location":"DSAyy/backtracking/#problem-statement_6","title":"Problem Statement","text":"<p>Given a non-negative integer \\(n\\), generate the Gray code sequence of length \\(2^n\\) starting from \\(0\\).</p> <p>In Gray code, two successive values differ in only one bit.</p>"},{"location":"DSAyy/backtracking/#example_7","title":"Example","text":"<pre><code>Input: n = 2\nOutput: [0, 1, 3, 2]\n</code></pre> <p>Explanation:</p> <ul> <li> <p>Binary of 0: 00</p> </li> <li> <p>Binary of 1: 01</p> </li> <li> <p>Binary of 3: 11</p> </li> <li> <p>Binary of 2: 10     Each step differs from the previous by exactly one bit.</p> </li> </ul>"},{"location":"DSAyy/backtracking/#shizuka-insight","title":"Shizuka Insight","text":"<p>There are two main methods to generate Gray codes:</p> <ol> <li> <p>Backtracking / Reflection (not used here):</p> <ul> <li>For \\(n\\) bits: prepend <code>0</code> to Gray codes of \\(n-1\\) bits, then prepend <code>1</code> to their reverse</li> </ul> </li> <li> <p>Direct Formula (used here):</p> <ul> <li> <p>The \\(i^{\\text{th}}\\) Gray code:</p> <p>\\(gray(i)=i\u2295(i\u226b1)\\text{gray}(i) = i \\oplus (i \\gg 1)\\)</p> </li> </ul> </li> </ol>"},{"location":"DSAyy/backtracking/#python-code_6","title":"Python Code","text":"<pre><code>def grayCode(n):\n    result = []\n    for i in range(1 &lt;&lt; n):  # 0 to 2^n - 1\n        result.append(i ^ (i &gt;&gt; 1))\n    return result\n</code></pre>"},{"location":"DSAyy/backtracking/#example_8","title":"Example","text":"<pre><code>grayCode(3)\n# Output: [0, 1, 3, 2, 6, 7, 5, 4]\n</code></pre>"},{"location":"DSAyy/backtracking/#time-space-complexity_3","title":"Time &amp; Space Complexity","text":"<ul> <li> <p>Time: \\(O(2^n)\\) for generating all values</p> </li> <li> <p>Space: \\(O(2^n)\\) for storing the sequence</p> </li> </ul>"},{"location":"DSAyy/backtracking/#kth-permutation-sequence","title":"Kth Permutation Sequence","text":""},{"location":"DSAyy/backtracking/#problem-statement_7","title":"Problem Statement","text":"<p>Given integers \\(n\\) and \\(k\\), return the \\(k^{\\text{th}}\\) permutation sequence of the numbers \\([1, 2, 3, \\dots, n]\\) in lexicographic order.</p>"},{"location":"DSAyy/backtracking/#example_9","title":"Example","text":"<pre><code>Input: n = 3, k = 4\nOutput: \"231\"\n</code></pre> <p>Permutations in order:</p> <ol> <li> <p>123</p> </li> <li> <p>132</p> </li> <li> <p>213</p> </li> <li> <p>231</p> </li> <li> <p>312</p> </li> <li> <p>321</p> </li> </ol>"},{"location":"DSAyy/backtracking/#key-insight_4","title":"Key Insight","text":"<p>Instead of generating all permutations, we can compute the \\(k^{\\text{th}}\\) directly using the factorial number system.</p> <ul> <li> <p>There are \\((n-1)!\\) permutations for each fixed first digit.</p> </li> <li> <p>At each step, choose the digit at index:</p> <p>index=\u230ak\u22121(n\u22121)!\u230b\\text{index} = \\left\\lfloor \\frac{k-1}{(n-1)!} \\right\\rfloor - Remove the chosen digit and recurse with updated \\(k\\) and \\(n\\).</p> </li> </ul>"},{"location":"DSAyy/backtracking/#python-code_7","title":"Python Code","text":"<pre><code>def getPermutation(n, k):\n    import math\n    nums = [str(i) for i in range(1, n + 1)]\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i\n\n    k -= 1  # Convert to 0-based index\n    res = []\n    for i in range(n, 0, -1):\n        f = fact[i - 1]\n        idx = k // f\n        res.append(nums[idx])\n        nums.pop(idx)\n        k %= f\n\n    return ''.join(res)\n</code></pre>"},{"location":"DSAyy/backtracking/#example_10","title":"Example","text":"<pre><code>getPermutation(4, 9)\n# Output: \"2314\"\n</code></pre>"},{"location":"DSAyy/backtracking/#time-space-complexity_4","title":"Time &amp; Space Complexity","text":"<ul> <li> <p>Time: \\(O(n^2)\\) \u2014 due to list <code>.pop()</code> being \\(O(n)\\)</p> </li> <li> <p>Space: \\(O(n)\\) for factorials, result, and remaining numbers</p> </li> </ul>"},{"location":"DSAyy/backtracking/#maximal-string-lexicographically-largest-by-swapping","title":"Maximal String (Lexicographically Largest by Swapping)","text":""},{"location":"DSAyy/backtracking/#problem-statement_8","title":"Problem Statement","text":"<p>Given a string \\(s\\) of digits and an integer \\(k\\), return the lexicographically largest string possible by performing at most \\(k\\) swaps of characters.</p> <p>Each swap can be between any two characters in the string.</p>"},{"location":"DSAyy/backtracking/#example_11","title":"Example","text":"<pre><code>Input: s = \"254\", k = 1\nOutput: \"524\"\n\nInput: s = \"254\", k = 2\nOutput: \"542\"\n</code></pre>"},{"location":"DSAyy/backtracking/#key-insight_5","title":"Key Insight","text":"<p>Use backtracking to try swapping the current character with all greater digits on the right.</p> <ul> <li> <p>At each index, find the maximum digit in the remaining substring.</p> </li> <li> <p>If a better digit exists, swap it with the current character.</p> </li> <li> <p>Try all such swaps and recurse with \\(k-1\\).</p> </li> <li> <p>Always track the current best (maximum) string seen so far.</p> </li> </ul>"},{"location":"DSAyy/backtracking/#python-code_8","title":"Python Code","text":"<pre><code>def maximalString(s, k):\n    best = [s]\n\n    def backtrack(s_list, k, idx):\n        current = ''.join(s_list)\n        if current &gt; best[0]:\n            best[0] = current\n        if k == 0 or idx == len(s_list):\n            return\n\n        max_digit = max(s_list[idx:])\n        if max_digit != s_list[idx]:\n            for i in range(len(s_list) - 1, idx - 1, -1):\n                if s_list[i] == max_digit:\n                    s_list[idx], s_list[i] = s_list[i], s_list[idx]\n                    backtrack(s_list, k - 1, idx + 1)\n                    s_list[idx], s_list[i] = s_list[i], s_list[idx]\n        else:\n            backtrack(s_list, k, idx + 1)\n\n    backtrack(list(s), k, 0)\n    return best[0]\n</code></pre>"},{"location":"DSAyy/backtracking/#example_12","title":"Example","text":"<pre><code>maximalString(\"129814999\", 4)\n# Output: \"999984211\"\n</code></pre>"},{"location":"DSAyy/backtracking/#time-space-complexity_5","title":"Time &amp; Space Complexity","text":"<ul> <li> <p>Time: \\(O((n!)^k)\\) in worst case (but small \\(n \\leq 9\\) and \\(k \\leq 5\\) makes it feasible)</p> </li> <li> <p>Space: \\(O(n)\\) for recursion stack and list manipulation</p> </li> </ul>"},{"location":"DSAyy/backtracking/#subsets-ii-all-subsets-with-duplicates","title":"Subsets II (All Subsets With Duplicates)","text":""},{"location":"DSAyy/backtracking/#problem-statement_9","title":"Problem Statement","text":"<p>Given an integer array \\(A\\) that may contain duplicates, return all possible subsets (the power set).</p> <ul> <li>Each subset must be in non-descending order</li> <li>The solution set must not contain duplicate subsets</li> <li>The output should be lexicographically sorted</li> </ul>"},{"location":"DSAyy/backtracking/#example_13","title":"Example","text":"<pre><code>Input: A = [1, 2, 2]\nOutput:\n[\n [],\n [1],\n [1, 2],\n [1, 2, 2],\n [2],\n [2, 2]\n]\n</code></pre>"},{"location":"DSAyy/backtracking/#key-insight_6","title":"Key Insight","text":"<p>Use backtracking to generate all subsets.</p> <ul> <li> <p>Sort the array to bring duplicates together.</p> </li> <li> <p>At each recursive level, skip duplicates to avoid repeated subsets.</p> </li> <li> <p>Always proceed forward (i.e., no reuse of earlier elements).</p> </li> </ul>"},{"location":"DSAyy/backtracking/#python-code_9","title":"Python Code","text":"<pre><code>def subsetsWithDup(nums):\n    res = []\n    nums.sort()\n\n    def backtrack(start, path):\n        res.append(path[:])\n        for i in range(start, len(nums)):\n            if i &gt; start and nums[i] == nums[i - 1]:\n                continue\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()\n\n    backtrack(0, [])\n    return res\n</code></pre>"},{"location":"DSAyy/backtracking/#example_14","title":"Example","text":"<pre><code>subsetsWithDup([1, 2, 2])\n# Output: [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]\n</code></pre>"},{"location":"DSAyy/backtracking/#time-space-complexity_6","title":"Time &amp; Space Complexity","text":"<ul> <li> <p>Time: \\(O(2^n)\\) subsets generated, with pruning from duplicate skipping</p> </li> <li> <p>Space: \\(O(n)\\) recursion stack + output size</p> </li> </ul>"},{"location":"DSAyy/backtracking/#combinations-k-combinations-from-1-to-n","title":"Combinations (k-Combinations from 1 to n)","text":""},{"location":"DSAyy/backtracking/#problem-statement_10","title":"Problem Statement","text":"<p>Given two integers \\(n\\) and \\(k\\), return all possible combinations of \\(k\\) numbers chosen from the range \\(1\\) to \\(n\\).</p> <ul> <li>Each combination must be in ascending order</li> <li>The result should be lexicographically sorted</li> </ul>"},{"location":"DSAyy/backtracking/#example_15","title":"Example","text":"<pre><code>Input: n = 4, k = 2\nOutput:\n[\n [1, 2],\n [1, 3],\n [1, 4],\n [2, 3],\n [2, 4],\n [3, 4]\n]\n</code></pre>"},{"location":"DSAyy/backtracking/#key-insight_7","title":"Key Insight","text":"<p>This is a combinatorial backtracking problem.</p> <ul> <li> <p>At each step, select the next number from the remaining range</p> </li> <li> <p>Use a growing list <code>path</code> to store the current combination</p> </li> <li> <p>Stop recursion when <code>k</code> elements are chosen</p> </li> <li> <p>To prune unnecessary calls, limit upper bound of loop:</p> <p>end=n\u2212remaining+1\\text{end} = n - \\text{remaining} + 1</p> </li> </ul>"},{"location":"DSAyy/backtracking/#python-code_10","title":"Python Code","text":"<pre><code>def combine(n, k):\n    res = []\n\n    def backtrack(start, path):\n        if len(path) == k:\n            res.append(path[:])\n            return\n        for i in range(start, n - (k - len(path)) + 2):\n            path.append(i)\n            backtrack(i + 1, path)\n            path.pop()\n\n    backtrack(1, [])\n    return res\n</code></pre>"},{"location":"DSAyy/backtracking/#example_16","title":"Example","text":"<pre><code>combine(3, 2)\n# Output: [[1, 2], [1, 3], [2, 3]]\n</code></pre>"},{"location":"DSAyy/backtracking/#time-space-complexity_7","title":"Time &amp; Space Complexity","text":"<ul> <li> <p>Time: \\(O\\left(\\binom{n}{k} \\cdot k\\right)\\) \u2014 total combinations \u00d7 length of each</p> </li> <li> <p>Space: \\(O(k)\\) for recursion stack; output space is also \\(O\\left(\\binom{n}{k} \\cdot k\\right)\\)</p> </li> </ul>"},{"location":"DSAyy/backtracking/#combination-sum-ii-each-number-used-at-most-once","title":"Combination Sum II (Each Number Used At Most Once)","text":""},{"location":"DSAyy/backtracking/#problem-statement_11","title":"Problem Statement","text":"<p>Given a list of integers \\(A\\) (which may contain duplicates) and a target sum \\(B\\), return all unique combinations where each number is used at most once, and the sum is exactly \\(B\\).</p> <ul> <li>Each combination must be in non-descending order</li> <li>The result must be lexicographically sorted</li> <li>The solution set must not contain duplicate combinations</li> </ul>"},{"location":"DSAyy/backtracking/#example_17","title":"Example","text":"<pre><code>Input: A = [10, 1, 2, 7, 6, 1, 5], B = 8\nOutput:\n[\n [1, 1, 6],\n [1, 2, 5],\n [1, 7],\n [2, 6]\n]\n</code></pre>"},{"location":"DSAyy/backtracking/#key-insight_8","title":"Key Insight","text":"<ul> <li> <p>Sort the input to bring duplicates together</p> </li> <li> <p>Use backtracking to explore all subsets that sum to \\(B\\)</p> </li> <li> <p>At each step:</p> <ul> <li> <p>Skip duplicates by checking if <code>A[i] == A[i-1]</code> and <code>i &gt; start</code></p> </li> <li> <p>Do not reuse the same number \u2014 move to <code>i + 1</code> after including <code>A[i]</code></p> </li> </ul> </li> </ul>"},{"location":"DSAyy/backtracking/#python-code_11","title":"Python Code","text":"<pre><code>def combinationSum2(candidates, target):\n    res = []\n    candidates.sort()\n\n    def backtrack(start, path, total):\n        if total == target:\n            res.append(path[:])\n            return\n        if total &gt; target:\n            return\n        for i in range(start, len(candidates)):\n            if i &gt; start and candidates[i] == candidates[i - 1]:\n                continue\n            if candidates[i] &gt; target:\n                break\n            path.append(candidates[i])\n            backtrack(i + 1, path, total + candidates[i])\n            path.pop()\n\n    backtrack(0, [], 0)\n    return res\n</code></pre>"},{"location":"DSAyy/backtracking/#example_18","title":"Example","text":"<pre><code>combinationSum2([1, 1, 2, 5, 6, 7, 10], 8)\n# Output: [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]\n</code></pre>"},{"location":"DSAyy/backtracking/#time-space-complexity_8","title":"Time &amp; Space Complexity","text":"<ul> <li> <p>Time: Exponential in number of elements \u2014 pruned by early stopping and skipping duplicates</p> </li> <li> <p>Space: \\(O(k)\\) recursion stack; output depends on number of valid combinations</p> </li> </ul>"},{"location":"DSAyy/backtracking/#combination-sum-each-number-can-be-used-unlimited-times","title":"Combination Sum (Each Number Can Be Used Unlimited Times)","text":""},{"location":"DSAyy/backtracking/#problem-statement_12","title":"Problem Statement","text":"<p>Given a list of positive integers \\(A\\) and a target sum \\(B\\), return all unique combinations in which elements from \\(A\\) (with unlimited usage) sum to \\(B\\).</p> <ul> <li>Each combination must be in non-descending order</li> <li>The result must be lexicographically sorted</li> <li>The solution set must not contain duplicate combinations</li> </ul>"},{"location":"DSAyy/backtracking/#example_19","title":"Example","text":"<pre><code>Input: A = [2, 3, 6, 7], B = 7\nOutput:\n[\n [2, 2, 3],\n [7]\n]\n</code></pre>"},{"location":"DSAyy/backtracking/#key-insight_9","title":"Key Insight","text":"<p>This is a classic unbounded knapsack problem.</p> <ul> <li> <p>Sort and deduplicate the input</p> </li> <li> <p>Use backtracking to explore all combinations</p> </li> <li> <p>At each step:</p> <ul> <li> <p>Reuse the same number by passing the same index <code>i</code></p> </li> <li> <p>Stop if the remaining target is zero</p> </li> <li> <p>Break if the current number exceeds the remaining target</p> </li> </ul> </li> </ul>"},{"location":"DSAyy/backtracking/#python-code_12","title":"Python Code","text":"<pre><code>def combinationSum(candidates, target):\n    res = []\n    candidates = sorted(set(candidates))\n\n    def backtrack(start, path, total):\n        if total == target:\n            res.append(path[:])\n            return\n        if total &gt; target:\n            return\n        for i in range(start, len(candidates)):\n            if candidates[i] &gt; target - total:\n                break\n            path.append(candidates[i])\n            backtrack(i, path, total + candidates[i])  # reuse same i\n            path.pop()\n\n    backtrack(0, [], 0)\n    return res\n</code></pre>"},{"location":"DSAyy/backtracking/#example_20","title":"Example","text":"<pre><code>combinationSum([2, 3], 6)\n# Output: [[2, 2, 2], [3, 3]]\n</code></pre>"},{"location":"DSAyy/backtracking/#time-space-complexity_9","title":"Time &amp; Space Complexity","text":"<ul> <li> <p>Time: Exponential in worst-case (many combinations)</p> </li> <li> <p>Space: \\(O(B)\\) recursion stack; output depends on number of solutions</p> </li> </ul>"},{"location":"DSAyy/backtracking/#all-possible-subsets-power-set-via-backtracking","title":"All Possible Subsets (Power Set via Backtracking)","text":""},{"location":"DSAyy/backtracking/#problem-statement_13","title":"Problem Statement","text":"<p>Given a list of distinct integers \\(A\\), return all possible subsets (the power set).</p> <ul> <li>Each subset must be in non-descending order</li> <li>The solution set must be lexicographically sorted</li> </ul>"},{"location":"DSAyy/backtracking/#example_21","title":"Example","text":"<pre><code>Input: A = [1, 2, 3]\nOutput:\n[\n [],\n [1],\n [1, 2],\n [1, 2, 3],\n [1, 3],\n [2],\n [2, 3],\n [3]\n]\n</code></pre>"},{"location":"DSAyy/backtracking/#key-insight_10","title":"Key Insight","text":"<p>This is a classic power set problem.</p> <p>Use backtracking to generate all subsets:</p> <ul> <li> <p>At each step, we can either include the current number or skip it</p> </li> <li> <p>By iterating from left to right, and always moving forward, subsets are guaranteed to be sorted</p> </li> <li> <p>Sorting the array first ensures lexicographic output</p> </li> </ul>"},{"location":"DSAyy/backtracking/#python-code_13","title":"Python Code","text":"<pre><code>def subsets(nums):\n    res = []\n    nums.sort()\n\n    def backtrack(start, path):\n        res.append(path[:])\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()\n\n    backtrack(0, [])\n    return res\n</code></pre>"},{"location":"DSAyy/backtracking/#example_22","title":"Example","text":"<pre><code>subsets([1, 2])\n# Output: [[], [1], [1, 2], [2]]\n</code></pre>"},{"location":"DSAyy/backtracking/#time-space-complexity_10","title":"Time &amp; Space Complexity","text":"<ul> <li> <p>Time: \\(O(2^n \\cdot n)\\) \u2014 \\(2^n\\) subsets, each up to \\(n\\) in length</p> </li> <li> <p>Space: \\(O(n)\\) recursion stack; output takes \\(O(2^n \\cdot n)\\)</p> </li> </ul>"},{"location":"DSAyy/backtracking/#word-break-dictionary-segmentation-using-backtracking","title":"Word Break (Dictionary Segmentation Using Backtracking)","text":""},{"location":"DSAyy/backtracking/#problem-statement_14","title":"Problem Statement","text":"<p>Given a string \\(s\\) and a set of words <code>wordDict</code>, return all possible sentences where spaces are inserted to form a valid sequence of dictionary words.</p> <p>Each word in the sentence must appear in the given dictionary.</p>"},{"location":"DSAyy/backtracking/#example_23","title":"Example","text":"<pre><code>Input: \ns = \"catsanddog\", \nwordDict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"]\n\nOutput:\n[\n \"cat sand dog\",\n \"cats and dog\"\n]\n</code></pre>"},{"location":"DSAyy/backtracking/#key-insight_11","title":"Key Insight","text":"<p>This is a backtracking problem with memoization to avoid recomputing subproblems.</p> <ul> <li> <p>Try all prefixes of the string</p> </li> <li> <p>If a prefix is in the dictionary, recursively process the suffix</p> </li> <li> <p>Use a memoization dictionary <code>dp[start]</code> to store valid sentence endings for substring <code>s[start:]</code></p> </li> </ul>"},{"location":"DSAyy/backtracking/#python-code_14","title":"Python Code","text":"<pre><code>def wordBreak(s, wordDict):\n    wordSet = set(wordDict)\n    dp = {}\n\n    def backtrack(start):\n        if start in dp:\n            return dp[start]\n        if start == len(s):\n            return [\"\"]\n\n        sentences = []\n        for end in range(start + 1, len(s) + 1):\n            word = s[start:end]\n            if word in wordSet:\n                rest = backtrack(end)\n                for r in rest:\n                    sentence = word + (\" \" + r if r else \"\")\n                    sentences.append(sentence)\n\n        dp[start] = sentences\n        return sentences\n\n    return backtrack(0)\n</code></pre>"},{"location":"DSAyy/backtracking/#example_24","title":"Example","text":"<pre><code>wordBreak(\"pineapplepenapple\", [\n \"apple\", \"pen\", \"applepen\", \"pine\", \"pineapple\"\n])\n# Output:\n# [\"pine apple pen apple\", \"pineapple pen apple\", \"pine applepen apple\"]\n</code></pre>"},{"location":"DSAyy/backtracking/#time-space-complexity_11","title":"Time &amp; Space Complexity","text":"<ul> <li> <p>Time: Exponential in worst-case, but pruned by memoization</p> </li> <li> <p>Space: \\(O(n^2)\\) for memo and recursive call stack</p> </li> </ul>"},{"location":"DSAyy/backtracking/#restore-ip-addresses","title":"Restore IP Addresses","text":""},{"location":"DSAyy/backtracking/#problem-statement_15","title":"Problem Statement","text":"<p>Given a string \\(s\\) containing only digits, return all possible valid IP address combinations that can be formed by inserting dots into \\(s\\).</p> <p>A valid IP address consists of exactly four integers (each between 0 and 255), separated by dots. - No segment can have leading zeros (e.g. \"01\" is invalid, \"0\" is valid).</p>"},{"location":"DSAyy/backtracking/#example_25","title":"Example","text":"<pre><code>Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\", \"255.255.111.35\"]\n</code></pre>"},{"location":"DSAyy/backtracking/#key-insight_12","title":"Key Insight","text":"<p>Use backtracking to explore all possible ways to insert 3 dots (dividing string into 4 parts):</p> <p>At each recursive step:</p> <ul> <li> <p>Try placing a dot after 1 to 3 digits</p> </li> <li> <p>Check if the segment is valid (\u2264 255, no leading zeros)</p> </li> <li> <p>If valid, recurse with the next segment</p> </li> </ul> <p>Stop early if more than 4 segments or the string is exhausted.</p>"},{"location":"DSAyy/backtracking/#python-code_15","title":"Python Code","text":"<pre><code>def restoreIpAddresses(s):\n    res = []\n\n    def backtrack(start, path):\n        if len(path) == 4:\n            if start == len(s):\n                res.append('.'.join(path))\n            return\n        for end in range(start + 1, min(len(s), start + 4)):\n            part = s[start:end]\n            if (part.startswith('0') and len(part) &gt; 1) or int(part) &gt; 255:\n                continue\n            backtrack(end, path + [part])\n\n    backtrack(0, [])\n    return res\n</code></pre>"},{"location":"DSAyy/backtracking/#example_26","title":"Example","text":"<pre><code>restoreIpAddresses(\"0000\")\n# Output: [\"0.0.0.0\"]\n</code></pre>"},{"location":"DSAyy/backtracking/#time-space-complexity_12","title":"Time &amp; Space Complexity","text":"<ul> <li> <p>Time: \\(O(1)\\) \u2014 worst-case bounded since only 3 dots \u2192 \\(O(3^4)\\)</p> </li> <li> <p>Space: \\(O(1)\\) recursion depth, result space depends on number of valid IPs</p> </li> </ul>"},{"location":"DSAyy/backtracking/#rat-in-a-maze-find-all-paths","title":"Rat in a Maze (Find All Paths)","text":""},{"location":"DSAyy/backtracking/#problem-statement_16","title":"Problem Statement","text":"<p>Given an \\(n \\times n\\) maze represented by a binary matrix, find all paths from the top-left cell \\((0, 0)\\) to the bottom-right cell \\((n-1, n-1)\\).</p> <ul> <li>A cell with <code>1</code> is traversable, <code>0</code> is blocked.</li> <li>Valid moves are down (<code>D</code>), left (<code>L</code>), right (<code>R</code>), and up (<code>U</code>).</li> <li>The rat cannot visit the same cell more than once in the same path.</li> <li>Return all paths in lexicographic order.</li> </ul>"},{"location":"DSAyy/backtracking/#example_27","title":"Example","text":"<pre><code>Input:\nmaze = [\n [1, 0, 0, 0],\n [1, 1, 0, 1],\n [1, 1, 0, 0],\n [0, 1, 1, 1]\n]\n\nOutput: [\"DDRDRR\", \"DRDDRR\"]\n</code></pre>"},{"location":"DSAyy/backtracking/#key-insight_13","title":"Key Insight","text":"<p>This is a classic backtracking problem with visited tracking.</p> <ul> <li> <p>Try all four directions in fixed lexicographic order</p> </li> <li> <p>Only move to valid, unvisited, open cells</p> </li> <li> <p>Mark cells as visited during recursion and unmark (backtrack) afterward</p> </li> </ul>"},{"location":"DSAyy/backtracking/#python-code_16","title":"Python Code","text":"<pre><code>def findPaths(maze, n):\n    res = []\n    visited = [[False]*n for _ in range(n)]\n    directions = [('D', 1, 0), ('L', 0, -1), ('R', 0, 1), ('U', -1, 0)]\n\n    def is_valid(r, c):\n        return 0 &lt;= r &lt; n and 0 &lt;= c &lt; n and maze[r][c] == 1 and not visited[r][c]\n\n    def backtrack(r, c, path):\n        if r == n - 1 and c == n - 1:\n            res.append(path)\n            return\n        visited[r][c] = True\n        for dir_char, dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if is_valid(nr, nc):\n                backtrack(nr, nc, path + dir_char)\n        visited[r][c] = False\n\n    if maze[0][0] == 1:\n        backtrack(0, 0, \"\")\n    return res\n</code></pre>"},{"location":"DSAyy/backtracking/#example_28","title":"Example","text":"<pre><code>findPaths([\n [1, 0, 0, 0],\n [1, 1, 0, 1],\n [1, 1, 0, 0],\n [0, 1, 1, 1]\n], 4)\n# Output: [\"DDRDRR\", \"DRDDRR\"]\n</code></pre>"},{"location":"DSAyy/backtracking/#time-space-complexity_13","title":"Time &amp; Space Complexity","text":"<ul> <li> <p>Time: \\(O(4^{n^2})\\) worst case (exponential paths), pruned by visited matrix</p> </li> <li> <p>Space: \\(O(n^2)\\) for recursion stack and visited matrix</p> </li> </ul>"},{"location":"DSAyy/backtracking/#word-search-existence-of-a-word-in-a-grid","title":"Word Search (Existence of a Word in a Grid)","text":""},{"location":"DSAyy/backtracking/#problem-statement_17","title":"Problem Statement","text":"<p>Given a 2D board of characters and a word, return true if the word exists in the board.</p> <ul> <li>The word can be constructed from letters of sequentially adjacent cells.</li> <li>Adjacent cells are horizontally or vertically neighboring.</li> <li>The same letter cell may not be used more than once.</li> </ul>"},{"location":"DSAyy/backtracking/#example_29","title":"Example","text":"<pre><code>Input:\nboard = [\n ['A','B','C','E'],\n ['S','F','C','S'],\n ['A','D','E','E']\n], word = \"ABCCED\"\n\nOutput: True\n</code></pre>"},{"location":"DSAyy/backtracking/#key-insight_14","title":"Key Insight","text":"<p>Use backtracking DFS to explore all valid paths from each cell.</p> <ul> <li> <p>Start DFS from every cell that matches the first letter</p> </li> <li> <p>At each step, check adjacent unvisited cells for the next character</p> </li> <li> <p>Temporarily mark the visited cells to avoid revisiting</p> </li> <li> <p>Restore the cell (backtrack) after recursion</p> </li> </ul>"},{"location":"DSAyy/backtracking/#python-code_17","title":"Python Code","text":"<pre><code>def exist(board, word):\n    rows, cols = len(board), len(board[0])\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n        if r &lt; 0 or r &gt;= rows or c &lt; 0 or c &gt;= cols or board[r][c] != word[i]:\n            return False\n\n        temp = board[r][c]\n        board[r][c] = \"#\"\n\n        found = (\n            dfs(r + 1, c, i + 1) or\n            dfs(r - 1, c, i + 1) or\n            dfs(r, c + 1, i + 1) or\n            dfs(r, c - 1, i + 1)\n        )\n\n        board[r][c] = temp\n        return found\n\n    for r in range(rows):\n        for c in range(cols):\n            if board[r][c] == word[0] and dfs(r, c, 0):\n                return True\n\n    return False\n</code></pre>"},{"location":"DSAyy/backtracking/#example_30","title":"Example","text":"<pre><code>exist([\n ['A','B','C','E'],\n ['S','F','C','S'],\n ['A','D','E','E']\n], \"SEE\")\n# Output: True\n</code></pre>"},{"location":"DSAyy/backtracking/#time-space-complexity_14","title":"Time &amp; Space Complexity","text":"<ul> <li> <p>Time: \\(O(m \\cdot n \\cdot 4^L)\\) where \\(L\\) is the length of the word</p> </li> <li> <p>Space: \\(O(L)\\) recursion depth; \\(O(1)\\) extra space (in-place visited marking)</p> </li> </ul> <p>Here is the first problem from the Backtracking PDF formatted in clean markdown:</p>"},{"location":"DSAyy/backtracking/#problem-reverse-linked-list-recursion","title":"Problem: Reverse Linked List (Recursion)","text":""},{"location":"DSAyy/backtracking/#problem-statement_18","title":"Problem Statement","text":"<p>Reverse a singly linked list using recursion.</p> <p>Given the head of a singly linked list, reverse the list and return the new head.</p>"},{"location":"DSAyy/backtracking/#constraints_1","title":"Constraints","text":"<ul> <li>Number of nodes: \\(1 \\leq N \\leq 10^5\\)</li> </ul>"},{"location":"DSAyy/backtracking/#recursive-insight","title":"Recursive Insight","text":"<p>The idea is to recursively reverse the rest of the list, and then put the current node at the end.</p>"},{"location":"DSAyy/backtracking/#recursive-relation","title":"Recursive Relation","text":"<p>If <code>head</code> is the current node:</p> <ul> <li>Reverse rest of the list: <code>rev = reverse(head.next)</code></li> <li>Then, <code>head.next.next = head</code> and <code>head.next = None</code></li> </ul>"},{"location":"DSAyy/backtracking/#python-code_18","title":"Python Code","text":"<pre><code>class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverseList(head: ListNode) -&gt; ListNode:\n    if not head or not head.next:\n        return head\n    new_head = reverseList(head.next)\n    head.next.next = head\n    head.next = None\n    return new_head\n</code></pre>"},{"location":"DSAyy/backtracking/#example_31","title":"Example","text":"<p>Given:</p> <pre><code>1 \u2192 2 \u2192 3 \u2192 4 \u2192 5 \u2192 None\n</code></pre> <p>After reversing:</p> <pre><code>5 \u2192 4 \u2192 3 \u2192 2 \u2192 1 \u2192 None\n</code></pre>"},{"location":"DSAyy/backtracking/#time-complexity","title":"Time Complexity","text":"<ul> <li>\\(O(N)\\) where \\(N\\) is the number of nodes.</li> </ul>"},{"location":"DSAyy/backtracking/#space-complexity","title":"Space Complexity","text":"<ul> <li>\\(O(N)\\) recursive call stack.</li> </ul>"},{"location":"DSAyy/backtracking/#problem-modular-expression-compute-ab-mod-c","title":"Problem: Modular Expression \u2014 Compute \\(A^B \\mod C\\)","text":""},{"location":"DSAyy/backtracking/#problem-statement_19","title":"Problem Statement","text":"<p>Given three integers \\(A\\), \\(B\\), and \\(C\\), compute:</p> \\[ (A^B) \\mod C \\] <p>Efficiently compute this even for very large \\(B\\) (up to \\(10^9\\)).</p>"},{"location":"DSAyy/backtracking/#constraints_2","title":"Constraints","text":"<ul> <li>\\(-10^9 \\leq A \\leq 10^9\\)</li> <li>\\(0 \\leq B \\leq 10^9\\)</li> <li>\\(1 \\leq C \\leq 10^9\\)</li> </ul> <p>If the result is negative, return a non-negative number in range \\([0, C-1]\\).</p>"},{"location":"DSAyy/backtracking/#mathematical-insight-binary-exponentiation","title":"Mathematical Insight: Binary Exponentiation","text":"<p>We use binary exponentiation (also known as exponentiation by squaring), which reduces the time complexity from \\(O(B)\\) to \\(O(\\log B)\\).</p>"},{"location":"DSAyy/backtracking/#binary-exponentiation-logic","title":"Binary Exponentiation Logic","text":"<p>To compute \\(x^n\\):</p> \\[ x^n =  \\begin{cases} (x^{n/2})^2 &amp; \\text{if } n \\text{ is even} \\\\ x \\cdot (x^{(n-1)/2})^2 &amp; \\text{if } n \\text{ is odd} \\end{cases} \\] <p>At each step, take result modulo \\(C\\) to avoid overflow.</p>"},{"location":"DSAyy/backtracking/#python-code_19","title":"Python Code","text":"<pre><code>def mod_pow(x: int, n: int, d: int) -&gt; int:\n    base = x % d\n    if base &lt; 0:\n        base += d\n\n    result = 1\n    while n &gt; 0:\n        if n % 2 == 1:\n            result = (result * base) % d\n        base = (base * base) % d\n        n //= 2\n\n    return result % d\n</code></pre>"},{"location":"DSAyy/backtracking/#problem-letter-phone-digit-to-letter-combinations","title":"Problem: Letter Phone (Digit-to-Letter Combinations)","text":""},{"location":"DSAyy/backtracking/#problem-statement_20","title":"Problem Statement","text":"<p>Given a string of digits (from <code>0\u20139</code>), return all possible letter combinations that the number could represent using a telephone keypad.</p>"},{"location":"DSAyy/backtracking/#digit-to-letter-mapping_1","title":"Digit to Letter Mapping:","text":"<pre><code>0 \u2192 0 1 \u2192 1  \n2 \u2192 abc 3 \u2192 def  \n4 \u2192 ghi 5 \u2192 jkl  \n6 \u2192 mno 7 \u2192 pqrs  \n8 \u2192 tuv 9 \u2192 wxyz\n</code></pre>"},{"location":"DSAyy/backtracking/#example_32","title":"Example","text":""},{"location":"DSAyy/backtracking/#input","title":"Input:","text":"<pre><code>A = \"23\"\n</code></pre>"},{"location":"DSAyy/backtracking/#output","title":"Output:","text":"<pre><code>[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]\n</code></pre>"},{"location":"DSAyy/backtracking/#approach","title":"Approach","text":"<p>This is a Cartesian product problem using backtracking.</p> <ul> <li> <p>At each index, try all characters mapped from the current digit.</p> </li> <li> <p>Recurse to the next index.</p> </li> <li> <p>Append the full path to the result when complete.</p> </li> </ul>"},{"location":"DSAyy/backtracking/#python-code_20","title":"Python Code","text":"<pre><code>def letterCombinations(A):\n    if not A:\n        return []\n\n    digit_map = [\n        \"0\", \"1\", \"abc\", \"def\", \"ghi\",\n        \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"\n    ]\n\n    result = []\n\n    def backtrack(index, path):\n        if index == len(A):\n            result.append(''.join(path))\n            return\n        for char in digit_map[int(A[index])]:\n            path.append(char)\n            backtrack(index + 1, path)\n            path.pop()\n\n    backtrack(0, [])\n    return result\n</code></pre>"},{"location":"DSAyy/backtracking/#example-usage","title":"Example Usage","text":"<pre><code>letterCombinations(\"23\")\n# Output: ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']\n</code></pre>"},{"location":"DSAyy/backtracking/#time-complexity_1","title":"Time Complexity","text":"<ul> <li>\\(O(4^n)\\) \u2014 where \\(n\\) is the length of the digit string (since max 4 letters per digit)</li> </ul>"},{"location":"DSAyy/backtracking/#space-complexity_1","title":"Space Complexity","text":"<ul> <li>\\(O(n)\\) \u2014 recursion stack and temporary path</li> </ul>"},{"location":"DSAyy/binary_search/","title":"Binary Search","text":"<p>Given a sorted array, that has been rotated at some unknown pivot, find the minimum element in A.</p> <p>Ex: 7 2 4 5, output = 2</p> <pre><code>def findMin(A):\n    n = len(A)\n    l,r = 0, n - 1\n    while l &lt; r:\n        m = l + (r-l)//2\n        if A[m] &gt; A[r]: #minimum is on the right.\n            l = m + 1\n        else:\n            r = m\n    return A[l]\n</code></pre>"},{"location":"DSAyy/binary_search/#search-in-bitonic-array","title":"Search in Bitonic Array","text":"<p>Given a bitonic sequence (first increasing, then decreasing) of N distinct elements. Find the index of element B in A in O(logN) time.</p> <p>If it does not exist, return -1.</p> <p>Ex: A = 3 9 10 20 17 5 1, B = 20. Output: 3</p>"},{"location":"DSAyy/binary_search/#how","title":"How","text":"<p>First find the peak, then do two binary searches each side.</p> <pre><code>def searchBito(A):\n    N = len(A)\n    lo = 0; hi = N-1\n    while lo &lt; hi:\n        mid = (lo + hi) // 2\n        if A[mid] &gt; A[mid+1]:\n            hi = mid\n        else:\n            lo = mid + 1\n    peak = lo\n    #bs in increasing part\n    lo , hi = 0, peak\n    while lo &lt;= hi:\n        mid = (lo + hi)//2\n        if A[mid] == B:\n            return mid\n        if A[mid] &lt; B:\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    #bs in decreasing part\n    lo,hi = peak + 1, N-1\n    while lo &lt;= hi:\n        mid = (lo + hi)//2\n        if A[mid] == B:\n            return mid\n        if A[mid] &lt; B:\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return -1\n</code></pre>"},{"location":"DSAyy/binary_search/#smaller-or-equal-elements","title":"Smaller or equal elements.","text":"<p>Given a sorted array A, and int B, count the number of elements in A that are \\(\\leq\\) B.</p> <pre><code>def leq(A,B):\n    N = len(A)\n    lo,hi = 0, N-1\n    ans = N\n    while lo &lt;= hi:\n        mid = (lo + hi)//2\n        if A[mid] &gt; B:\n            ans = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return ans\n</code></pre>"},{"location":"DSAyy/binary_search/#wood-cutting-made-easy","title":"Wood Cutting Made easy","text":"<p>Given an array of tree heights, and the amount of wood B to be collected. Find the maximum height H such that if you cut all trees taller than H down to height H, you collect at least B metres of wood.</p> <pre><code>def wood(A,B):\n    lo,hi = 0, max(A)\n    best = 0\n    while lo &lt;= hi:\n        mid = (lo + hi)//2\n        wood = sum(max(0, ai - mid) for ai in A)\n        if wood &gt;= B:\n            best = mid\n            low = mid + 1 #try higher cut\n        else:\n            high = mid - 1 #try lower cut\n    return best\n</code></pre>"},{"location":"DSAyy/binary_search/#matrix-search","title":"Matrix Search","text":"<p>Given a \\(N \\times M\\) matrix where each row is sorted and first element of each row is \\(\\geq\\) last element of previous row.</p> <p>Given an integer B, determine if B exists in the matrix.</p> <p>Ex:</p> 1 3 5 7 10 11 16 20 23 30 34 50 <p>Flattening it, its just a sorted list.</p> <p>an index k would correspond to \\(A[row][col]\\) where row = \\(\\lfloor \\frac{k}{M} \\rfloor\\) and col = \\(k\\space mod\\space M\\)</p> <pre><code>def searchMatrix(A,B):\n    n,m = len(A), len(A[0])\n    low, high = 0, n*m - 1\n    while low &lt;= high:\n        mid = (low + high)//2\n        row = mid//m\n        col = mid % m\n        val = A[row][col]\n        if val == B:\n            return 1\n        elif val &lt; B:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return 0\n</code></pre>"},{"location":"DSAyy/binary_search/#search-for-a-range","title":"Search for a Range.","text":"<p>Given a sorted array, and int B. Find the starting point and ending point of B in A.</p> <p>Bhai bas upperbound - lowerbound hai.</p> <pre><code>def searchRange(A,B):\n    n = len(A)\n    res = [-1,-1]\n    lo,hi = 0, n-1\n    while lo &lt;= hi: #search for first occurence\n        mid = (lo + hi) //2\n        if A[mid] &lt; B:\n            lo = mid + 1\n        elif A[mid] &gt; B:\n            hi = mid - 1\n        else:\n            res[0] = mid\n            hi = mid - 1 #keep search better on left\n    if res[0] == -1: return res\n    #find last occ\n    lo, hi= 0, n-1\n    while lo &lt;= hi:\n        mid = (lo + hi)//2\n        if A[mid] &lt; B:\n            lo = mid + 1\n        elif A[mid] &gt; B:\n            hi = mid - 1\n        else:\n            res[1] = mid\n            lo= mid + 1 #keep searching right\n    return res\n</code></pre>"},{"location":"DSAyy/binary_search/#sorted-insertion-position","title":"Sorted Insertion Position","text":"<p>Given a sorted array, tell the index where B is found. If not found, where should it be inserted.</p> <pre><code>def searchInsert(A,B):\n    n = len(A)\n    lo,hi = 0, n\n    while lo &lt; hi:\n        mid = (lo + hi) // 2\n        if A[mid] &lt; B:\n            lo = mid + 1\n        else:\n            hi = mid\n    return lo\n</code></pre>"},{"location":"DSAyy/binary_search/#capacity-to-ship-packages-within-b-days","title":"Capacity to Ship packages within B days.","text":"<p>Conveyor belt has packages that must be shipped within another B days.</p> <p>The \\(i^{th}\\) package on the conveyor belt has weight \\(A[i]\\). Each day, we load the packages (not more than the maximum weight capacity).</p> <p>Return the least weight capacity of the belt such that all the packages can be shipped within B days.</p> <p>\\(A = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], B = 5\\) Output = 15</p> <pre><code>def maxCap(A,B):\n    lo,hi = max(A), sum(A)\n    answer = hi\n    def canBeShipped(C):\n        days = 1\n        currentLoad = 0\n        for weight in A:\n            if currentLoad + weight &lt;= C:\n                currentLoad += weight\n            else:\n                days += 1\n                currentLoad = weight\n        return days &lt;= B\n    #bs on the capacity\n    while lo &lt;= hi:\n        cap = (lo + hi)//2\n        if canBeShipped(cap):\n            answer = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return answer\n</code></pre>"},{"location":"DSAyy/binary_search/#matrix-median","title":"Matrix Median","text":"<p>Given a matrix \\(N \\times M\\), where each row is sorted in non-decreasing order. Find and return the overall median of the matrix.</p> <p>Use bs on value range, not indices.</p> <p>Median is just the kth smallest element where \\(k = \\frac{N\\times M-1}{2}\\)</p> <p>For a guessed value of mid, count how many elements \\(\\leq\\) mid using upper_bound in each row, since each row is sorted.</p> <pre><code>import bisect\ndef findMedian(matrix):\n    n = len(matrix)\n    m = len(matrix[0])\n    lo = min(row[0] for row in matrix)\n    hi = max(row[-1] for row in matrix)\n    desired = (n*m+1) // 2\n    def notDesiredCount(x):\n        count = 0\n        for row in matrix:\n            #count elements &lt;= mid using upperbound\n            count += bisect.bisect_right(row,mid)\n        return count &lt; desired\n    while lo &lt; hi:\n        mid = (lo + hi)//2\n        if notDesiredCount(mid):\n            lo = mid + 1\n        else:\n            hi = mid\n    return lo\n</code></pre>"},{"location":"DSAyy/binary_search/#square-root-of-integer","title":"Square root of Integer","text":"<p>Given a non-neg A, compute and return \\(\\sqrt A\\) . <pre><code>def sqrt(A):\n    if A &lt; 2:\n        return A\n    lo,hi = 1, A//2\n    ans = 1\n    while lo &lt;= hi:\n        mid = (lo + hi)//2\n        if mid*mid == A:\n            return mid\n        if mid*mid &lt; A:\n            ans = mid\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    return ans\n</code></pre></p>"},{"location":"DSAyy/binary_search/#allocate-books","title":"Allocate Books","text":"<p>Given N books with pages count, and B students. Allocate books to students such that, books for a student are consecutive. </p> <p>Minimize the maximum pages assigned to a student.</p> <p>A = 12 34 67 90, B = 2. Ans = 113 limit per student.</p> <pre><code>def allocateBooks(A,B):\n    def studentsFit(pageLimit):\n        students = 1\n        pages = 0\n        for p in A:\n            if pages + p &gt; pageLimit:\n                students += 1\n                pages = p\n            else:\n                pages += p\n        return students &lt;= B\n    if B &gt; len(A): return -1\n    lo = max(A)\n    hi = sum(A)\n    ans = hi\n    while lo &lt;= hi:\n        limit = (lo + hi)//2\n        if studentsFit(limit):\n            ans = limit\n            hi = limit - 1\n        else:\n            lo = limit + 1\n    return ans\n</code></pre>"},{"location":"DSAyy/binary_search/#painters-partition","title":"Painter's Partition","text":"<p>Given A painters, each taking B units of time per length, and and array of board lengths.</p> <p>Paint all boards while minimizing the maximum time any painter spends painting.</p> <p>A = 2, B = 5, C = 1,10 : Answer = 50. (each painter gets one board)</p> <pre><code>def minTime(A,B,C):\n    MOD = 100000003\n    if A &gt;= len(C): #each painter paints one board\n        return (max(c)*B) % MOD #max length a painter paints.\n    def paintersDontExceed(maxLen):\n        #if every painter paints at max this length, all boards are painted with the given painters.\n        painters = 1\n        currSum = 0\n        for boardLength in C:\n            if currSum + boardLength &gt; maxLen:\n                painters += 1\n                currSum = boardLength\n            else:\n                currSum += boardLength\n        return painters &lt;= A\n    lo,hi = max(C), sum(C)\n    best = hi\n    while lo &lt;= hi:\n        length = (lo + hi) // 2\n        if paintersDontExceed(length):\n            best = length\n            hi = length-1\n        else:\n            lo = length + 1\n    return (best*B) % MOD\n</code></pre>"},{"location":"DSAyy/binary_search/#red-zone-detection-problem","title":"Red Zone Detection Problem","text":""},{"location":"DSAyy/binary_search/#problem-statement","title":"Problem Statement","text":"<p>You're given N orange zones on an infinite 2D plane. Each zone is located at coordinate <code>A[i] = (x_i, y_i)</code>. Every day, each orange zone spreads influence in a circular region with increasing radius \\(d\\) (Euclidean distance).  </p> <p>A location becomes a red zone if it lies within distance \\(d\\) of at least B orange zones.</p> <p>Objective: Find the minimum integer value of \\(d\\) such that there exists at least one point covered by at least \\(B\\) orange zones.</p>"},{"location":"DSAyy/binary_search/#constraints","title":"Constraints:","text":"<ul> <li>\\(2 \\leq B \\leq N \\leq 100\\)</li> <li>\\(0 \\leq x_i, y_i \\leq 10^9\\)</li> </ul>"},{"location":"DSAyy/binary_search/#mathematical-explanation","title":"Mathematical Explanation","text":"<p>Given a fixed distance \\(r\\):</p> <ol> <li>For each pair of centers \\((P, Q)\\), if distance \\(d \\leq 2r\\), their circles intersect.</li> <li>Calculate the intersection points (at most two) between the two circles.</li> <li>Let \\(d = |P - Q|\\)</li> <li>Midpoint: $$ M = \\frac{P + Q}{2} $$</li> <li>Height to intersection point:      $$ h = \\sqrt{r^2 - \\left(\\frac{d}{2}\\right)^2} $$</li> <li>Direction vector from \\(P\\) to \\(Q\\):      $$ \\vec{u} = \\frac{Q - P}{|Q - P|} $$</li> <li>Perpendicular unit vector \\(\\vec{u}^\\perp\\) is perpendicular to \\(\\vec{u}\\)</li> <li> <p>Intersection points:      $$ M \\pm h \\cdot \\vec{u}^\\perp $$</p> </li> <li> <p>Also check each circle center, as a red zone might occur at the center.</p> </li> <li>Count how many circles each candidate point lies within.</li> </ol>"},{"location":"DSAyy/binary_search/#python-code","title":"Python Code","text":"<pre><code>import math\nfrom typing import List, Tuple\nfrom itertools import combinations\n\ndef distance(p1: Tuple[float, float], p2: Tuple[float, float]) -&gt; float:\n    return math.hypot(p1[0] - p2[0], p1[1] - p2[1])\n\ndef circle_intersections(p1, p2, r) -&gt; List[Tuple[float, float]]:\n    d = distance(p1, p2)\n    if d &gt; 2 * r or d == 0:\n        return []\n\n    mx = (p1[0] + p2[0]) / 2\n    my = (p1[1] + p2[1]) / 2\n    dx = (p2[0] - p1[0]) / d\n    dy = (p2[1] - p1[1]) / d\n    h = math.sqrt(r * r - (d / 2) ** 2)\n\n    px = mx + h * dy\n    py = my - h * dx\n    qx = mx - h * dy\n    qy = my + h * dx\n\n    return [(px, py), (qx, qy)]\n\ndef count_covering(point, centers, r) -&gt; int:\n    return sum(distance(point, c) &lt;= r + 1e-7 for c in centers)\n\ndef check(centers: List[Tuple[float, float]], B: int, r: float) -&gt; bool:\n    candidates = list(centers)\n    for (p1, p2) in combinations(centers, 2):\n        candidates.extend(circle_intersections(p1, p2, r))\n\n    return any(count_covering(pt, centers, r) &gt;= B for pt in candidates)\n\ndef min_radius(A: List[List[int]], B: int) -&gt; int:\n    centers = [(float(x), float(y)) for x, y in A]\n    lo, hi = 0, 2_000_000_000\n    answer = hi\n    while lo &lt;= hi:\n        mid = (lo + hi) // 2\n        if check(centers, B, mid):\n            answer = mid\n            hi = mid - 1\n        else:\n            lo = mid + 1\n    return answer\n</code></pre>"},{"location":"DSAyy/binary_search/#modular-power-function-compute-xn-mod-d","title":"Modular Power Function: Compute \\((x^n) \\mod d\\)","text":""},{"location":"DSAyy/binary_search/#problem-statement_1","title":"Problem Statement","text":"<p>Given integers \\(x\\), \\(n\\), and \\(d\\), compute:</p> \\[ (x^n) \\mod d \\]"},{"location":"DSAyy/binary_search/#constraints_1","title":"Constraints:","text":"<ul> <li>\\(-10^9 \\leq x \\leq 10^9\\)</li> <li>\\(0 \\leq n \\leq 10^9\\)</li> <li>\\(1 \\leq d \\leq 10^9\\)</li> </ul> <p>If the result is negative, convert it to a non-negative number in the range \\([0, d-1]\\).</p>"},{"location":"DSAyy/binary_search/#mathematical-insight-binary-exponentiation","title":"Mathematical Insight: Binary Exponentiation","text":"<p>Naive computation of \\(x^n\\) is inefficient for large \\(n\\). Instead, use Exponentiation by Squaring to reduce time complexity from \\(O(n)\\) to \\(O(\\log n)\\).</p>"},{"location":"DSAyy/binary_search/#recurrence","title":"Recurrence:","text":"\\[ x^n = \\begin{cases} (x^{n/2})^2 &amp; \\text{if } n \\text{ is even} \\\\ x \\cdot (x^{(n-1)/2})^2 &amp; \\text{if } n \\text{ is odd} \\end{cases} \\]"},{"location":"DSAyy/binary_search/#key-points","title":"Key Points:","text":"<ul> <li>Always take modulo \\(d\\) at each step to prevent overflow.</li> <li>Convert \\(x\\) to a non-negative base in \\([0, d-1]\\) before starting.</li> <li>Result is always normalized to \\([0, d-1]\\).</li> </ul>"},{"location":"DSAyy/binary_search/#python-code_1","title":"Python Code","text":"<pre><code>def power_mod(x: int, n: int, d: int) -&gt; int:\n    base = x % d\n    if base &lt; 0:\n        base += d\n\n    result = 1\n    while n &gt; 0:\n        if n &amp; 1:\n            result = (result * base) % d\n        base = (base * base) % d\n        n &gt;&gt;= 1\n\n    return result % d\n</code></pre>"},{"location":"DSAyy/binary_search/#simple-queries","title":"Simple Queries","text":""},{"location":"DSAyy/binary_search/#problem-statement_2","title":"Problem Statement","text":"<p>Given an array \\(A\\) of \\(N\\) integers, perform the following operations:</p> <ol> <li>Generate all subarrays of \\(A\\).</li> <li>For each subarray, take its maximum element and collect them into array \\(G\\).</li> <li>Replace each element \\(x\\) in \\(G\\) with \\(f(x)\\), the product of all divisors of \\(x\\), modulo \\(10^9 + 7\\).</li> <li>Sort \\(G\\) in descending order.</li> </ol> <p>For \\(Q\\) queries, each giving a value \\(k\\), return the \\(k^{\\text{th}}\\) element of \\(G\\).</p>"},{"location":"DSAyy/binary_search/#constraints_2","title":"Constraints:","text":"<ul> <li>\\(1 \\leq N, Q \\leq 10^5\\)</li> <li>\\(1 \\leq A[i], k \\leq 10^5\\)</li> </ul>"},{"location":"DSAyy/binary_search/#step-1-count-occurrences-of-each-maximum","title":"Step 1: Count Occurrences of Each Maximum","text":"<p>For each index \\(i\\) in array \\(A\\): - Let \\(L\\) = number of consecutive elements to the left that are strictly less than \\(A[i]\\) (including \\(i\\)). - Let \\(R\\) = number of elements to the right (including \\(i\\)) that are less than or equal to \\(A[i]\\). - Then the number of subarrays where \\(A[i]\\) is the maximum = \\(L \\times R\\)</p> <p>Efficiently compute: - <code>prev[i]</code>: index of previous greater element to the left - <code>next[i]</code>: index of next greater or equal element to the right Using monotonic stacks</p>"},{"location":"DSAyy/binary_search/#step-2-product-of-divisors-fx","title":"Step 2: Product of Divisors \\(f(x)\\)","text":"<p>If the prime factorization of \\(x\\) is:</p> \\[ x = \\prod p_i^{a_i} \\] <p>Then: - Number of divisors \\(D = \\prod (a_i + 1)\\) - Product of divisors:   $$ f(x) = \\prod p_i^{(D \\cdot a_i)/2} $$</p> <p>To compute \\(f(x)\\): - Use smallest prime factor (SPF) for fast factorization - Use modular exponentiation for large powers</p>"},{"location":"DSAyy/binary_search/#step-3-build-list-g-and-answer-queries","title":"Step 3: Build List \\(G\\) and Answer Queries","text":"<ol> <li>For each unique \\(x\\) in \\(A\\), calculate how many subarrays it is max in \u2192 <code>count[x]</code></li> <li>Compute \\(f(x)\\) for each \\(x\\)</li> <li>Each \\(f(x)\\) appears <code>count[x]</code> times in \\(G\\)</li> <li>Sort \\((f(x), count[x])\\) by descending \\(f(x)\\)</li> <li>Build prefix sums of counts</li> <li>For each query \\(k\\), use binary search over the prefix sums to get answer</li> </ol>"},{"location":"DSAyy/binary_search/#python-code_2","title":"Python Code","text":"<pre><code>from typing import List\nfrom collections import defaultdict\nimport bisect\n\nMOD = 10**9 + 7\nMAX_A = 100005\n\nspf = list(range(MAX_A))\n\ndef build_spf():\n    for i in range(2, MAX_A):\n        if spf[i] == i:\n            for j in range(i*i, MAX_A, i):\n                if spf[j] == j:\n                    spf[j] = i\n\ndef factorize(x):\n    factors = defaultdict(int)\n    while x &gt; 1:\n        p = spf[x]\n        factors[p] += 1\n        x //= p\n    return factors\n\ndef mod_pow(a, b):\n    result = 1\n    while b &gt; 0:\n        if b % 2:\n            result = (result * a) % MOD\n        a = (a * a) % MOD\n        b //= 2\n    return result\n\ndef product_of_divisors(x):\n    factors = factorize(x)\n    D = 1\n    for a in factors.values():\n        D *= (a + 1)\n    result = 1\n    for p, a in factors.items():\n        exp = (D * a) // 2\n        result = (result * mod_pow(p, exp)) % MOD\n    return result\n\ndef solve(A: List[int], queries: List[int]) -&gt; List[int]:\n    n = len(A)\n    build_spf()\n\n    prev = [-1] * n\n    next_ = [n] * n\n\n    stack = []\n    for i in range(n):\n        while stack and A[stack[-1]] &lt; A[i]:\n            stack.pop()\n        if stack:\n            prev[i] = stack[-1]\n        stack.append(i)\n\n    stack = []\n    for i in range(n-1, -1, -1):\n        while stack and A[stack[-1]] &lt;= A[i]:\n            stack.pop()\n        if stack:\n            next_[i] = stack[-1]\n        stack.append(i)\n\n    count = defaultdict(int)\n    for i in range(n):\n        left = i - prev[i]\n        right = next_[i] - i\n        count[A[i]] += left * right\n\n    freq = []\n    for x in count:\n        fx = product_of_divisors(x)\n        freq.append((fx, count[x]))\n\n    freq.sort(reverse=True)\n\n    prefix = []\n    total = 0\n    for val, cnt in freq:\n        total += cnt\n        prefix.append((total, val))\n\n    result = []\n    for k in queries:\n        idx = bisect.bisect_left(prefix, (k, -1))\n        result.append(prefix[idx][1])\n\n    return result\n</code></pre>"},{"location":"DSAyy/binary_search/#median-of-two-sorted-arrays","title":"Median of Two Sorted Arrays","text":""},{"location":"DSAyy/binary_search/#problem-statement_3","title":"Problem Statement","text":"<p>Given two sorted arrays \\(A\\) and \\(B\\) of lengths \\(m\\) and \\(n\\), compute the median of the merged array in \\(O(\\log(\\min(m, n)))\\) time.</p> <p>If the total number of elements is even, return the average of the two middle elements.</p>"},{"location":"DSAyy/binary_search/#constraints_3","title":"Constraints:","text":"<ul> <li>\\(0 \\leq |A|, |B| \\leq 10^6\\)</li> <li>\\(1 \\leq |A| + |B| \\leq 2 \\cdot 10^6\\)</li> </ul>"},{"location":"DSAyy/binary_search/#approach","title":"Approach","text":"<p>Naively merging and sorting the arrays takes \\(O(m+n)\\) time, which is too slow. Instead, use binary search on the smaller array to find the correct partition:</p> <p>Let \\(i\\) be the partition index in \\(A\\), and \\(j\\) in \\(B\\), such that: $$ i + j = \\left\\lfloor \\frac{m+n+1}{2} \\right\\rfloor $$</p> <p>Let: - \\(a_{\\text{left}} = A[i-1]\\) or \\(-\\infty\\) if \\(i=0\\) - \\(a_{\\text{right}} = A[i]\\) or \\(+\\infty\\) if \\(i=m\\) - \\(b_{\\text{left}} = B[j-1]\\) or \\(-\\infty\\) if \\(j=0\\) - \\(b_{\\text{right}} = B[j]\\) or \\(+\\infty\\) if \\(j=n\\)</p> <p>The correct partition satisfies: $$ a_{\\text{left}} \\leq b_{\\text{right}} \\quad \\text{and} \\quad b_{\\text{left}} \\leq a_{\\text{right}} $$</p> <ul> <li>If true, we can compute the median:</li> <li>If total is odd:     $$ \\max(a_{\\text{left}}, b_{\\text{left}}) $$</li> <li> <p>If total is even:     $$ \\frac{\\max(a_{\\text{left}}, b_{\\text{left}}) + \\min(a_{\\text{right}}, b_{\\text{right}})}{2} $$</p> </li> <li> <p>If \\(a_{\\text{left}} &gt; b_{\\text{right}}\\), move \\(i\\) left.</p> </li> <li>If \\(b_{\\text{left}} &gt; a_{\\text{right}}\\), move \\(i\\) right.</li> </ul>"},{"location":"DSAyy/binary_search/#python-code_3","title":"Python Code","text":"<pre><code>def findMedianSortedArrays(A, B):\n    if len(A) &gt; len(B):\n        A, B = B, A\n\n    m, n = len(A), len(B)\n    total = m + n\n    half = (total + 1) // 2\n\n    lo, hi = 0, m\n    while lo &lt;= hi:\n        i = (lo + hi) // 2\n        j = half - i\n\n        a_left = float('-inf') if i == 0 else A[i - 1]\n        a_right = float('inf') if i == m else A[i]\n        b_left = float('-inf') if j == 0 else B[j - 1]\n        b_right = float('inf') if j == n else B[j]\n\n        if a_left &lt;= b_right and b_left &lt;= a_right:\n            if total % 2 == 1:\n                return max(a_left, b_left)\n            else:\n                return (max(a_left, b_left) + min(a_right, b_right)) / 2\n        elif a_left &gt; b_right:\n            hi = i - 1\n        else:\n            lo = i + 1\n\n    return 0.0\n</code></pre>"},{"location":"DSAyy/binary_search/#rotated-sorted-array-search","title":"Rotated Sorted Array Search","text":""},{"location":"DSAyy/binary_search/#problem-statement_4","title":"Problem Statement","text":"<p>Given a rotated sorted array \\(A\\) (with distinct integers) and an integer \\(B\\), find the index of \\(B\\) using \\(O(\\log N)\\) time, or return \\(-1\\) if \\(B\\) is not present.</p>"},{"location":"DSAyy/binary_search/#key-insight","title":"Key Insight","text":"<p>Although the array is rotated, at least one half of any subarray \\([lo, hi]\\) is sorted. This allows us to perform binary search.</p>"},{"location":"DSAyy/binary_search/#binary-search-strategy","title":"Binary Search Strategy","text":"<ol> <li>Compute \\(mid = \\left\\lfloor \\frac{lo + hi}{2} \\right\\rfloor\\)</li> <li>If \\(A[mid] == B\\), return \\(mid\\)</li> <li>Otherwise, check which half is sorted:</li> <li>If \\(A[lo] \\leq A[mid]\\) (left half sorted):<ul> <li>If \\(A[lo] \\leq B &lt; A[mid]\\): search left</li> <li>Else: search right</li> </ul> </li> <li>Else (right half sorted):<ul> <li>If \\(A[mid] &lt; B \\leq A[hi]\\): search right</li> <li>Else: search left</li> </ul> </li> </ol>"},{"location":"DSAyy/binary_search/#python-code_4","title":"Python Code","text":"<pre><code>def search_rotated_array(A, B):\n    lo, hi = 0, len(A) - 1\n    while lo &lt;= hi:\n        mid = (lo + hi) // 2\n        if A[mid] == B:\n            return mid\n        if A[lo] &lt;= A[mid]:  # Left half is sorted\n            if A[lo] &lt;= B &lt; A[mid]:\n                hi = mid - 1\n            else:\n                lo = mid + 1\n        else:  # Right half is sorted\n            if A[mid] &lt; B &lt;= A[hi]:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n    return -1\n</code></pre>"},{"location":"DSAyy/bit_manipulation/","title":"Bit Manipulation","text":""},{"location":"DSAyy/bit_manipulation/#number-of-1-bits-hamming-popcount","title":"Number of 1 bits (Hamming / Popcount)","text":"<p>Given a non-neg int A, return the number 1 bits in it.</p> <pre><code>def countSetBits(A):\n    count = 0\n    while n:\n        n &amp;= (n-1) #clears the least significant set bit\n        count += 1\n    return count\n</code></pre>"},{"location":"DSAyy/bit_manipulation/#trailing-zeroes-in-binary-representation","title":"Trailing Zeroes in Binary Representation","text":"<p>Given an int, count the trailing zeroes in binary representation.</p> <pre><code>def trailBinZer(A):\n    count = 0\n    while A&amp;1 == 0:\n        count += 1\n        A &gt;&gt;= 1\n    return count\n</code></pre>"},{"location":"DSAyy/bit_manipulation/#reverse-bits","title":"Reverse Bits","text":"<p>Given a 32 bit unsigned int, return the value with all bits reversed.</p> <p>A = 3 (00000000000000000000000000000011), Output: 11000000000000000000000000000000 = 3221225472</p> <pre><code>def reverse(A):\n    rev = 0\n    for i in range(32):\n        rev = (rev &lt;&lt; 1) | (A &amp; 1)\n        A &gt;&gt;= 1\n    return rev\n</code></pre>"},{"location":"DSAyy/bit_manipulation/#divide-integers-without-multiplication-div-or-mod","title":"Divide Integers (without multiplication, div or mod)","text":"<p>Given two numbers, divide them without multiplication, division or modulus operations.</p> <p>If overflow, return INT_MAX (\\(2^{31} - 1\\)) </p>"},{"location":"DSAyy/bit_manipulation/#how","title":"How","text":"<p>For each bit from 31 to 0, check if (B &lt;&lt; shift) fits in the dividend.</p> <p>If yes, set the corresponding bit in the quotient, and subtract (B &lt;&lt; shift) from the dividend.</p> <p>Finally assign the corresponding sign.</p> <pre><code>def divide(A,B):\n    INT_MAX = 2**31 - 1\n    INT_MIN = -2**31\n    if A == INT_MIN and  B == -1:\n        return INT_MAX\n    negative = (A &lt; 0) != (B &lt; 0)\n    dividend = abs(A) #converting to 64 bit unsigned\n    divisor = abs(B)\n    result = 0\n    for shift in range(31,-1,-1):\n        if (dividend &gt;&gt; shift) &gt;= divisor:\n            result |= (1 &lt;&lt; shift)\n            dividend -= (divisor &lt;&lt; shift)\n    if negative:\n        result = -result\n    return result\n</code></pre>"},{"location":"DSAyy/bit_manipulation/#different-bits-sum-pairwise","title":"Different Bits Sum Pairwise","text":"<p>Given N positive int \\(A_1...A_N\\), compute the sum: $$ \\sum_{i=1}^{N}\\sum_{j=1}^{N}f(A_i,A_j) $$ where f(X,Y) is the number of different bits between x and y. Return the result modulo \\(10^9 + 7\\)</p> <p>Ex: A = 1,3,5 Output = 8</p>"},{"location":"DSAyy/bit_manipulation/#how_1","title":"How","text":"<p>Instead of \\(N^2\\) , use the linearity of counting- For each bit position (0 to 31), count how many numbers have bit set and unset (ones and zeroes). Each differing pair adds 1 to \\(f(A_i,A_j)\\) for both \\((i,j)\\) and \\((j,i)\\).</p> <p>$$ cntPairs = 2 \\times ones \\times zeros $$ because both \\((i,j)\\) and \\((j,i)\\) count.</p> <pre><code>def cntBits(A):\n    MOD = 10**9 + 7\n    n = len(A)\n    bitCount = [0]*32\n    for x in A:\n        for b in range(32):\n            if x &amp; (1 &lt;&lt; b):\n                bitcount[b] += 1\n    ans = 0\n    for b in range(32):\n        ones = bitcount[b]\n        zeros = n - ones\n        ans = (ans + (2*ones*zeros) % MOD) % MOD\n    return ans\n</code></pre>"},{"location":"DSAyy/bit_manipulation/#count-total-set-bits-from-1-to-a","title":"Count Total Set Bits from 1 to A","text":"<p>Given a positive int \\(A\\), count the total set bits in the binary representation of all numbers from \\(1\\) to \\(A\\). Return ans modulo \\(10^9 + 7\\)</p>"},{"location":"DSAyy/bit_manipulation/#how_2","title":"How","text":"<p>Cant be naive, I am standing on business, isn't that clocking to you.</p> <p>For each bit position, observe nigga, Bit \\(i\\) in all numbers cycles between blocks of 0s and 1s of length \\(2^i\\).</p> <p>Over a range 0 to A, for each full block length of \\(2^{i+1}\\), bit i is 1 for exactly \\(2^i\\) times.</p> <p>How many full cycles in A? \\(fullCycles = \\frac{A+1}{2^{i+1}}\\) </p> <p>Each full cycle contributes \\(2^i\\) set bits.</p> <p>Now for the leftovers, if \\(rem = (A+1)\\%2^{i+1}\\) the bit is 1 for atmost \\(max(0,rem - 2^i)\\) numbers.</p> <p>Sum for all i.</p> <pre><code>def countTotalSetBits(A):\n    MOD = 10**9 + 7\n    n = A+1\n    ans = 0\n    for i in range(31):\n        bitMask = 1 &lt;&lt; i\n        cycleLen = 1 &lt;&lt; (i+1)\n        fullCycles = n // cycleLen\n        ans += fullCycles*bitMask\n        rem = n % cycleLen\n        extra = max(0, rem - bitMask)\n        ans += extra\n    return ans % MOD\n</code></pre>"},{"location":"DSAyy/bit_manipulation/#palindromic-binary-representation","title":"Palindromic Binary Representation","text":"<p>Given an int \\(A\\), find the \\(A\\)th positive integer, whose binary representation is a palindrome.</p> <p>Note: first number is 1.</p>"},{"location":"DSAyy/bit_manipulation/#how_3","title":"How","text":"<p>We can generate Ath instead of checking each one.</p> <p>For every bit length L, we can count how many palindromic exists. Left half of the bit determines the palindrome, right is just a mirror.</p> <p>Highest bit is always \\(1\\).</p> <p>Steps:</p> <ol> <li> <p>Find the bit-length L such that Ath palindrome lies within.</p> </li> <li> <p>Within palindromes of length L, determine the index of our target.</p> </li> <li> <p>Construct the left half. (with top bit 1 and the rest from binary counting)</p> </li> <li> <p>Mirror this to complete the palindrome.</p> </li> </ol> <p>Ex: Find the 9th one</p> <ul> <li> <p>L = 5 (1 + 2 + 2 + 4 = 9 so it falls in this length)</p> </li> <li> <p>Half is \\(\\lceil 5/2 \\rceil = 3\\) bits. The prefix ranges from \\(100_2\\) to \\(111_2\\) (4 possibilites)</p> </li> <li> <p>\\(9\\)th means prefix is \\(100_2\\) since \\(9\\) is the first among \\(L = 5\\) palindromes.</p> </li> <li> <p>\\(11011_2 = 27_{10}\\)</p> </li> </ul> <pre><code>import math\ndef palindromicBinary(A):\n    remaining = A\n    for L in range(1,64): #find the length of palindromic binary\n        half = (L+1)//2 \n        count = 1 &lt;&lt; (half - 1)\n        if remaining &gt; count:\n            remaining -= count\n        else:\n            break\n    idx = remaining - 1\n    prefix = (1 &lt;&lt; (half - 1)) | idx #add leading 1 to maintain length\n    result = prefix\n    toMirror = prefix &gt;&gt; (L%2) #skip middle if L is odd\n\n    for _ in range(half):\n        result = (result &lt;&lt; 1)|(toMirror &amp; 2)\n        toMirror &gt;&gt;= 1\n    return result   \n</code></pre>"},{"location":"DSAyy/bit_manipulation/#xor-ing-the-subarrays","title":"XOR-ing the subarrays","text":"<p>Given an array A of N integers, perform the following:</p> <ol> <li> <p>For every contiguous subarray, XOR its elements.</p> </li> <li> <p>XOR all these results, return the final value.</p> </li> </ol>"},{"location":"DSAyy/bit_manipulation/#how_4","title":"How","text":"<p>An element affects the XOR only if it appears odd number of times in all subarrays.</p> <p>Number of subarrays containing \\(A[i] = (i+1) \\times (N-i)\\)</p> <p>Fact: When N is even, every \\((i+1) \\times (N-i)\\) is even for all i, so ans is \\(0\\).</p> <p>When N is odd, only the elements at even indices (0-based), have \\((i+1) \\times (N-i)\\) odd.</p> <p>When N is odd, just XOR the even index elements.</p> <pre><code>def XORSub(A):\n    N = len(A)\n    if (N&amp;1)==0: return 0\n    ans = 0\n    for i in range(0,N,2):\n        ans ^= A[i]\n    return ans\n</code></pre>"},{"location":"DSAyy/bit_manipulation/#single-number-every-number-appears-twice-except-one","title":"Single Number (Every Number Appears Twice Except One)","text":"<p>Int array A, every element appears twice except one, find.</p> <p>Just XOR the whole thing.</p> <pre><code>def singleNumber(A):\n    ans = 0\n    for x in A:\n        ans ^= x\n    return ans\n</code></pre>"},{"location":"DSAyy/bit_manipulation/#single-number-ii-every-element-appears-thrice-except-1","title":"Single Number II (Every Element Appears Thrice Except 1)","text":"<p>Given an array A, every element appears thrice except one, find it.</p>"},{"location":"DSAyy/bit_manipulation/#how_5","title":"How","text":"<p>Hashmap nononono</p> <p>Sigma: use variables \\(ones\\) and \\(twos\\), to record the bitwise modulo \\(3\\) sum for all numbers seen so far. Each bit in \\(ones\\) and twos$ $forms a \\(base-3\\) counter for that bit position.</p> <ul> <li>ones records the bits seen once modulo 3</li> <li>twos records bits seen twice modulo 3</li> <li> <p>for new x:</p> <ul> <li> <p>Add \\(x\\)'s bits to \\(ones\\) where not already in \\(twos\\)</p> </li> <li> <p>Add \\(x\\)'s bits to \\(A\\) where not already in updates \\(ones\\).</p> </li> </ul> </li> </ul> <p>After all elements, \\(ones\\) contains the answer.</p> <pre><code>def singleNumber(A):\n    ones = 0 #bits seen exactly once (modulo 3)\n    twos = 0 #bits seen exactly twice (modulo 3)\n    for x in A:\n        ones = (ones ^ x) &amp; ~twos\n        twos = (twos ^ x) &amp; ~ones\n    return ones\n</code></pre>"},{"location":"DSAyy/bit_manipulation/#the-one-among-fakes","title":"\ud83e\udd4a \"The One Among Fakes\"","text":"<p>In a world full of noise, where fakes come in threes, I stand like a king, with code that don\u2019t freeze. Most of 'em copy, repeat, disappear \u2014 But one\u2019s got that spark, that truth crystal clear.</p> <p>\"I track with two masks,\" I boldly declare, Ones and twos \u2014 yeah, I split it with flair. First time you show up? You land in my grip. Second time? I move you \u2014 tighten the zip.</p> <p>But come at me thrice? You're gone, erased. This empire\u2019s mine \u2014 I don't leave a trace. Only the rare stays in my throne, While impostors fall like kings de-throned.</p> <p>Bit by bit, I scan with might, With logic sharper than a knight. When the dust settles and lies are gone, The truth remains \u2014 the chosen one.</p> <p>So when they ask, \u201cWho\u2019s left?\u201d \u2014 I say with pride, \"The man who showed once, and never had to hide.\" He walks through zeros, untouchable flame \u2014 And <code>ones</code> holds his code, forever the name.</p>"},{"location":"DSAyy/dp/","title":"Dynamic Programming","text":""},{"location":"DSAyy/dp/#longest-common-subsequence","title":"Longest Common Subsequence","text":""},{"location":"DSAyy/dp/#question-statement","title":"Question Statement","text":"<p>Given 2 strings, find the length of uska longest common subsequence. Note subsequence does not have to be continuous.</p> <p>Example: A = \\(abbcdgf\\) and B = \\(bbadcgf\\)  toh the output would be 5 (bbcgf is the lcs)</p>"},{"location":"DSAyy/dp/#kaise-karna-hai","title":"Kaise karna hai","text":"<p>Thode subproblems meh divide karte hai isse. Let \\(\\text{LCS[i][j] be LCS of substrings A[0...i] and B[0....j]}\\) . Toh the obvious relation we can find is if \\(\\text{A[i-1] == B[j-1] fir LCS[i][j] is just LCS[i-1][j-1] + 1}\\)  which means ki humme ek element same mil gaya, toh length would be 1 + the substrings removing those used indexes dono strings se. else \\(\\text{take max of LCS[i-1][j] and LCS[i][j-1]}\\) coz wahi dono possibilities are left.  which means dono string se ek element skip karke check karlo Humhe continuity bhi maintain karni hai. Thats it literally.</p> <p><pre><code>int LCS(string A, string B){\n    int n = A.size(), m = B.size();\n    vector&lt;vector&lt;int&gt;&gt; lcs(n+1, vector&lt;int&gt;(m+1,0));\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= m; ++j){\n            if (A[i-1] == B[j-1]) lcs[i][j] = 1 + lcs[i-1][j-1];\n            else lcs[i][j] = max(lcs[i-1][j], lcs[i][j-1]); \n        }\n    return lcs[n][m];\n}\n</code></pre> Time complexity \\(O(n \\times m)\\)  and and same with space Now the sexy part is hum isse aur optimize kar sakte hai</p> <p>Abhi let \\(\\text{prev}\\) be the results of the i-1 row, and \\(curr\\) be the result of the current row i</p> <p>\\(\\text{LCS[i-1][j-1] = previous row ka j-1}\\) \\(\\text{LCS[i-1][j] = previous row ka j}\\) \\(\\text{LCS[i][j-1] = cur row ka j-1}\\)</p> <pre><code>int LCS(string A, string B){\n    int n = A.size(), m = B.size();\n    if (m &gt; n){\n        // keeping the rows as the bigger one, since lcs ka upper limit toh chotta wala hi hoga\n        swap(A,B);\n        swap(m,n);\n    }\n    vector&lt;int&gt; prev(m+1, 0), cur(m+1,0);\n    for (int row = 1; row &lt;= n; ++row){\n        for (int j = 1; j &lt;= m; ++j){\n            if (A[i-1] == B[j-1])\n                cur[j] = prev[j-1] + 1; \n                // we found a similar el, toh prev row ke result se ek zyada hoga\n            else \n                cur[j] = max(prev[j], cur[j-1]);\n        }\n        swap(prev,cur)\n    }\n    return prev[M]\n}\n</code></pre> <p>Isme the space complexity changed from \\(O(n\\times m)\\) se \\(O(min(n,m))\\) </p>"},{"location":"DSAyy/dp/#longest-palindromic-subsequence","title":"Longest Palindromic Subsequence","text":""},{"location":"DSAyy/dp/#question-statement_1","title":"Question Statement","text":"<p>Given a string A, find length of the longest palindromic subsequence. Example: \\(A = beebeeed\\)  the output would be 4 coz LPS is \\(eeee\\)</p>"},{"location":"DSAyy/dp/#karna-kaise-hai","title":"Karna kaise hai","text":"<p>Abe chutiye, Longest palindromic substring is just the LCS of A and reversed(A)</p> <p>I am not even gonna waste my time fuck off. $$ LPS(A) = LCS(A, reverse(A)) $$</p>"},{"location":"DSAyy/dp/#edit-distance","title":"Edit Distance","text":""},{"location":"DSAyy/dp/#problem-statement","title":"Problem Statement","text":"<p>Given 2 strings, find min steps required to convert A to B given in one step we can - Insert a char - Delete a char - Replace a char Example: - A = abad, B = abac. The output is 1 coz sirf c ko d se replace karna</p>"},{"location":"DSAyy/dp/#kaise-karna","title":"Kaise karna","text":"<p>Let \\(edit[i][j]\\) be the minimum dist to convert \\(A[0...i-1] \\space and \\space B[0...j-1]\\)  Toh iska rishta is  $$ edit[i][j] = edit[i-1][j-1] \\space \\text{if A[i-1] and B[j-1] same hai} $$ $$ \\text{else if its different, edit[i][j] is gonna be 1 + min(edit[i-1][j], edit[i-1][j-1], edit[i-1][j-1])} $$ \\(edit[i-1][j]\\) means hum \\(A[i-1]\\) delete kar rahe hai same with \\(edit[i][j-1]\\) meaning \\(B[j-1]\\) delete \\(edit[i-1][j-1]\\) matlab bro humne dono ko replace kar diya ek dusre se and both are updated</p>"},{"location":"DSAyy/dp/#base-cases","title":"Base Cases","text":"<p>Kuch baate sacch hoti hai Jaise, \\(edit[0][j] = j\\) -&gt; means \\(B[0..j]\\) ko empty karne ke liye j operations are needed. Similarly. \\(edit[i][0] = i\\)</p> <p>Bas bhai ab chalao for loop, sabke level nikalenge.</p> <pre><code>int editDistance(string A, string B){\n    int n = A.size(), B = B.size();\n    vector&lt;vector&lt;int&gt;&gt; edit(n+1, vector&lt;int&gt; (m+1, 0));\n    // sach baate\n    for (int i = 1; i &lt;= n; ++i) edit[i][0] = i;\n    for (int j = 1; j &lt;= m; ++j) edit[0][j] = j;\n\n    for (int i = 1; i &lt;= n; ++i){\n        for (int j = 1; j &lt;= m; ++j){\n            if (A[i-1] == B[j-1]) \n                edit[i][j] = edit[i-1][j-1];\n                // no extra edits needed\n            else {\n                edit[i][j] = 1 + min({\n                    edit[i-1][j], edit[i][j-1], edit[i-1][j-1]\n                });\n            }\n        }\n    }\n    return dp[n][m];\n}\n</code></pre> <p>Time and Space dono in this are \\(O(n\\times m)\\)</p>"},{"location":"DSAyy/dp/#repeating-subsequence","title":"Repeating Subsequence","text":""},{"location":"DSAyy/dp/#problem-kya-yap-kar-raha","title":"Problem kya yap kar raha","text":"<p>String A, check kar if its longest repeating subsequence is \\(\\geq\\) 2.  Repeating subsequence is basically repeating subsequence.</p> <p>Example: A = \\(abab\\), Output is 1 (subseq \\(ab\\) repeats)</p>"},{"location":"DSAyy/dp/#how-to-solve","title":"How to solve?","text":"<p>$$ \\text{Repeating subsequence (A) is LCS(A,A) but i } \\neq  j $$   Aur kuch bhi nahi.</p> <p>bas  $$ \\text{return dp[n][n] } \\geq 2 $$</p>"},{"location":"DSAyy/dp/#distinct-subsequences","title":"Distinct Subsequences","text":""},{"location":"DSAyy/dp/#problem-statement_1","title":"Problem Statement","text":"<p>Given 2 sequences A and B, count ways to form B as a subseq of A.</p> <p>Example: - A = rabbbit, B = rabbit, Output 3     - Basically all 3 <code>b</code> can be removed.</p>"},{"location":"DSAyy/dp/#karu-kaise","title":"Karu kaise?","text":"<p>Let \\(ways[j]\\) be ways to form \\(B[0...j]\\)  as a subseq of first <code>i</code> elements of A.  Isse 1D meh fit kar sakte if we update j from right to left, toh \\(ways[j-1]\\) hoga from previous <code>i</code> </p> <p>Toh the rishta would be  $$ ways[j] = ways[j] + ways[j-1] \\text{      if A[i-1] == B[j-1]} $$ warna \\(ways[j]\\) would remain 0, coz agar element hi same nai toh string kaise banega with those indexes. Note ki \\(ways[j-1]\\) humare previous i ke iteration se hoga, so we have already computed pehle ka.</p> <pre><code>int distSubseq(string A, string B){\n    int n = A.size(), m = B.size();\n    vector&lt;long long&gt; ways(m+1,0);\n    ways[0] = 1; //empty banane ke liye kya hi chahiye\n    for (int i = 1; i &lt;= n; ++i){\n        for (int j = m; j &gt;= 1; --j){\n            if (A[i-1] == B[j-1]){\n                ways[j] += ways[j-1];\n            }\n        }\n    }\n    return (int)ways[m];\n}\n</code></pre>"},{"location":"DSAyy/dp/#scramble-string","title":"Scramble String","text":""},{"location":"DSAyy/dp/#what-does-the-dog-say","title":"What does the dog say?","text":"<p>Given 2 strings, bata if the other string can be made by scrambling A. Now what the fuck is scrambling? B is scramble(A) if -&gt; A can be represented as a binary tree by recursively partitioninng into two non-substrings, and by swapping left and right children any number of times, we can get B. What the helly?</p> <p>Input: A= <code>we</code> and B = <code>we</code>  Ans = 1.</p>"},{"location":"DSAyy/dp/#bhai-mar-jau-meh","title":"Bhai mar jau meh?","text":"<p>Iske liye we use 3D dp. Whether  <code>A[i...i+len - 1]</code> can be scrambled into <code>B[j....j+len - 1]</code> Let <code>scramble[i][j][len]</code> be true if <code>A.substr(i,len)</code> can be scrambled into <code>B.substr(j,len</code></p>"},{"location":"DSAyy/dp/#hard-truth","title":"Hard Truth","text":"<p>Bhai pata nahi yaar ye scrambling shit kya hai Base Case: For length 1, <code>scramble[i][j][1] = (A[i] == B[j])</code>      Like bhai ek hi toh length hai, same string hi hogaya ye toh For each length \\(l\\) from 2 to n, for all <code>A.substr(i,l)</code> and <code>B.substr(j,l)</code> har ek split <code>k</code> try kar le - No swap: <code>scramble[i][j][l]</code> is true if \\(scramble[i][j][k] \\space \\&amp; \\space scramble[i][j][l-k]\\) meaning dono continuous partitions valid hai. - Swap: <code>scramble[i][j][l]</code> is true if <code>scramble[i][j+l-k][k]</code> and <code>scramble[i+k][j][l-k]</code> dono true hai Also quick check: If dono sorted are different, tab toh they cant scramble.</p> <p><pre><code>bool isScramble(string A, string B){\n    int n = A.size();\n    if (n != B.length()) return 0;\n    //quick sorted check\n    {\n        array&lt;int,256&gt; freq = {0};\n        for (char c : A) freq[(unsigned char)c]++;\n        for (char c : B) freq[(unsigned char)c]--;\n        for (int x : freq) if (x != 0) return 0;\n    }\n    static bool scramble[51][51][51];\n    memset(dp,false, sizeof(scramble));\n    // base case\n    for (int i = 0; i &lt; n; ++i)\n        for (int j = 0; j &lt; n; ++j)\n            scramlbe[i][j][1] = (A[i] == B[i]);\n    for (int len = 2; len &lt;= n; ++len){\n        for (int i = 0; i + len &lt;= n; ++i){\n            for (int j = 0; j + len &lt;= n; ++j){\n                for (int k = 1; k &lt; len; k++){\n                    if ((scramble[i][j][k] &amp;&amp; scramble[i+k][j+k][len-k]) || \n                        (scramble[i][j+len - k][k] &amp;&amp; scramble[i+k][j][len - k]){\n                        scramble[i][j][len] = 1;\n                        break;\n                        }\n                    )\n                }\n            }\n        }\n    }\n    return scramble[0][0][n] ? 1 : 0;\n}\n</code></pre> Time Complexity: \\(O(n^4)\\)</p>"},{"location":"DSAyy/dp/#wildcard-pattern-matching","title":"WildCard Pattern Matching","text":""},{"location":"DSAyy/dp/#problem-kya-hai","title":"Problem kya hai","text":"<p>Given 2 strings, find the wildcard pattern between them - <code>?</code> matches any single character - <code>*</code> matches any sequence of character This match must cover the entire string</p> <p>Return if A can be formed with the B pattern - A = <code>aa</code> and B = <code>a*</code> , then ans is 1 - A = <code>aab</code> and B = <code>c*a*b</code>, then output 0 hai</p>"},{"location":"DSAyy/dp/#karna-kaise-hai_1","title":"Karna kaise hai","text":"<p>Iske liye 2 pointer greedy karna padega with some backtracking for the <code>*</code> wala part. - If the character at B is <code>*</code>, remember uska position and current index in A, and try to match it with 0 chars first. - If there is a mismatch, then look for the previous <code>*</code>, since that can save us, and then advance the A pointer and try to match with more. - If the current pointer in B is <code>?</code> ya fir it matches A, then advance both the pointers - If A khatam hogaya, then skip the trailing <code>*</code> in B - If dono khatam, then ans is 1</p> <pre><code>bool isMatch(string A, string B){\n    int n = A.size(), m = B.size();\n    int i = 0, j = 0;\n    int last_star = -1, match_i = 0;\n    while (i &lt; n){\n        if (j &lt; m &amp;&amp; (B[j] == A[i] || B[i] == '?')) \n            i++,j++;\n        else if (j &lt; m &amp;&amp; B[j] == '*'){\n            last_star = j;\n            match_i = i;\n            j++;\n        }\n        else if (last_star != -1){\n            j = last_star + 1;\n            match_i++;\n            i = match_i;\n        }\n        else \n            return 0;\n    }\n    while (j &lt; m &amp;&amp; B[j] == '*') j++;\n    return (j == m)? 1: 0;\n}\n</code></pre>"},{"location":"DSAyy/dp/#pattern-matching-and","title":"Pattern Matching . and *","text":""},{"location":"DSAyy/dp/#problem-kya-hai_1","title":"Problem kya hai","text":"<p>Again pattern matching but, - <code>.</code> means atleast ek element hai here - <code>*</code> ek element nahi bhi hoga toh chalega Example: match(<code>aa</code>, <code>.*</code>) is 1, but match(<code>aa</code>,<code>.</code>) is 0.</p>"},{"location":"DSAyy/dp/#kaise-karna-hai_1","title":"Kaise karna hai","text":"<p>Yaha we finally use dynamic programming. <code>match[i][j]</code> means <code>a[0...i-1]</code> matches <code>b[0..j-1]</code> But isse bhi optimize karenge for only two rows.</p>"},{"location":"DSAyy/dp/#rishte","title":"Rishte","text":"<ul> <li>If <code>B[j-1]</code> is <code>.</code> or <code>a[i-1]</code> matches one character, tab <code>match[i][j] = match[i-1][j-1]</code></li> <li>If <code>B[j-1]</code> is <code>*</code>, tab it can match zero or more previous element:<ul> <li>Zero occurence: \\(match[i][j] \\space | \\space  match[i][j-2]\\)</li> <li>One or more: If <code>A[i-1]</code> matched <code>B[j-2]</code> or <code>B[j-2]</code> is <code>.</code>, then <code>match[i][j]</code> |= <code>match[i-1][j]</code></li> </ul> </li> <li>else <code>match[i][j] = 0</code></li> </ul>"},{"location":"DSAyy/dp/#truth","title":"Truth","text":"<ul> <li><code>match[0][0]</code> = 1 (empty toh match hoga hi)</li> <li><code>match[0][j]</code> = 1 if <code>B[0...j-1]</code> can represent empty </li> <li><code>match[i][0] = 0</code> for i &gt; 0 coz non-empty match nahi kar sakta empty se</li> </ul> <p>The less optimized one but easier to understand: <pre><code>/*\n   Regex-like pattern match for\n     .  = exactly one arbitrary character\n     *  = zero or more copies of the PREVIOUS pattern symbol\n   dp[i][j]  == true  \u21d4   A[0 .. i-1] matches  B[0 .. j-1]\n   (so the table has   (n+1) \u00d7 (m+1)   entries)\n*/\nbool isMatch2D(const string&amp; A, const string&amp; B)\n{\n    int n = A.size(), m = B.size();\n    vector&lt;vector&lt;bool&gt;&gt; dp(n + 1, vector&lt;bool&gt;(m + 1, false));\n    // \u278a empty pattern vs. empty text\n    dp[0][0] = true;\n    // \u278b first row: empty text vs. longer &amp; longer pattern\n    //    Only a chain like  x* y* z*  can match emptiness\n    for (int j = 2; j &lt;= m; ++j)\n        if (B[j - 1] == '*')\n            dp[0][j] = dp[0][j - 2];\n    // \u278c fill the whole grid\n    for (int i = 1; i &lt;= n; ++i)\n    {\n        for (int j = 1; j &lt;= m; ++j)\n        {\n            char pc = B[j - 1];          // current pattern symbol\n            if (pc != '*')               // case 1: normal char or '.'\n            {\n                bool same = (pc == '.' || pc == A[i - 1]);\n                dp[i][j] = same &amp;&amp; dp[i - 1][j - 1];\n            }\n            else                         // case 2: we\u2019re at a '*'\n            {\n                //   pc == '*'  \u2190 it always modifies B[j-2]\n                //   let prev = B[j - 2]\n                // \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n                // zero copies of prev*\n                bool zero      = dp[i][j - 2];\n                // one-or-more copies  \u21d2  prev must match A[i-1]\n                bool oneOrMore = false;\n                char prevPat   = B[j - 2];\n                if (prevPat == '.' || prevPat == A[i - 1])\n                    oneOrMore = dp[i - 1][j];\n                dp[i][j] = zero || oneOrMore;\n            }\n        }\n    }\n    return dp[n][m];\n}\n</code></pre> The optimized one: <pre><code>bool isMatch(string A, string B){\n    int n = A.size(), m = B.size();\n    vector&lt;bool&gt; prev(m+1, false), cur(m+1, false);\n    prev[0] = true;\n    for (int j = 1; j &lt;= m; ++j){\n        if (B[j-1] == '*' &amp;&amp; j &gt;= 2)\n            prev[j] = prev[j-2];\n        else \n            prev[j] = false;\n    }\n    for (int i = 1; i &lt;= n; ++i){\n        cur[0] = false;\n        for (int j = 1; j &lt;= m; ++j){\n            if (B[j-1] == '.' || B[j-1] == A[i-1])\n                cur[j] = prev[j-1];\n            else if (B[j-1] == '*'){\n                bool matchZero = (j &gt;= 2) ? cur[j-2] : false;\n                bool matchOneOrMore = (j &gt;= 2 &amp;&amp; \n                    (B[j-2] == '.' || B[j-2] == A[i-1])\n                    )? \n                    prev[j] : false;\n                cur[j] = matchZero || matchOneOrMore;\n            }\n            else cur[j] = false;\n        }\n        swap(cur,prev);\n    }\n    return prev[m] ? 1 : 0;\n}\n</code></pre></p>"},{"location":"DSAyy/dp/#length-of-longest-subsequence","title":"Length of Longest Subsequence","text":""},{"location":"DSAyy/dp/#problem-yap","title":"Problem yap","text":"<p>Given array A, find length of longest sequence whihc is strictly increasing  then strictly decreasing. (mountain peak type shit)</p> <p>Example: - A = <code>[1,11,2,10,4,5,2,1]</code>, output is 6 (<code>1,2,10,4,2,1</code>)</p>"},{"location":"DSAyy/dp/#how","title":"How????","text":"<p>So this mountain thing is called bitonic subsequence. - For each i, compute <code>lis[i]</code> which is the length of longest increasing subsequence ending at i. - then also compute <code>lds[i]</code> which is length of longest decreasing subsequence starting at i - Ab bas har ek index pe compute dono ka sum  \\(lis[i] + lds[i] - 1\\)</p> <pre><code>int longSubseq(vector&lt;int&gt; &amp;A){\n    int n = A.size();\n    if (n == 0) return 0;\n    vector&lt;int&gt; lis(n,1);\n    for (int i = 0; i &lt; n; ++i)\n        for (int j = 0; j &lt; i; ++j)\n            if (A[j] &lt; A[j])\n                lis[i] = max(lis[i], lis[j] + 1);\n    vector&lt;int&gt; lds(n,1);\n    for (int i = n-1; i &gt;= 0; --i)\n        for (int j = i+1; j &lt; n; ++j)\n            if (A[j] &lt; A[i])\n                lds[i] = max(lds[i], lds[j] + 1);\n    int ans = 0;\n    for (int i = 0; i &lt; n; ++i) \n        ans = max(ans, lis[i] + lds[i] - 1);\n    return ans;\n}\n</code></pre>"},{"location":"DSAyy/dp/#smallest-subsequence-given-the-primes","title":"Smallest subsequence given the primes.","text":""},{"location":"DSAyy/dp/#sexy-ass-statement","title":"Sexy ass statement","text":"<p>Given 3 prime numbers, and an integer D, find the first smallest D positive numbers which only have A,B,C, or a combination of them as their prime factors.</p> <p>Input: A,B,C,D, Output: Array of size D</p> <ul> <li>A= 2, B = 3, C = 5, D = 5<ul> <li>the output is <code>2,3,4,5,6</code></li> </ul> </li> </ul>"},{"location":"DSAyy/dp/#how-to-do-this-shit","title":"How to do this shit.","text":"<p>What they ask is <code>Ugly Numbers</code> (numbers with only prime as their factors) We use 3 pointers, with a min-merge approach - Maintain an array <code>res</code> initialized with the sequence {1} - For each index, multiple previous seq elements by A,B,C and pick the smallest new candidate. - Increment pointers which produced the candidate to avoid duplicates. $$ res[next] = min(res[i_1]\\times A,res[i_2]\\times B, res[i_3]\\times C) $$</p> <pre><code>vector&lt;int&gt; subseq(int A, int B, int C, int D){\n    vector&lt;long long&gt; primes = {(long long)A,(long long)B, (long long)C};\n    sort(primes.begin(),primes.end());\n    long long p1 = primes[0], p2 = primes[1], p3 = primes[2];\n    vector&lt;unsigned long long&gt; res(D+1);\n    res[0] = 1ull;\n    int i1 = 0, i2 =0, i3 = 0;\n    for (int idx = 1; idx &lt;= D; idx++){\n        unsigned long long \n            nextA = res[i1] * p1,\n            nextB = res[i2] * p2,\n            nextC = res[i3] * p3;\n        unsigned long long val = min({nextA, nextB, nextC});\n        res[idx] = val;\n        if (val == nextA) i1++;\n        if (val == nextB) i2++;\n        if (val == nextC) i3++;\n    }\n    vector&lt;int&gt; ans;\n    for (int k = 1; k &lt;= D; ++k){\n        ans.push_back((int)res[k]);\n    }\n    return ans;\n}\n</code></pre>"},{"location":"DSAyy/dp/#largest-area-of-rectangle-with-permutations","title":"Largest Area of Rectangle with Permutations","text":""},{"location":"DSAyy/dp/#what-does-this-bitch-yap","title":"What does this bitch yap","text":"<p>Given a binary grid A of \\(N \\times M\\), find the area of the largest rectangle containing only 1s.  We are allowed to permute the columns of the matrix in any order.</p> <p>Example $$ A = [[1,0,1],[0,1,0],[1,0,0]] $$ The output is 2</p>"},{"location":"DSAyy/dp/#how-to-do-this","title":"How to do this?","text":"<ul> <li>For each cell (i,j), compute <code>H[i][j]</code> = number of consecutive 1's ending at (i,j) upto row i.</li> <li>For each row, treat <code>H[i]</code> as histogram of column heights, and since <code>H[i]</code> can be permuted, sort <code>H[i]</code> in descending order.</li> <li>For each width k (the k largest column heights), the maximal rectangle is \\(height \\times width = H[i][k-1] \\times k\\) </li> <li>Take the best over all i and k. Example dry run: <pre><code>A\nrow0  1 0 1 1 0 1\nrow1  1 1 1 1 1 1\nrow2  1 1 1 0 1 1\nrow3  0 1 1 1 1 0\nrow4  1 1 1 1 1 1\n</code></pre></li> </ul> row i formula per column j H[i] 0 first row \u2192 copy <code>A</code> 1 0 1 1 0 1 1 if <code>A[1][j]==1</code> then <code>1+H[0][j]</code> else 0 2 1 2 2 1 2 2 same rule 3 2 3 0 2 3 3 same rule 0 3 4 1 3 0 4 same rule 1 4 5 2 4 1 row original H[i] after sort \u2193 <code>k</code> height \u00b7 width 0 1 0 1 1 0 1 1 1 1 0 0 0 1 \u2192 1 2 \u2192 2 3 \u2192 3 3 1 2 1 2 2 1 2 2 2 2 2 1 1 1 \u2192 2 2 \u2192 4 3 \u2192 6 4 \u2192 8 5 \u2192 5 6 \u2192 6 8 2 3 2 3 0 2 3 3 3 3 2 2 0 1 \u2192 3 2 \u2192 6 3 \u2192 9 4 \u2192 8 5 \u2192 10 10 3 0 3 4 1 3 0 4 3 3 1 0 0 1 \u2192 4 2 \u2192 6 3 \u2192 9 4 \u2192 4 9 4 1 4 5 2 4 1 5 4 4 2 1 1 1 \u2192 5 2 \u2192 8 3 \u2192 12 4 \u2192 8 12 <p>Hence the largest we find is \\(4 \\times 3 = 12\\) <pre><code>int maximalRectangle(vector&lt;vector&lt;int&gt;&gt; &amp; A){\n    int N = A.size();\n    if (N == 0) return 0;\n    int M = A[0].size();\n    // building H matrix\n    vector&lt;vector&lt;int&gt;&gt; H(N, vector&lt;int&gt; (M,0));\n    for (int j = 0; j &lt; M; ++j){\n        H[0][j] = A[0][j];\n        // starting meh consecutive ones is the 1 if the value at that ind is 1\n    }\n    for (int i = 1; i &lt; N; ++i)\n        for (int j = 0; j &lt; M; ++j){\n            if (A[i][j] == 1)\n                H[i][j] = H[i-1][j] + 1;\n            else H[i][j] = 0;\n        }\n    int ans = 0;\n    for (int i = 0; i &lt; N; ++i){\n        vector&lt;int&gt; row = H[i];\n        sort(row.rbegin(),row.rend());\n        for (int k = 1; k &lt;= M; ++k){\n            int height = row[k-1];\n            int area = height * k;\n            ans = max(ans, area);\n        }\n    }\n    return ans;\n}\n</code></pre></p>"},{"location":"DSAyy/dp/#tiling-with-dominoes","title":"Tiling with Dominoes","text":""},{"location":"DSAyy/dp/#problem-statement_2","title":"Problem Statement","text":"<p>Given integer A, find total ways to tile a \\(3 \\times A\\) board with \\(2 \\times 1\\) dominoes. Return answer % \\(10^9 + 7\\).</p> <p>Example:  - A = 2, Output = 3 - A = 1, Output = 0</p>"},{"location":"DSAyy/dp/#maths-behind-this","title":"Maths behind this","text":"<p>Let <code>f(n)</code> be the number of ways to tile a \\(3 \\times n\\) board. - <code>f[0]</code> = 1. (empty board) - <code>f[1]</code> = 0 (cannot be completely tiled) - <code>f[2]</code> = 3 - <code>f[3]</code> = 0. (odd ke liye toh impossible hai completely tile karna, always some remainder) - For n \\(\\geq\\) 4, even n, \\(f[n] = 4 \\times f[n-2] - f[n-4]\\) - For odd n, <code>f[n]</code> = 0</p> <pre><code>int domino(int A){\n    const int MOD = 1e9 + 7;\n    vector&lt;int&gt; f(A+1,0);\n    if (A &gt;= 0) f[0] = 1;\n    if (A &gt;= 1) f[1] = 0;\n    if (A &gt;= 2) f[2] = 1;\n    if (A &gt;= 3) f[3] = 0;\n    for (int n = 4; n &lt;= A; ++n){\n        if (n &amp; 1) f[n] = 0;\n        else {\n            long long x = (4LL * f[n-2]) % MOD;\n            x = (x - f[n-4] + MOD) % MOD;\n            f[n] = (int)x;\n        }\n    }\n    return f[A];\n}\n</code></pre>"},{"location":"DSAyy/dp/#paint-house","title":"Paint House","text":"<p>N houses in a row, each can be painted with RGB.  Painting each house with a certain color has a given cost, represented by \\(n \\times 3\\) matrix A, where <code>A[i][j]</code> is the cost to paint the house <code>i</code> with cost <code>j</code>  (0 -&gt; red, 1-&gt; blue, 2-&gt; green). Paint such that - No two adjacent houses have the same color. - Minimize the total painting cost. Input \\(N\\times 3\\) matrix, output -&gt; min cost to paint all. Example: $$     A = \\begin{matrix} 1 &amp;&amp; 2  &amp;&amp; 3\\ 10 &amp;&amp; 11 &amp;&amp; 12 \\end{matrix} $$ Output: 12 Paint 0 with R, 1 with G: 1 + 11 = 12</p>"},{"location":"DSAyy/dp/#how-to-do-this-painting","title":"How to do this painting","text":"<p>Let <code>cost[i][c]</code> be the min cost to paint houses 0 to i with house i painted color c. But since each row only depends on the previous,, we can just use 2 arrays.</p> <p>$$ cost[i][0] = A[i][0] + min(cost[i-1][1], cost[i-1][2]) $$ $$ cost[i][1] = A[i][1] + min(cost[i-1][0], cost[i-1][2]) $$ $$ cost[i][2] = A[i][2] + min(cost[i-1][0], cost[i-1][1]) $$ Iss se simple dp ho nahi sakta Thoda simple karne ke liye let <code>prev_cost[c]</code> be cost of painting the previous house with color c. <code>prev_cost[c] = cost[i-1][c]</code></p> <pre><code>int minCost(vector&lt;vector&lt;int&gt;&gt; &amp;A){\n    int N = A.size();\n    if (N == 0) return 0;\n    long long prev_cost[3];\n    for (int c = 0; c &lt; 3; ++c) \n        prev_cost[c] = A[0][c];\n    for (int i = 1; i &lt; N; ++i){\n        long long cost[3];\n        cost[0] = A[i][0] + min(prev_cost[1], prev_cost[2]);\n        cost[1] = A[i][1] + min(prev_cost[0], prev_cost[2]);\n        cost[2] = A[i][2] + min(prev_cost[0], prev_cost[1]);\n        for (int c = 0; c &lt; 3; ++c) prev_cost[c] = cost[c];\n    }\n    long long ans = min({prev_cost[0], prev_cost[1], prev_cost[2]});\n    return (int)ans;\n}\n</code></pre>"},{"location":"DSAyy/dp/#ways-to-decode","title":"Ways to decode","text":"<p>Given an encoded string <code>A</code> consisting of digits. - 'A' = 1, 'B' = 2 ... 'Z' = 26 find the total number of ways of decoding A modulo \\(10^9 + 7\\).</p> <p>Input: String A, Output: total number of decoding ways.</p> <p>Example: - A = '8', Output = 1 (\"H\") - B = '12', Output = 2 (\"AB\", \"L\")</p>"},{"location":"DSAyy/dp/#karna-kaise-hai_2","title":"Karna kaise hai","text":"<p>Let <code>ways[i]</code> be number of ways to decode <code>A[0...i]</code> (first i characters)</p> <p>Toh iss ke rishte kuch aise honge: - If \\(A[0] = '0'\\), single digit is valid, add <code>ways[i-1]</code> - If <code>A[i-2,i-1]</code> form a valid 2 digit number between 10 and 26, add <code>ways[i-2]</code></p> <p>Base cases: - \\(ways[0] = 1\\) (empty string banane ka there is only one way) - \\(ways[1] = 1 \\text{ if A[0] } \\neq '0', \\text{ else 0}\\)</p> <pre><code>int numDecodings(string A){\n    int n = A.length();\n    const int MOD = 1e9 + 7;\n    if (n == 0) return 0;\n    vector&lt;int&gt; ways(n+1,0);\n    ways[0] = 1;\n    ways[1] = (A[0] != '0')? 1 : 0;\n    for (int i = 2; i &lt;= n; ++i){\n        char c1 = A[i-1], c0 = A[i-2];\n        if (c1 != '0')\n            ways[i] = (ways[i] + ways[i-1]) % MOD;\n        if (c0 == '1' || (c0 == '2' &amp;&amp; c1 &lt;= '6'))\n            ways[i] = (ways[i] + ways[i-2]) % MOD;\n    }\n    return ways[n];\n}\n</code></pre>"},{"location":"DSAyy/dp/#stairs","title":"Stairs","text":""},{"location":"DSAyy/dp/#legendary-beginner-problem","title":"Legendary beginner problem","text":"<p>You are climbing a staircase with A steps. You can climb either 1 or 2 steps; How many distinct ways can you reach the top?</p> <p>Input: A = 2, Output = 2 (<code>[1,1],[2]</code>)</p>"},{"location":"DSAyy/dp/#karna-kaise-hai_3","title":"Karna kaise hai","text":"<p>Let \\(waysToStep[n]\\) be the number of ways to reach step n</p> <p>$$     waysToStep[i] = waysToStep[i-1] + waysToStep[i-2] $$ Some facts: \\(waysToStep[0] = 1\\) (1 way to stay at the bottom) \\(waysToStep[1] = 1\\) (climb one step)</p> <pre><code>int climbStairs(int A){\n    if (A &lt;= 1) return 1;;\n    int prev = 1, curr = 2;\n    for (int i = 3; i &lt;= A; ++i) {\n        int next = prev + curr;\n        prev = curr;\n        curr = next;\n    }\n    return curr;\n}\n</code></pre>"},{"location":"DSAyy/dp/#longest-increasing-subsequence","title":"Longest Increasing Subsequence","text":""},{"location":"DSAyy/dp/#problem-kya-hai_2","title":"Problem kya hai","text":"<p>Given array of integers A, find the length of Longest Increasing Subsequence.</p> <p>Example: - <code>A = [1,2,1,5]</code> Output: 3 (LIS = <code>[1,2,5]</code> )</p>"},{"location":"DSAyy/dp/#karna-kaise-hai_4","title":"Karna kaise hai","text":"<p>BINARY SEARCH BITCH - Maintain a list <code>tail</code> where <code>tail[i]</code> is the smallest possible tail value of an increasing subsequence of length <code>i+1</code> - <code>tail[i]</code> is the smallest possible value that can end a increasing subsequence of length <code>i+1</code>  - For each x in A:     - Use lower_bound to find the first element in tail \\(\\geq\\) x.     - If none, append x (increase the LIS length)     - Otherwise, replace it. (keep tail as small as possible for future extensions)         - the older value was bigger than x, and it wouldn't be a valid increasing subsequence ending at <code>i</code> so we replace the bigger value withh this new pookie. Length of the tail at the end is the ans</p> <pre><code>int lis(vector&lt;int&gt; &amp;A){\n    vector&lt;int&gt; tail;\n    for (int x : A){\n        auto it = lower_bound(tail.begin(),tail.end(), x);\n        // find first el &gt;= x\n        if (it == tail.end())\n            tail.push_back(x);\n        else \n            *it = x;\n    }\n    return tails.size();\n}\n</code></pre>"},{"location":"DSAyy/dp/#intersecting-chords-in-a-circle","title":"Intersecting chords in a circle","text":"<p>Given an integer \\(A\\) return the number of ways to draw A chords in a circle with \\(2A\\) points, such that no two chords intersect. Two ways are different if atleast one chord is present in one way but not the other. Return modulo \\(10^9 + 7\\)</p> <p>Example: - A = 1, Output = 1 - A = 2, Output = 2</p>"},{"location":"DSAyy/dp/#how-tho","title":"How tho","text":"<p>The number of ways to draw A non-intersecting chords on 2A points on a circle is the A-th Catalan number. $$ C_0 = 1, \\space \\space C_n = \\sum_{i=0}^{n-1} C_i \\times C_{n-1 - i} $$ where \\(C_n\\) is the number of valid chord drawings with n chords.</p> <pre><code>int chordCut(int A){\n    const int MOD = 1e9 + 7;\n    vector&lt;long long&gt; C(A+1, 0);\n    C[0] = 1;\n    for (int n = 1; n &lt;= A; ++n){\n        long long ways = 0;\n        for (int i = 0; i &lt; n; ++i){\n            ways = (ways + C[i] * C[n-1-i]) % MOD;\n        }\n        C[n] = ways;\n    }\n    return (int)C[A];\n}\n</code></pre>"},{"location":"DSAyy/dp/#birthday-bombs","title":"Birthday Bombs","text":""},{"location":"DSAyy/dp/#problem","title":"Problem","text":"<p>Tengu has N friends. Each friend \\(i\\) has a positive strength \\(B[i]\\) and can kick tengu any number of times. Tengu has pain resistance limit A. Find lexicographically smallest array of max pos length of friend indices, where each friend index can appear any number of times, such that their sum of strengths is \\(\\leq\\) A.</p>"},{"location":"DSAyy/dp/#how_1","title":"How","text":"<ul> <li>Max num of kicks: \\(M = \\frac{A}{w_{min}}\\)   where \\(w_{min}\\) is the min val in B.</li> <li>At each kick pos, to keep ans smallest, try each friend in asc order and pick the lowest index friend whose cost allows enough resistance for remaining M-1 kicks, all possibly using the cheapest friend.</li> <li>After choosing, subtract from capacity and continue.</li> </ul> <pre><code>vector&lt;int&gt; smallKicks(int A, vector&lt;int&gt;&amp; B){\n    int N = B.size();\n    int w_min = *min_element(B.begin(),B.end());\n    int M = A/w_min;\n    if (M == 0) return {};\n    vector&lt;int&gt; ans;\n    long long cap = A; // remaining capacity\n    for (int pos = 0; pos &lt; M; ++pos){\n        int rem = M - pos - 1;\n        for (int i = 0; i &lt; N; ++i){\n            long long cost_i = B[i];\n            long long needed_for_rest = 1LL* rem * w_min;\n            if (cost_i + needed_for_rest &lt;= cap){\n                ans.push_back(i);\n                cap -= cost_i;\n                break;\n            }   \n        }\n    }\n    return ans;\n}\n</code></pre>"},{"location":"DSAyy/dp/#jump-game-array","title":"Jump Game Array","text":""},{"location":"DSAyy/dp/#problem_1","title":"Problem","text":"<p>Given array A with non-neg int, you are at index 0. Each element <code>A[i]</code> is the max jump len from pos i. Determine if you can reach the last index.</p> <p>Example - \\(A = [2,3,1,1,4]\\) , Output = 1 - \\(A = [3,2,1,0,4]\\) , Output = 0</p>"},{"location":"DSAyy/dp/#how_2","title":"How:","text":"<p>Keep track of <code>maxReach</code> index, like the farthest we can reach - for each index i, if i &gt; maxReach, we are stuck, return 0 - warna update maxReach and move on</p> <pre><code>int canJump(vector&lt;int&gt; &amp;A){\n    int n = A.size();\n    long long maxReach = 0;\n    for (int i = 0; i &lt; n; ++i){\n        if (i &gt; maxReach) return 0;\n        maxReach = max(maxReach, (long long i) + A[i]);\n        if (maxReach &gt;= n-1) return 1;\n    }\n    return 1;\n}\n</code></pre>"},{"location":"DSAyy/dp/#min-jumps-array","title":"Min Jumps Array","text":""},{"location":"DSAyy/dp/#problem_2","title":"Problem","text":"<p>Given array A with non-neg int, you are at index 0. Each <code>A[i]</code> represents the max jump length from that pos. Return the min number of jumps required to reach the last index. If not pos, return -1.</p>"},{"location":"DSAyy/dp/#how_3","title":"How","text":"<p>Use a greedy BFS - <code>current_end</code> : the farthest index we can reach with current jumps - <code>furthest</code> : farthest we can reach with one more jump - for every i in \\([0,current\\_end]\\) , update furthest to the farthest you can go. - when i reaches current_end, increment jump count, and extend curr_end to furthest. - if current_end cannot be extended, return -1 <pre><code>int jump(vector&lt;int&gt; $A){\n    int n = A.size();\n    if (n &lt;= 1) return 0;\n    if (A[0] == 0) return -1;\n    int jumps = 0, current_end = 0, furthest = 0;\n    for (int i = 0; i+1 &lt; n; ++i){\n        furthest = max(furthest, i + A[i]);\n        if (i == current_end){\n            jumps++;\n            current_end = furthest;\n            if (current_end &gt;= n-1) return jumps;\n            if (current_end == i) return -1;\n        }\n    }\n    return (current_end &gt;= n -1)? jumps : -1;\n}\n</code></pre></p>"},{"location":"DSAyy/dp/#longest-arithmetic-progression","title":"Longest Arithmetic Progression","text":""},{"location":"DSAyy/dp/#problem-statement-ass","title":"Problem statement (ass)","text":"<p>Given int arr A of size N, find len of longest AP in A. AP is a seq where consec elements ka diff is same.</p> <p>Example: - <code>A = [3,6,9,12]</code> Output: 4 - <code>A = [9,4,7,2,10]</code> Output: 3 (4,7,10)</p>"},{"location":"DSAyy/dp/#kya-kyu-kaise","title":"Kya Kyu Kaise","text":"<ul> <li>Let <code>ap[i][j]</code> be the len of longest AP ending at i,j</li> <li>For each j &gt; i, try to find a pehle ka index <code>k</code> such that <code>A[k]</code> , <code>A[i]</code>, <code>A[j]</code> form an AP.</li> <li>Agar waise kuch exists, se<code>ap[i][j]</code> = <code>ap[k][i] + 1</code> (matlab AP goes on), warna <code>ap[i][j] = 2</code> (atleast 2 number toh hai ye dono bhai)</li> <li>Use hashmap for finding last occurence</li> </ul> <pre><code>int longestAP(vector&lt;int&gt; &amp;A){\n    int n = A.size();\n    if (n &lt;= 2) return n;\n    map&lt;int,int&gt; occ;\n    vector&lt;vector&lt;int&gt;&gt; ap(n+1, vector&lt;int&gt;(n+1,0));\n    for (int i = 0; i &lt; n; ++i){\n        for (int j = i+1; j &lt; n; ++j){\n            int x = 2*A[i] - A[j]; // aise we find prev element\n            if (occ.find(x) != occ.end()){\n                // ap ki legacy goes on\n                ap[i][j] = max(ap[i][j], 1 + ap[mp[x]][i]);\n            }\n            else {\n                ap[i][j] = 2;\n            }\n            ans = max(ans,ap[i][j]);\n        }\n        mp[A[i]] = i;\n    }\n    return ans;\n}\n</code></pre>"},{"location":"DSAyy/dp/#n-digit-numbers-with-digit-sum-s","title":"N digit numbers with digit sum S","text":""},{"location":"DSAyy/dp/#problem-statement_3","title":"Problem Statement","text":"<p>Given 2 integers N and S, find out the num of N-digit numbers whose digit sum to S.  Note valid num dont have leading zeroes. Return ans \\(modulo \\space 10^9 + 7\\)</p> <p>Example: N = 2, S = 4, Output = 4 (numbers = 13,22,31,40)</p>"},{"location":"DSAyy/dp/#kaise","title":"Kaise?","text":"<p>Let \\(dp[sum]\\) be the num of ways to get sum <code>sum</code> with a fixed number of digits so far. First digit ke liye we can only put 1-9. Uske aage we can put 0-9 For each pos, update all possible digit sum using the prev position ka possibilities.</p> <pre><code>int digitSum(int N, int S){\n    const int MOD = 1e9 + 7;\n    vector&lt;int&gt; dp(S+1,0), next_dp(S+1,0);\n    // first digit wala base case\n    for (int d=  1; d &lt;= 9; ++d) \n        if (d &lt;= S) dp[d] = 1;\n    for (int pos = 2; pos &lt;= N; ++pos){\n        fill(next_dp.begin(),next_dp.end(), 0);\n        for (int sum = 0; sum &lt;= S; ++sum){\n            if (dp[sum] == 0) continue; // we have nothing to add\n            for (int d = 0; d &lt;= 9; ++d){\n                if (sum + d &gt; S) break;\n                // jitne bhi next sum possible hai, sab ke ways add karde\n                next_dp[sum + d] = (next_dp[sum + d] + dp[sum]) % MOD; \n            }\n        }\n        // calculations update kar de\n        dp.swap(next_dp);\n    }\n    return dp[S];\n}\n</code></pre>"},{"location":"DSAyy/dp/#shortest-common-superstring","title":"Shortest Common Superstring","text":""},{"location":"DSAyy/dp/#problem-kya-yap-kar-raha_1","title":"Problem kya yap kar raha","text":"<p>Given a set of strings A of len N, return len of shortest string that contains all string in A as substrings.</p> <p>Example: - \\(A = ['aaaa', 'aa'],\\space  Output = 4\\)  (superstring : \"aaaa\") - <code>A = [abcd,cdef,fgh,de]</code> Output: 8 (superstring : \"abcdefgh\")</p>"},{"location":"DSAyy/dp/#how-the-fuck","title":"How the fuck","text":"<p>Pehle toh remove any string that is a substring of another For all pairs <code>i,j</code> precompute maximum suffix-prefix ka overlap between <code>A[i]</code> and <code>A[j]</code>. Ab let <code>dp[mask][last]</code> be the min len superstring for set of strings mask, ending at string <code>last</code>. Transition: For every mask, for every mask, try adding any <code>nxt</code> not in the mask The cost to add <code>A[nxt]</code> after <code>A[last]</code> is  $$ |A[nxt]| - overlap[last][nxt] $$ Matlab length of <code>A[nxt]</code> - overlap between <code>A[last]</code> and <code>A[nxt]</code> Then the answer would be min of <code>dp[all-used][last]</code></p> <p>Iska code thoda heavy hai <pre><code>int computeOverlap(string a, string b){\n    int maxLen = min(a.size(),b.size());\n    for (int k = maxLen, k &gt; 0; --k){\n        if (a.substr(a.size()-k,k) == b.substr(0,k)){\n            return k;\n            // agar a ke last k matches b ke first k, toh its better to join them\n        }\n    }\n}\n\nint minComSups(vector&lt;string&gt; &amp;A){\n    int n = A.size();\n    if (n == 0) return 0;\n    // remove substrings coz time na waste kar yaar\n    vector&lt;bool&gt; keep(n,true);\n    for (int i = 0; i &lt; n; ++i){\n        if (!keep[i]) continue;\n        for (int j = 0; j &lt; n; ++j){\n            if (i == j || !keep[j]) continue;\n            if (A[i].find(A[j]) != string::npos)\n                keep[j] = 0;\n            else if (A[j].find(A[i]) != string::npos){\n                keep[i] = false;\n                break;\n            }\n        }\n    }\n    vector&lt;string&gt; strs;\n    for (int i = 0; i &lt; n; ++i) if (keep[i]) strs.push_back(A[i]);\n    A.swap(strs); // cleaned A by removing faaltu ke subtrs\n    // precompute overlap\n    vector&lt;vector&lt;int&gt;&gt; overlap(n, vector&lt;int&gt;(n,0));\n    for (int i = 0; i &lt; n; ++i){\n        for (int j = 0; j &lt; n; ++j){\n            if (i == j) continue;\n            overlap[i][j] = computeOverlap(A[i],A[j]);\n        }\n    }\n    // ab finally dp\n    int FULL = 1 &lt;&lt; n, INF = 1e9;\n    vector&lt;vector&lt;int&gt;&gt; dp(FULL, vector&lt;int&gt;(n,INF));\n    // min com supstr of A[i] ending at i is A[i] bhai duh\n    for (int i = 0; i &lt; n; ++i) dp[i &lt;&lt; i][i] = A[i].length();\n\n    for (int mask = 0; mask &lt; FULL; ++mask){\n        for (int last = 0; last &lt; n; ++last){\n            if (!(mask &amp; (1 &lt;&lt; last))) continue;\n            // agar last pehle compute kar rakha then continue\n            int curLen = dp[mask][last];\n            if (curLen == INF) continue; // not computed, abhi bhi default value hai\n            int rem = (~mask) &amp; (FULL - 1);\n            for (int nxt = 0; nxt &lt; n; ++nxt){\n                if (!(rem &amp; (1 &lt;&lt; nxt))) continue; // nxt already in mask\n                int add = (int)A[nxt].size() - overlap[last][nxt];\n                int newMask = mask | (1 &lt;&lt; nxt);\n                dp[newMask][nxt] = min(dp[newMask][nxt],curLen + add);\n            }\n        }\n    }\n    int ans = INF, finalMask = FULL - 1;\n    for (int last = 0; last &lt; n; ++last)\n        ans = min(ans, dp[finalMask][last]);\n    return ansl\n}\n</code></pre></p>"},{"location":"DSAyy/dp/#ways-to-color-a-3-x-n-board","title":"Ways to color a 3 x N Board.","text":""},{"location":"DSAyy/dp/#problem_3","title":"Problem","text":"<p>Given 3xA board, find ways to color it using atmost 4 colors such that no two baaju wala cells have the same color. Return ans modulo \\(10^9 + 7\\)</p> <p>Example:  - A = 1, ans = 36 - A = 2, ans = 588</p>"},{"location":"DSAyy/dp/#how-the-fuck_1","title":"How the fuck","text":"<p>DP with State Compression Each column can be colored in \\(4 \\times 3 \\times 3 = 36\\) ways. Choose colors for top, middle, and bottom. All different from adjacent vertically. Let <code>patterns[i]</code> mean i-th valid color pattern for a column. Let <code>compatList[i]</code> as the set of prev column patterns compatible with i (no color repeats in any row) Let <code>dp[i]</code> be the number of ways so far if the rightmost column uses the pattern i. So the transition would be: $$ nextDP[i] = \\sum_{j \\in compatList[i]} dp[j] $$ So pehle, Gemerate all 36 valid column colorings  Now for each pattern, build a list of compatible previous patterns Then bas ways add karde of all that are compatible</p> <pre><code>const int MOD = 1e9 + 7;\nvector&lt;array&lt;int,3&gt;&gt; buildAllPatterns(){\n    vector&lt;array&lt;int,3&gt;&gt; patterns;\n    for (int c0 = 0; c0 &lt; 4; ++c0){\n        for (int c1 = 0; c1 &lt; 4: ++c1){\n            if (c1 == c0) continue; // valid nahi hai\n            for (int c2 = 0; c2 &lt; 4: ++c2){\n                if (c2 == c1) continue;\n                patterns.push_back({c0,c1,c2});\n            }\n        }\n    }\n}\n\nvector&lt;vector&lt;int&gt;&gt; buildCompat(vector&lt;array&lt;int,3&gt;&gt; &amp;patterns){\n    int M = patterns.size();\n    vector&lt;vector&lt;int&gt;&gt; compatList(M);\n    for (int i = 0; i &lt; M; ++i){\n        for (int j = 0; j &lt; M; ++j){\n            bool ok = 1;\n            for (int r = 0; r &lt; 3; ++r){\n                //check the rows incase adj nikale toh not okk\n                if (patterns[i][c] == patterns[j][c]){\n                    ok = 0;\n                    break;\n                }\n            }\n            if (ok) compatList[i].push_back(j);\n        }\n    }\n    return compatList;\n}\n\nint color(int A){\n    int N = A:\n    if (N &lt;= 0) return 0;\n    vector&lt;array&lt;int,3&gt;&gt; patterns = buildAllTriples();\n    vector&lt;vector&lt;int&gt;&gt; compatList = buildCompat(patterns);\n    // ways of coloring i columns is dp[i]\n    vector&lt;int&gt; dp(36,1), next_dp(36,0);\n    for (int col = 2; col &lt;= N; ++col){\n        for (int i = 0; i &lt; 36; ++i) nextDP[i] = 0;\n        for (int i = 0; i &lt; 36; ++i){\n            long long sumWays = 0;\n            for (int j : compatList[i]){\n                sumWays += dp[j];\n                if (sumWays &gt;= MOD) sumWays -= MOD;\n            }\n            nextDP[i] = (int)sumWays;\n        }\n        dp.swap(nextDP);\n    }\n    long long answer = 0;\n    for (int i = 0; i &lt; 36; ++i){\n        answer += dp[i];\n        if (answer &gt;= MOD) answer -= MOD;\n    }\n    return (int)answer;\n}\n</code></pre>"},{"location":"DSAyy/dp/#kth-manhattan-distance-neighbourhood","title":"Kth Manhattan Distance Neighbourhood","text":""},{"location":"DSAyy/dp/#what-does-the-problem-say","title":"What does the problem say...","text":"<p>Given a Matrix \\(n \\times m\\) and int K, for every el <code>M[i][j]</code>, find the max el in K-Manhattan distance neighborhood.</p> <p>$$ \\text{For each  (i,j), compute }  max{M[p][q] \\space | \\space |i-p| + |j-q| \\leq K }</p> <p>$$ Example:  - M = \\(\\begin{bmatrix} 1 &amp; 2 &amp; 4 \\\\ 4 &amp; 5 &amp; 8 \\end{bmatrix}\\) , K = 2, The output would be \\(\\begin{bmatrix} 5 &amp; 8 &amp; 8 \\\\ 8 &amp; 8 &amp; 8 \\end{bmatrix}\\) </p>"},{"location":"DSAyy/dp/#how-to-look-at-neighbors","title":"How to look at neighbors?","text":"<p>We use K rounds of DP. At each round d, for every cell (i,j), we compute the max amongst itself and 4 neighbors {up down left right} from the previous round. This way after K rounds, we would have max val within manhattan distance K.</p> <pre><code>vector&lt;vector&lt;int&gt;&gt; KMan(int A, vector&lt;vector&lt;int&gt;&gt; &amp;B){\n    int n = B.size();\n    if (n == 0) return {};\n    int m = B[0].size(), K = A;\n    vector&lt;vector&lt;int&gt;&gt; dp_prev(n, vector&lt;int&gt;(m)), curr(n, vector&lt;int&gt;(m));\n    // prev would have the max comparisons from the last round\n    for (int i = 0; i &lt; n; ++i) \n        for (int j = 0; j &lt; m; ++j) dp_prev[i][j] = B[i][j];\n    const int dir[4][2] = {{-1,0}, {1,0}, {0,-1}, {0,1}};\n    for (int d = 1; d &lt;= K; ++d){\n        for (int i = 0; i &lt; n; ++i) {   \n            for (int j = 0; j &lt; m; ++j){\n                int best = dp_prev[i][j];\n                for (auto [x,y] : dir){\n                    int ni = i + x, nj = j + y;\n                    if (ni &gt;= 0 &amp;&amp; ni &lt; n &amp;&amp; nj &gt;= 0 &amp;&amp; nj &lt; m)\n                        best = max(best, dp_prev[ni][nj]);\n                }\n                dp_curr[i][j] = best;\n            }\n        }\n        dp_prev.swap(dp_curr);\n    }\n    return dp_prev;\n}\n</code></pre>"},{"location":"DSAyy/dp/#best-time-to-buy-and-sell-stocks-at-most-b-times","title":"Best time to buy and sell stocks at most B times.","text":""},{"location":"DSAyy/dp/#problem-statement_4","title":"Problem statement","text":"<p>Given an array A of size N, where <code>A[i]</code> is the price of the stock on day i, and an integer B, find the maximum profit possible with atmost B transactions.  A transaction consists of buying and selling stocks.</p> <p>Example: - \\(A[i] = [2,4,1]\\)  B = 2 =&gt; Output = 2</p>"},{"location":"DSAyy/dp/#how_4","title":"How","text":"<p>If \\(B \\geq N/2\\) , you can trade kitna bhi. So the ans is just the sum of all the upward movements. If \\(B &lt; N/2\\) , USE DP.      Let \\(dp[k][i]\\) be the max profit with at index i with atmost k transactions.     $$     dp[k][i] = max(dp[k][i], A[i] + max_{j &lt; i}(dp[k-1][j] - A[j]))     $$     But instead of looping purra, we can just maintain the best price.     $$     bestPrice = max(dp[k-1][j] - A[j])      $$     Maintain this as we move ahead with i.</p> <pre><code>int BuySellB(vector&lt;int&gt; &amp;A, int B){\n    int N = A.size();\n    if (N &lt; 2 || B == 0) return 0;\n    if (B &gt;= N/2){\n        // as many transactions as we want\n        int profit = 0;\n        for (int i = 1; i &lt; N; ++i)\n            if (A[i] &gt; A[i-1]) \n                profit += A[i] - A[i-1];\n        return profit;\n    }\n    // otherwise we use normal dp\n    vector&lt;vector&lt;int&gt;&gt; dp(B+1, vector&lt;int&gt;(N,0));\n    for (int k = 1; k &lt;= B; ++k){\n        int bestPrev = dp[k-1][0] - A[0];\n        for (int i = 1; i &lt; N; ++i){\n            dp[k][i] = max(dp[k][i-1], A[i] + bestPrev);\n            bestPrev = max(bestPrev, dp[k-1][i] - A[i]);\n        }\n    }\n    return dp[B][N-1];\n}\n</code></pre>"},{"location":"DSAyy/dp/#coins-in-a-line","title":"Coins in a Line","text":""},{"location":"DSAyy/dp/#problem_4","title":"Problem","text":"<p>Array A of coins in a line (len n is even). Two players take turns picking either leftmost or the rightmost coin. Each want to maximise their total. Assume you go first. Return max money you can win.</p> <p>Example - \\(A = [1,2,3,4]\\) =&gt; Output = 6 - \\(A = [5,4,8,10]\\) =&gt; Output = 15</p>"},{"location":"DSAyy/dp/#explanation","title":"Explanation","text":"<p>Let \\(dp[i][j]\\) be the max money you can get from \\(A[i...j]\\) if its your turn. - If you pick \\(A[i]\\), your opponent faces \\(A[i+1...j]\\) and will min your future gain     - You get \\(A[i] + min(dp[i+2][j],dp[i+1][j-1] )\\)  - If you pick \\(A[j]\\) , you get \\(A[j] + min(dp[i][j-2], dp[i+1][j-1])\\)  - Take max of both</p> <pre><code>int maxCoin(vector&lt;int&gt; &amp;A){\n    int n = A.size();\n    if (n == 0) return 0;\n    vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 0));\n    for (int i = 0; i &lt; n; ++i) dp[i][i] = A[i];\n    for (int i = 0; i +1 &lt; n; ++i) dp[i][i+1] = max(A[i],A[i+1]);\n\n    for (int len = 3; len &lt;= n; ++len){\n        for (int i = 0; i + len &lt; n; ++i){\n            int j = i + len - 1;\n            int pickLeft = A[i] + min(\n                (i+2 &lt;= j ? dp[i+2][j] : 0),\n                (i + 1 &lt;= j-1 ? dp[i+1][j-1] : 0);\n            );\n            int pickRight = A[i] + min(\n                (i &lt;= j-2 ? dp[i][j-2] : 0),\n                (i+1 &lt;= j-1 ? dp[i+1][j-1] : 0)\n            );\n            dp[i][j] = max(pickLeft, pickRight);\n        }\n    }\n    return dp[0][n-1];\n}\n</code></pre>"},{"location":"DSAyy/dp/#evaluate-expression-to-true","title":"Evaluate Expression To True","text":""},{"location":"DSAyy/dp/#problem_5","title":"Problem","text":"<p>Boolean expression de rakha, count ways to parenthesize A such that it evaluates to true. Return ans modulo 1003. Example: - A = \"T|F\" =&gt; 1 - A = \"T^TF\" =&gt; 0</p>"},{"location":"DSAyy/dp/#how_5","title":"How","text":"<p>Let n be len of A. There are (n+1)/2 operands (at even pos). Let <code>dp_t[i][j]</code> be the number of ways to evaluate operands i to j to true. Let <code>dp_f[i][j]</code> be the number of ways to eval operands i to j to false. - Part at k: <code>[i..k]</code> and <code>[k+1..j]</code>, operator <code>A[2k + 1]</code> - For each operator, count ways to get T/F by comb results from L and R subprobs.</p> <pre><code>int cntTrue(string A){\n    const int MOD = 1003;\n    int n = A.size();\n    int m = (n+1)/2;\n    vector&lt;vector&lt;int&gt;&gt; dp_t(m, vector&lt;int&gt; (m,0));\n    vector&lt;vector&lt;int&gt;&gt; dp_f(m, vector&lt;int&gt; (m,0));\n    // initialize single characters\n    for (int k = 0; k &lt; m; ++k){\n        char c = A[2*k]; // every operand is at even index\n        if (c == 'T') dp_t[k][k] = 1;\n        else dp_f[k][k] = 1;\n    } \n    // fill dp for substr of increasing len\n    for (int len = 2; len &lt;= m; ++len){\n        for (int i = 0; i &lt; len -1 &lt; m; ++i){\n            int j = i + len - 1;\n            int waysT = 0, waysF= 0;\n            for (int k = i; k &lt; j; ++k){\n                char op = A[2*k + 1]; //operator between the operands\n                int lt = dp_t[i][k], lf = dp_f[i][k];\n                int rt = dp_t[k+1][j], rf = dp_f[k+1][j];\n                int totL = (lt + rt) % MOD;\n                int totR = (rt +rf) % MOD;\n                if (op == '&amp;'){\n                    waysT += lt*rt;\n                    waysF += totL*totR - lt*rt;\n                }\n                else if (op == '|'){\n                    waysF += lf * rf;\n                    waysT += totL*totR - lt*rt;\n                }\n                else if (op == '^'){\n                    waysT += lt*rf + lf*rt;\n                    waysF += lt*rt + lf*rf;\n                }\n            }\n            dp_t[i][j] = waysT;\n            dp_f[i][j] = waysF;\n        }\n    }\n    return dp_t[0][m-1];\n}\n</code></pre>"},{"location":"DSAyy/dp/#egg-drop-problem","title":"Egg Drop Problem","text":""},{"location":"DSAyy/dp/#problem-toh-zindagi-meh-hai","title":"Problem toh zindagi meh hai","text":"<p>Given A Eggs, and building with B floors. Find min moves reqd to find the critical floor C (such that any egg dropped above C would break, and at or below C would not). Each move, you may drop egg from any floor. An egg that breaks cannot be used again.</p> <p>Input : 2 integers, A and B. Example: - A = 1, B = 2, output = 2 - A = 2, B = 10, output = 4</p>"},{"location":"DSAyy/dp/#_1","title":"????","text":"<p>Let <code>dp[k]</code> be max num of floors you can test k eggs and m moves. $$ dp[k] = 1 + dp[k] + dp[k-1] $$ Drop an egg - If it breaks, you have <code>k-1</code> eggs, <code>m-1</code> moves left. (<code>dp[k-1]</code>) - if it doesn't, you have k eggs and m-1 moves left. <code>dp[k]</code> floors +1 for current floor being tested.</p> <pre><code>int eggDrop(int A, int B){\n    vector&lt;int&gt; dp(A+1,0); // dp[k] = max floor with k eggs\n    int moves = 0;\n    while (dp[A] &lt; B){ // we have to test atleast all the floors to be certain\n        moves ++;\n        for (int k = A; k &gt;= 1; --k)\n            dp[k] += dp[k-1] + 1;\n    }\n    return moves;\n}\n</code></pre>"},{"location":"DSAyy/dp/#best-time-to-buy-and-sell-stocks-3","title":"Best time to buy and sell stocks 3","text":"<p><code>A[i]</code> is the price of stock on day <code>i</code>. Find the max possible profit by making atmost 2 interactions. You must sell before you buy again.</p> <p>Example - \\(A = [1,2,1,2]\\) Output is 2 - \\(A = [7,2,4,8,7]\\) Output is 6</p>"},{"location":"DSAyy/dp/#kaise_1","title":"Kaise","text":"<ul> <li>Let <code>firstBuy</code> be max profit after first buy (-ve )</li> <li>let <code>firstSell</code> be the max profit after first sell.</li> <li>let <code>secondBuy</code> be max prof after second buy (= profit after first sell - price)</li> <li>let <code>secondSell</code> max prof after second sell. On each day we update thse</li> </ul> <pre><code>int buySell3(vector&lt;int&gt;&amp; A){\n    int n = A.size();\n    if (n &lt; 2) return 0;\n    int firstBuy = INT_MIN, secondBuy = INT_MIN;\n    int firstSell = 0, secondSell = 0;\n    for (int price : A){\n        firstBuy = max(firstBuy, -price);\n        firstSell = max(firstSell, firstBuy + price);\n        secondBuy = max(secondBuy, firstSell - price);\n        secondSell = max(secondSell,secondBuy + price);\n    }\n    return secondSell;\n}\n</code></pre>"},{"location":"DSAyy/dp/#longest-valid-parentheses","title":"Longest Valid Parentheses","text":""},{"location":"DSAyy/dp/#problem-statement_5","title":"Problem Statement","text":"<p>Given a string A, having bracket sequence, find the len of longest valid bracket substring.</p> <p>Example - A = \"(()\" -&gt; 2 - A = \")()())\" -&gt; 4</p>"},{"location":"DSAyy/dp/#how_6","title":"How","text":"<p>Let <code>dp[i]</code> be the len of longest val substring ending at i If <code>A[i]</code> = ), then     <code>A[i-1]</code> = (: tab \\(dp[i] = 2 + dp[i-2]\\) <code>A[i-1]</code> = ): tab try to match with pehle ka (. if <code>A[i]</code> = (: <code>dp[i]</code> = 0</p> <pre><code>int longValBra(string A){\n    int A = A.size();\n    if (n &lt; 2) return 0;\n    vector&lt;int&gt; dp(n,0);\n    int ans = 0;\n    for (int i = 1; i &lt; n; ++i){\n        if (A[i] == ')'){\n            if (A[i-1] == '(')\n                dp[i] = 2 + (i &gt;= 2? dp[i-2] : 0);\n            else {\n                int prevLen = dp[i-1];\n                int openIndex = i - prevLen - 1;\n                if (openIndex &gt;= 0 &amp;&amp; A[openIndex] == '('){\n                    dp[i] = prevLen + 2;\n                    if (openIndex &gt;= 1){\n                        dp[i] += dp[openIndex - 1];\n                    }\n                }\n            }\n            ans = max(ans,dp[i]);\n        }\n    }\n    return ans;\n}\n</code></pre>"},{"location":"DSAyy/dp/#max-edge-queries","title":"Max Edge Queries","text":""},{"location":"DSAyy/dp/#problem_6","title":"Problem","text":"<p>Given a tree with N nodes, and N-1 edges with weight. Answer Q queries in the form of (u,v). For each query, return the maximum weight of any edge on the simple path from U to V Input: Array A of \\(N-1 \\times 3\\) dimension. Contains \\([u,v,w]\\)  B = \\(Q \\times 2\\) array, containing queries \\([u,v]\\)</p>"},{"location":"DSAyy/dp/#how_7","title":"How","text":"<p>This is the classic Lowest Common Ancestor query with path maximum edge using binary lifting.</p> <p>For each node v, and for each \\(2^k\\) th ancestor of v:     \\(up[k][v]\\) : \\(2^k\\) th ancestor of v     \\(maxEdgeUp[k][v]\\) : max edge wt from v up to its \\(2^k\\) ancestor To answer a query (u,v):     Lift u and v to the same height, tracking maxEdge     if \\(u \\neq v\\) , keep lifting until their parents match (to make a path)     Compare max edges on both path</p> <pre><code>const int MAXN = 100000, LOGN = 17;\nvector&lt;pair&lt;int,int&gt;&gt; adj[MAXN + 1];\nint up[LOGN+1][MAXN+1];\nint maxEdgeUp[LOGN+1][MAXN+1];\nint depth[MAXN+1];\n\nint lca_maxEdge(int u, int v){\n    int ans = 0;\n    if (depth[u] &lt; depth[v]) swap(u,v);\n    int diff = depth[u] - depth[v];\n    for (int k = 0; k &lt;= LOGN; ++k){\n        if (diff &amp; (1 &lt;&lt; k)){\n            ans = max(ans, maxEdgeUp[k][u]);\n            u = up[k][u];\n        }\n    }\n    if (u == v) return ans;\n    for (int k = LOGN; k &gt;= 0; --k){\n        if (up[k][u] != 0 &amp;&amp; up[k][u] != up[k][v]){\n            ans = max(ans, maxEdgeUp[k][u]);\n            ans = max(ans, maxEdgeUp[k][v]);\n            u = up[k][u];\n            v = up[k][v];\n        }\n    }\n    ans = max(ans,maxEdgeUp[0][u]);\n    ans = max(ans,maxEdgeUp[0][v]);\n    return ans;\n}\n\nvector&lt;int&gt; mxEdgeQueries(vector&lt;vector&lt;int&gt;&gt; &amp;A, vector&lt;vector&lt;int&gt;&gt; &amp;B){\n    int N = A.size() + 1;\n    for (int i = 1; i &lt;= N; ++i) adj[i].clear();\n    for (&amp;e : A){\n        auto [u,v,w] = e;\n        adj[u].push_back({v,w});\n        adj[v].push_back({u,w});\n    }\n    function&lt;void(int,int,int,int)&gt; dfs = [&amp;](int u, int p, int w, int ht){\n        depth[u] = ht;\n        up[0][u] = p;\n        maxEdgeUp[0][u] = w;\n        for (auto [v,wt] : adj[u]){\n            if (v == p) continue;\n            dfs(v,u,wt,ht+1);\n        }\n    };\n    dfs(1,0,0,0);\n    for (int k = 1; k &lt;= LOGN; ++k){\n        for (int v = 1; v &lt;= N; ++V){\n            int mid = up[k-1][v];\n            up[k][v] = up[k-1][mid];\n            maxEdgeUp[k][v] = max(maxEdgeUp[k-1][v], maxEdgeUp[k-1][mid]);\n        }\n    }\n    vector&lt;int&gt; ans;\n    for (auto [u,v] : B)\n        ans.push_back(lca_maxEdge(u,v));\n    return ans;\n}\n</code></pre>"},{"location":"DSAyy/dp/#max-sum-path-in-a-binary-tree","title":"Max Sum Path in a binary tree","text":""},{"location":"DSAyy/dp/#problem-statement_6","title":"Problem statement","text":"<p>Given a bin tree, find max path sum. A path can start and end at any node, and must be continuous. Inp: root ptr, output: Integer</p>"},{"location":"DSAyy/dp/#how_8","title":"How","text":"<p>For each node: best path is current node + max gain from left + max gain from right for parent, you only only pass along either left or right (not both)</p> <p>Approach: DFS keeping a global max at each node:     compute left and right gain     update global max : node-&gt;val + leftGain + rightGain     return to parent : node-&gt;val + max(leftGain, rightGain)</p> <pre><code>static int globalMax;\nint dfsMaxGain(TreeNode* node){\n    int (!node) return 0;\n    int leftGain = max(0,dfsMaxGain(node-&gt;left));\n    int rightGain = max(0,dfsMaxGain(node-&gt;right));\n    int currentSum = node -&gt;val + leftGain + rightGain;\n    globalMax = max(globalMax, currentSum);\n    return node-&gt;val + max(leftGain, rightGain);\n}\nint solve(TreeNode*A){\n    globalMax = INT_MIN;\n    dfsMaxGain(A);\n    return globalMax;\n}\n</code></pre>"},{"location":"DSAyy/dp/#kingdom-war","title":"Kingdom War","text":""},{"location":"DSAyy/dp/#problem_7","title":"Problem","text":"<p>Given \\(N \\times M\\) grid A const of strength (can be -ve) of a village. Grid is non-decreasing both row-wise and col-wise, find max sum of any rectangular submatrix.</p> <p>Input: <pre><code>3 3\n-5 -4 -1\n-3  2  4\n 2  5  8\n</code></pre> Output -&gt; 19</p>"},{"location":"DSAyy/dp/#how_9","title":"How","text":"<p>Since each cell is \\(\\geq\\) cells above and left, the largest sum always would be from top left (i,j) and bottom-right (N,M) So just 2d prefix sum $$ sum = S_{N,M} - S_{i-1,M} - S_{N,j-1} + S_{i-1, j-1} $$ <pre><code>int maxSm(vector&lt;vector&lt;int&gt;&gt; &amp;A){\n    int N = A.size(), M = A[0].size();\n    vector&lt;vector&lt;int&gt;&gt; S(N+1, vector&lt;int&gt;(M+1,0));\n    for (int i = 1; i &lt;= N; ++i){\n        int rowSum = 0;\n        for (int j = 1; j &lt;= M; ++j){\n            rowSum += A[i-1][j-1];\n            S[i][j] = S[i-1][j] + rowSum;\n        }\n    }\n    int ans = INT_MIN;\n    for (int i = 1; i &lt;= N; ++i){\n        for (int j = 1; j &lt;= M; ++j){\n            int sm = S[N][M] - S[i-1][M] - S[N][j-1] + S[i-1][j-1];\n            ans = max(ans,sm);\n        }\n    }\n    return ans;\n}\n</code></pre></p>"},{"location":"DSAyy/dp/#max-path-in-triangle","title":"Max Path in Triangle","text":""},{"location":"DSAyy/dp/#problem-statement_7","title":"Problem Statement","text":"<p>Given a triang arr A, of size \\(N \\times N\\). find the max path sum from top to bottom. Where each step you move down to an adjacent num on the row below.</p> <p><pre><code>A = [ \n[3, 0, 0, 0]\n[7, 4, 0, 0] \n[2, 4, 6, 0] \n[8, 5, 9, 3] \n]\n</code></pre> Output = 23</p>"},{"location":"DSAyy/dp/#how_10","title":"How","text":"<p>Classic triangle DP Let <code>dp[j]</code> be max path sum to pos j of current row. update dp inplace from left to right</p> <p>$$ dp[j] = max(dp[j-1],dp[j]) + A[i][j] $$ handle leftmost and rightmost separately.</p> <pre><code>int plinko(vector&lt;vector&lt;int&gt;&gt; &amp;A){\n    int N = A.size();\n    if (N == 0) return 0;\n    vector&lt;int&gt; dp(N,0);\n    dp[0] = A[0][0];\n    for (int i = 1; i &lt; N; ++i){\n        dp[i] = dp[i-1] + A[i][i];\n        for (int j = i-1; j &gt; 0; --j){\n            dp[j] = max(dp[j], dp[j-1]) + A[i][j];\n        }\n        dp[0] = dp[0] + A[i][0];\n    }\n    return *max_element(dp.begin(),dp.end());\n}\n</code></pre>"},{"location":"DSAyy/dp/#max-size-square-submatrix","title":"Max size square submatrix","text":""},{"location":"DSAyy/dp/#problem-statement_8","title":"Problem Statement","text":"<p>Matrix A, \\(N \\times M\\). find the area of largest square sub-matrix that contains only 1s. <pre><code>    A = [0, 1, 1, 0, 1],\n        [1, 1, 0, 1, 0], \n        [0, 1, 1, 1, 0], \n        [1, 1, 1, 1, 0], \n        [1, 1, 1, 1, 1], \n        [0, 0, 0, 0, 0] ]\n</code></pre> Output 9</p>"},{"location":"DSAyy/dp/#how_11","title":"How","text":"<p>DP to compute for each cell (i,j) largest size of a square ending at (i,j) Let <code>dp[i][j]</code> be max side len of a square whose bot right corner is at (i,j) if i == 0 or j == 0:     if <code>A[i][j]</code> is 1, <code>dp[i][j]</code> is 1     else 0 warna if <code>A[i][j]</code> is 1 $$ dp[i][j] = 1 + min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])</p> <p>$$</p> <pre><code>int maxArea(vector&lt;vector&lt;int&gt;&gt;&amp; A){\n    int N = A.size();\n    if (N == 0) return 0;\n    int M = A[0].size(), maxSide = 0;\n    vector&lt;int&gt; prev(M,0), curr(M,0);\n    for (int i = 0; i &lt; N; ++i){\n        for (int j = 0; j &lt; M; ++j){\n            if (A[i][j] == 1){\n                if (i == 0 || j == 0)\n                    curr[j] = 1;\n                else \n                    curr[j] = 1 + min({prev[j],prev[j-1],curr[j-1]});\n                maxSide = max(maxSide, curr[j]);\n            }\n            else \n                curr[j] = 0;\n        }\n        prev.swap(curr);\n    }\n    return maxSide*maxSide;\n}\n</code></pre>"},{"location":"DSAyy/dp/#increasing-path-in-matrix","title":"Increasing path in Matrix","text":""},{"location":"DSAyy/dp/#problem_8","title":"Problem","text":"<p>Given a \\(N \\times M\\) matrix A. You can move:     Down: (i,j) to (i+1,j) if <code>A[i+1][j] &gt; A[i][j]</code>     Right: (i,j) to (i,j+1) if <code>A[i][j+1] &gt; A[i][j]</code> Find the len of longest increasing path from (0,0) ending at (N-1,M-1) if no path exists, ret -1;</p> <pre><code>A = [\n    [1, 2, 3, 4], \n    [2, 2, 3, 4], \n    [3, 2, 3, 4], \n    [4, 5, 6, 7] ] \n    Output: 7 // 1\u21922\u21923\u21924\u21925\u21926\u21927\n</code></pre>"},{"location":"DSAyy/dp/#how_12","title":"How","text":"<p>Let <code>dp[i][j]</code> be len of longst val path from (0,0) to (i,j) <code>dp[0][0]</code> = 1 (only itself) Now for every new, just take max path up and left and add 1</p> <pre><code>int maxPath(vector&lt;vector&lt;int&gt;&gt; &amp;A){\n    int N = A.size();\n    if (N == 0) return -1;\n    int M = A[0].size();\n    if (M == 0) return -1;\n    vector&lt;vector&lt;int&gt;&gt; dp(N, vector&lt;int&gt; (M,0));\n    dp[0][0] = 1;\n    for (int i = 0; i &lt; N; ++i){\n        for (int j = 0; j &lt; M; ++j){\n            if (i == 0 &amp;&amp; j == 0) continue;\n            int best = 0;\n            if (i &gt; 0 &amp;&amp; A[i][j] &gt; A[i-1][j] &amp;&amp; dp[i-1][j] &gt; 0)\n                best = max(best, dp[i-1][j] + 1);\n            if (j &gt; 0 &amp;&amp; A[i][j] &gt; A[i][j-1] &amp;&amp; dp[i][j-1] &gt; 0)\n                best = max(best, dp[i][j-1] + 1);\n            dp[i][j] = best;\n        }\n    }\n    return dp[N-1][M-1] &gt; 0? dp[N-1][M-1] : -1;\n}\n</code></pre>"},{"location":"DSAyy/dp/#min-difference-subsets","title":"Min difference subsets","text":""},{"location":"DSAyy/dp/#problem_9","title":"Problem","text":"<p>Int array A, partition it into two subsets S1, and S2, so that abs diff between their sum is minimized. Return the min possible difference.</p> <p>Example</p> <p>\\(A = [1, 6, 11, 5]\\) Output: 1</p>"},{"location":"DSAyy/dp/#explanation_1","title":"Explanation","text":"<p>Let total sum be S best we can dop is find a subset with sum <code>s</code> as close as S/2. then the other sum is S - s and abs diff is |S - 2s| Use dp to track which sums s s \\(\\leq\\) S/2 are possible.</p> <pre><code>int minDifSub(vector&lt;int&gt; &amp;A){\n    int N = A.size();\n    int tot = accumulate(A.begin(),A.end(),0);\n    int targ = tot / 2;\n    vector&lt;bool&gt; dp(targ + 1, false);\n    dp[0] = true;\n    for (int x : A{\n        for (int s = target; s &gt;= x; --s){\n            if (dp[s-x]) dp[s] = true;\n        }\n    }\n    for (int s = target; s &gt;= 0; --s)\n        if (dp[s])\n            return (tot - 2*s);\n    return tot;\n}\n</code></pre>"},{"location":"DSAyy/dp/#subset-sum-problem","title":"Subset sum problem","text":""},{"location":"DSAyy/dp/#problem_10","title":"Problem","text":"<p>Given int arr A, and int B. Is there a subset of A whose sum is B? \\(A = [3, 34, 4, 12, 5, 2]\\), B = 9 Output: 1 (Because 4 + 5 = 9)  \\(A = [3, 34, 4, 12, 5, 2]\\), B = 30 Output: 0 (No subset sums to 30)</p>"},{"location":"DSAyy/dp/#how_13","title":"How","text":"<p>Classic subset DP \\(dp[s]\\) is true if some subset of A sums to s \\(dp[0]\\) = true for each x     now for each s from B down to x         \\(dp[s] = dp[s] \\space | \\space dp[s-x]\\) </p> <pre><code>int isPoss(vector&lt;int&gt;&amp; A, int B){\n    int N = A.size();\n    vector&lt;bool&gt; dp(B+1, false);\n    dp[0] = 1;\n    for (int x :  A){\n        for (int s = B; s &gt;= x; --s)\n            if (dp[s-x]) dp[s] = true;\n    }\n    return dp[B] ? 1 : 0;\n}\n</code></pre>"},{"location":"DSAyy/dp/#unique-paths-in-a-grid-with-obstacles","title":"Unique Paths in a Grid with Obstacles","text":""},{"location":"DSAyy/dp/#problem_11","title":"Problem","text":"<p>\\(M \\times N\\) Grid, start at (1,1) , reach (m,n). Movement only R or D. Grid has obstacles, marked as blocked (1) or empty (0). Count the number of unique paths fomr top left to bot right, avoid obstacles.</p>"},{"location":"DSAyy/dp/#how_14","title":"How","text":"<p>Let <code>dp[j]</code> be ways to reach j in current row. Let <code>dp[0]</code> = 1. Start jaane ka only one  way For each cell (i,j):     if <code>A[i][j]]</code> = 1, set <code>dp[j]</code> = 0. (cant reach here)     else <code>dp[j] += dp[j-1]</code> (add ways from left if j &gt; 0)     upar ke ways would already be here (magical type shit)</p> <pre><code>int uniquePaths(vector&lt;vector&lt;int&gt;&gt; &amp;A){\n    int m = A.size();\n    if (m == 0) return 0;\n    int n = A[0].size();\n    if (A[0][0] || A[m-1][n-1]) return 0; // entry/exit blocked\n    vector&lt;int&gt; dp(n,0);\n    dp[0] = 1;\n    for (int i = 0; i &lt; m; ++i){\n        for (int j = 0; j &lt; n; ++j){\n            if (A[i][j] == 1)\n                dp[j] = 0;\n            else if (j &gt; 0)\n                dp[j] += dp[j-1];\n        }\n    }\n    return dp[n-1];\n}\n</code></pre>"},{"location":"DSAyy/dp/#yaha-se-down-to-up-dp-kinda-starts","title":"Yaha se down to up dp kinda starts","text":""},{"location":"DSAyy/dp/#dungeon-princess-minimum-initial-health-in-a-grid","title":"Dungeon Princess (Minimum Initial Health in a grid)","text":""},{"location":"DSAyy/dp/#problem-statement_9","title":"Problem Statement","text":"<p>Knight at top left, \\(M \\times N\\) dungeon grid, must reach bot right to the princess. Each cell has int. -ve for demons (damage), zero = empty, +ve health Movement: right and down. Find min initial health for knight to reach princess.</p> <p><pre><code>A = [ \n    [-2, -3, 3]\n    [-5, -10, 1]\n    [10, 30, -5] ]\n</code></pre>  Output: 7</p>"},{"location":"DSAyy/dp/#how_15","title":"How","text":"<p>We go from princess to knight. Its just max path from source to dist. let <code>dp[i][j]</code> be min HP upon entering cell (i,j) so that knight can reach the end.     always keeping HP \\(\\geq\\) 1 Base:     <code>dp[m-1][n-1]</code> = max(1, 1 - <code>A[m-1]][n-1]</code>)  Protection from negatives Fill last row and col, and Reverse DP     <code>dp[i][j]</code> = max(1,min(<code>dp[i+1][j]</code>,<code>dp[i][j+1]</code> - <code>A[i][j]</code>))</p> <pre><code>int calcminHP(vector&lt;vector&lt;int&gt;&gt; &amp;A){\n    int m = A.size();\n    if (m == 0) return 0;\n    int n = A[0].size();\n    vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n,0));\n    dp[m-1][n-1] = max(1, 1 - A[m-1][n-1]);\n    for (int i = m-2; i &gt;= 0; --i)\n        dp[i][n-1] = max(1, dp[i+1][n-1] - A[i][n-1]); // health we need down + this\n    for (int j = n-2; j &gt;= 0; --j)\n        dp[m-1][j] = max(1,dp[m-1][j+1] - A[m-1][j]); // health we need on right + this\n    for (int i = m-2; i &gt;= 0; --i){\n        for (int j = n-2; j &gt;= 0; --j){\n            int needNext = min(dp[i+1][j], dp[i][j+1]);\n            dp[i][j] = max(1, needNext - A[i][j]);\n        }\n    }\n    return dp[0][0];\n}\n</code></pre>"},{"location":"DSAyy/dp/#min-sum-path-in-a-matrix","title":"Min sum path in a matrix","text":""},{"location":"DSAyy/dp/#problem-statement_10","title":"Problem Statement","text":"<p>Given a \\(M \\times N\\) int grid. Find path from top left to bot right with min path sum. You can go Down or Right.</p>"},{"location":"DSAyy/dp/#how_16","title":"How","text":"<p>Basic DP Just keep adding elements and comparing top and left. In the first row, elements can only come from left. In the first col, elements can only come from top. Baaki normally \\(dp[i][j] = A[i][j] + min(dp[i-1][j], dp[i][j-1])\\)</p> <pre><code>int minPathSum(vector&lt;vector&lt;int&gt;&gt; &amp;A){\n    int m = A.size();\n    if (m == 0) return 0;\n    int n = A[0].size();\n    vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt; (n,0));\n    dp[0][0] = A[0][0];\n    // first row, only from left\n    for (int j = 1; j &lt; n; ++j)\n        dp[0][j] = dp[0][j-1] + A[0][j];\n    // first col\n    for (int i = 1; i &lt; m; ++i)\n        dp[i][0] = dp[i-1][0] + A[i][0];\n    for (int i = 1; i &lt; m; ++i){\n        for (int j = 1; j &lt; n; ++j){\n            dp[i][j] = A[i][j] + min(dp[i-1][j], dp[i][j-1]);       \n    return dp[m-1][n-1];\n}\n</code></pre>"},{"location":"DSAyy/dp/#min-path-sum-in-triangle","title":"Min Path Sum in Triangle","text":""},{"location":"DSAyy/dp/#problem_12","title":"Problem","text":"<p>Triangle arr de rakha, min path sum top to bot nikal. Movement, adjacent numbers on the row below.  $$     A[i][j] \\text{ can go to A[i+1][j] and A[i+1][j+1]} $$</p>"},{"location":"DSAyy/dp/#how_17","title":"How","text":"<p>Let \\(dp[j]\\) be min path sum to reach pos j in the current row. We start from bot and move up Let dp = last row of the triangle. Now for each row, update <code>dp[j]</code> as \\(A[i][j] + min(dp[j],dp[j+1])\\) Ans: \\(dp[0]\\) is the min path sum</p> <pre><code>int minTot(vector&lt;vector&lt;int&gt;&gt; &amp;A){\n    int n = A.size();\n    if (n == 0) return 0;\n    vector&lt;int&gt; dp = A[n-1];\n    for (int i = n-2; i &gt;= 0l --i)\n        for (int j = 0; j &lt;= i; ++j)\n            dp[j] = A[i][j] + min(dp[j], dp[j+1]);\n    return dp[0];\n}\n</code></pre>"},{"location":"DSAyy/dp/#max-rectangle-in-binary-matrix","title":"Max Rectangle in Binary Matrix","text":""},{"location":"DSAyy/dp/#problem_13","title":"Problem","text":"<p>Given a 2D bin matrix. Find largest rectangle with all 1s. return its area</p> <p><pre><code>A = [1 1 1]\n    [0 1 1]\n    [1 0 0]\n</code></pre> Ans = 4</p>"},{"location":"DSAyy/dp/#explanation_2","title":"Explanation","text":"<p>Largest rectangle in histogram I see. For each row, build a histogram of consec 1s. For each row, use a stack to compute largest area in \\(O(m)\\) time. Return max found over all.</p> <pre><code>int maximalRect(vector&lt;vector&lt;int&gt;&gt; &amp;A){\n    int n = A.size();\n    if (n == 0) return 0;\n    int m = A[0].size();\n    vector&lt;int&gt; heights(m,0);\n    int maxArea = 0;\n    for (int i = 0; i &lt; n; ++i){\n        // update the height list.\n        for (int j = 0; j &lt; m; ++j){\n            if (A[i][j] == 1) heights[j]++;\n            else heights[j] = 0;\n        }\n        // largest rect\n        stack&lt;int&gt; st;\n        for (int j = 0; j &lt;= m; ++k){\n            int h = (j == m? 0: heights[j]);\n            while (!st.empty() &amp;&amp; h &lt; heights[st.top()]){\n                int height = heights[st.top()];\n                st.pop();\n                int width = st.empty() ? j : (j - st.top() - 1);\n                maxArea = max(maxArea, height * width);\n            }\n            st.push(j);\n        }\n    }\n    return maxArea;\n}\n</code></pre>"},{"location":"DSAyy/dp/#rod-cutting-dp-and-reconstruction","title":"Rod Cutting -- DP and reconstruction","text":""},{"location":"DSAyy/dp/#problem_14","title":"Problem","text":"<p>Rod len A, int arr B of M weak points (cut locations). We must cut at every weak point. Each cut splits a segment into two smaller rods. cost of cut = length of segment in which the cut is made.  Order is up to us.  Return the sequence of curs that achieves the min total cost. If there are many, return the lexicographically smallest.</p> <p>Example: A = 6, B = \\([1,2,5]\\)  Best ans -&gt; 2 1 5 : gives cost 6 + 2 + 4 = 12</p>"},{"location":"DSAyy/dp/#how_18","title":"How","text":"<p>Add 0 and A to the cut positions, and sort. P = \\([0,sorted(B),A]\\)  Let M be the new len = len(B) + 2</p> <p>Let <code>dp[i][j]</code> be the min cost to cut the segment (\\(P_i, P_j)\\) . That is making a cut between the positions \\(P_i\\) and \\(P_j\\)  if (j = i+1), <code>dp[i][j]</code> = 0, coz then we can have no cuts. (kuch hai hi nahi beech meh) else  <code>dp[i][j]</code> = \\(min_{i&lt;k&lt;j} ((P_j - P_i) + dp[i][k] + d[k][j])\\) So basically len of the segment + baaki dono subproblems.</p> <p>Ab bhai lexicographical order check karna. Let <code>cutpos[i][j]</code> be the index k of the first cut that jisne min cost diya. Bas isse compare karke minimum select karle</p> <p>Now for reconstruction Rec(i,j) = {} if j = i+1, coz kuch hai hi nahi beech me     and {\\(P_k\\)} + merge(Rec(i,k),Rec(k,j)) otherwise Basic recursion</p> <pre><code>#python coz this code is hella big\ndef rod_cutting(A,B):\n    B.sort()\n    P = [0] + B + [A]\n    n = len(P)\n    dp = [[0]*n for _ in range(n)]\n    cutpos = [[-1]*n for _ in range(n)]\n    #fill the dp table\n    for length in range(2,n):\n        for i in range(n - length):\n            j = i + length\n            min_cost = float('inf')\n            best_k = -1\n            for k in range(i+1,j):\n                cost = P[j] - [i] + dp[i][k] + dp[k][j]\n                if cost &lt; min_cost  or (cost == min_cost and P[k] &lt; P[best_k]):\n                    min_cost = cost\n                    best_k = k\n            dp[i][j] = min_cost\n            cutpos[i][j] = best_k\n    result = [] #to be reconstructed\n    def reconstruct(i,j):\n        k = cutpos[i][j]\n        if (k == -1): return\n        result.append(P[k])\n        reconstruct(i,k)\n        reconstruct(k,j)\n    reconstruct(0,n-1)\n    return result\n</code></pre>"},{"location":"DSAyy/dp/#queen-attack-grid-scan-technique","title":"Queen Attack (Grid Scan Technique)","text":""},{"location":"DSAyy/dp/#problem_15","title":"Problem","text":"<p>\\(N \\times M\\) chessboard, with some cells having queens. For each cell (i,j) compute how many queens can attack it (assuming no queen at (i,j)). No queens can jump over other queens.</p>"},{"location":"DSAyy/dp/#how_19","title":"How","text":"<p>Normal 8D traversal For each direction, sweep through the board and record if a queen has already been encountered in that direction. Sum up the result for all 8 directions for each cell.</p> <pre><code>def queen_attack(grid):\n    n = len(grid)\n    m = len(grid[0])\n    dirs = [(-1,0),(1,0), (0,-1), (0,1),\n            (-1,-1), (-1,1), (1,-1), (1,1)]\n    attack_count = [[0]*m for _ in range(n)]\n    for dx, dy in range(dirs):\n        seen = [[0]*m for _ in range(n)] #queen already seen in this direction\n        x_range = range(n) if dx &gt;= 0 else range(n-1,-1,-1)\n        y_range = range(n) if dy &gt;= 0 else range(m-1,-1,-1)\n\n        for x in x_range:\n            for y in y_range:\n                nx, ny = x-dx, y - dy\n                if 0 &lt;= nx &lt; n and 0 &lt;= ny &lt; m:\n                    seen[x][y] = seen[nx][ny]\n                if grid[x][y] == '1':\n                    seen[x][y] = 1\n                elif seen[x][y]:\n                    attack_count[x][y] += 1\n    return attack_count\n</code></pre>"},{"location":"DSAyy/dp/#dice-throw-num-of-ways-to-get-a-given-sum","title":"Dice Throw: Num of ways to get a given sum","text":""},{"location":"DSAyy/dp/#problem_16","title":"Problem","text":"<p>Given A num of dice, each with face 1 to B. Find num of ways to roll these dice such that the sum of the numbers shown on the dice is exactly C. Return modulo 1e9  + 7</p>"},{"location":"DSAyy/dp/#how_20","title":"How","text":"<p>Counting DP Let <code>dp[a][s]</code> be num of ways to roll <code>a</code> dice such that their sum is s. We know <code>dp[0][0]</code> = 1 (1 way to get sum 0 with 0 dice) and <code>dp[0][s]</code> = 0 for s &gt; 0</p> <p>Transition $$ dp[a][s] = \\sum_{k = 1}^{B} dp[a-1][s-k] \\text{ for s } \\geq k $$ <pre><code>def num_ways_to_sum(A,B,C):\n    MOD = 10**9 + 7\n    if C &lt; A or C &gt; A*B:\n        return 0\n    prev = [0]*(C+1)\n    prev[0] = 1\n    for a in range(1,A+1):\n        prefix = [0]*(C+1)\n        prefix[0] = prev[0]\n        for s in range(1,C+1):\n            prefix[s] = (prefix[s-1] + prev[s]) % MOD\n        curr = [0]*(C+1)\n        for s in range(0,C+1):\n            if s == 0:\n                curr[s] = 0\n            else:\n                right = prefix[s-1]\n                left = prefix[s-B-1] if s - B -1 &gt;= 0 else 0\n                curr[s] = (right - left + MOD) % MOD\n        prev = curr\n    return prev[c]\n</code></pre></p>"},{"location":"DSAyy/dp/#submatrices-with-sum-zero","title":"Submatrices with Sum Zero","text":"<p>2D Matrix of int. Count num of non-empty submatrices with sum 0. Example</p> <p>-8  5  7  3  7  -8  5 -8  9</p> <p>Output = 2</p>"},{"location":"DSAyy/dp/#how_21","title":"How","text":"<p>KADANE!!! (and prefix sum)</p> <p>Fix 2 rows, top and bottom. For each column, compute sum of elements betweem these two rows inclusive. Now just count zero-sum subarrays in the collapsed column sums array.</p> <pre><code>def countZeroSumSubmatrics(matrix):\n    if not matrix or not matrix[0]:\n        return 0\n    rows,cols = len(matrix), len(matrix[0])\n    total = 0\n    for top in range(rows):\n        col_sums = [0]* cols\n        for bottom in range(top,rows):\n            for c in range(cols):\n                col_sums[c] += matrix[bottom][c]\n            # count 0 sum subarrs in col_sums\n            prefix_freq = {0:1} #psum to freq\n            prefix = 0\n            for val in col_sums:\n                prefix += val\n                total += prefix_val.get(prefix,0) # get freq of psum 0\n                prefix_freq[prefix] = prefix_freq.get(prefix,0) + 1\n    return total\n</code></pre>"},{"location":"DSAyy/dp/#coin-sum-infinite","title":"Coin sum infinite","text":"<p>Given a set of unique coins. Find diff ways to get sum B using infinite supply of these coins. A = 1 2 3 B = 4 Output = 4</p>"},{"location":"DSAyy/dp/#how_22","title":"How","text":"<p>Unbounded knapsack let dp(s) store num of ways to get sum s dp(0) = 1 (one way to make 0 sum) for each coin in A, iterate through all pos sum s from c to B and dp(s) = (dp(s) + dp(s-c)) mod</p> <pre><code>def coinChange2(A,B):\n    MOD = 10**9 + 7\n    n = len(A)\n    dp = [0]*(B+1)\n    dp[0] = 1\n    for coin in A:\n        for s in range(coin,B+1):\n            dp[s] = (dp[s] + dp[s-coin]) % MOD\n    return dp[B]\n</code></pre>"},{"location":"DSAyy/dp/#max-prod-subarray","title":"Max prod subarray","text":""},{"location":"DSAyy/dp/#problem_17","title":"Problem","text":"<p>int arr A, find a contig subarray which has largest prod. return the prod.</p> <p>Example A = 2 3 -2 4 Output = 6</p>"},{"location":"DSAyy/dp/#how_23","title":"How","text":"<p>Unlike normal kadane, we have to track both max and min prod at each step, due to presence of -ve nums A -ve num can turn the smallest into the largest <code>maxEnding</code> = max prod ending at cur index <code>minEnding</code> = min prod ending at cur index</p> <p>if el is -ve, swap maxEnding and minEnding then update     maxEnding = \\(max(x,maxEnding \\times x)\\)     minEnding = \\(min(x,minEnding \\times x)\\)</p> <pre><code>def maxProdSubarr(A):\n    maxEnding = A[0]\n    minEnding = A[0]\n    ans = A[0]\n    for i in range(1,n):\n        x = A[i]\n        if x &lt; 0:\n            maxEnding,minEnding = minEnding,maxEnding\n        maxEnding = max(x,maxEnding * x)\n        minEnding = min(x,minEnding * x)\n        ans = max(ans, maxEnding)\n    return ans\n</code></pre>"},{"location":"DSAyy/dp/#best-time-to-buy-and-sell-stock-1","title":"Best time to buy and sell stock 1","text":""},{"location":"DSAyy/dp/#problem_18","title":"Problem","text":"<p>int arr A, <code>A[i]</code> is price of stock on day i Allowed one transaction, buy and sell once. Find max poss profit. </p> <p>Example A = 1 2 Output = 1 Input 1 4 5 2 4 Output: 4</p> <p>How: <code>minPrice</code> Min price seen so far maxProfit = <code>A[i]</code> - minPrice then update then price</p> <pre><code>def buySell(A):\n    minPrice = A[0]\n    maxProfit = 0\n    for i in (1,len(A)):\n        maxProfit = max(maxProfit, A[i] - minPrice)\n        minPrice= min(minPrice, A[i])\n    return maxProfit\n</code></pre>"},{"location":"DSAyy/dp/#arrange-ii","title":"Arrange II","text":""},{"location":"DSAyy/dp/#problem_19","title":"Problem","text":"<p>Given a seq of horses, B means black, W means White and K num of stables. YOu have to assign all horses to stables Each horse is assigned to only one stable Cost of stable = num(White horses) \\(\\times\\) num(Black horses) Total cost is sum of all stable cost Stables cannot be non empty If not possible to assign, return -1</p> <p>Example A = <code>WWWB</code>, K = 2 Output = 0 Arrangement: {WWW}, {B}</p>"},{"location":"DSAyy/dp/#how_24","title":"How","text":"<p>We have to DP with partition Let DP state be min cost of placing first i horses into k stables     dp(i,k): min cost to place first i horses into k stables     cost(j+1,i): cost of placing horses from index j+1 to i in one stable So we build psum fopr white and black horses so we can compute cost(j+1,i) in constant time.</p> <p>Transition will look like $$ dp[i][k] = min_{j = k-1}^{i-1} (dp[j][k-1] + cost(j+1,i)) $$ so min cost to place first i horses into k stables is min cost to place any first k horses in k-1 stables and rest of them in a new stable</p> <p>dp(0,0) = 1 if i &lt; k: we cannot have k non-empty stables.</p> <pre><code>def arrange(A,B):\n    N = len(A)\n    if N &lt; B:\n        return -1\n    w = [0]*(N+1) #psum for white and black horses\n    b= [0]*(N+1)\n    for i in range(1,N+1):\n        w[i] = w[i-1] + (A[i-1] == 'W')\n        b[i] = b[i-1] + (A[i-1]=='B')\n    def cost(i,j):\n        return (w[j]-w[i-1])*(b[j] - b[i-1])\n    INF = 10**15\n    dp = [[INF]* (B+1) for _ in range(N+1)]\n    dp[0][0] = 1\n    for i in range(1,N+1):\n        for k in range(1,B+1):\n            for j in range(k-1,i):\n                if dp[j][k-1] == INF:\n                    continue\n                c = cost(j+1,i)\n                dp[i][k] = min(dp[i][k], dp[j][k-1] + c)\n    return dp[N][B] if dp[N][B] &gt;= INF else -1\n</code></pre>"},{"location":"DSAyy/dp/#chain-of-pairs","title":"Chain of Pairs","text":""},{"location":"DSAyy/dp/#problem_20","title":"Problem","text":"<p>Given list of pairs A, where pair (a,b) has a &lt; b. pair (c,d) can follow (a,b) in a chain if b &lt; c. Find max len of chain of such pairs preserving relative order. Pairs can be skipped but not rearranged</p> <p>Exampkle A = (5,24) (39,60) (15,28) (27,40) (50,90) Output = 3</p>"},{"location":"DSAyy/dp/#how_25","title":"How","text":"<p>Its like longest increasing subsequence but with custom comparator First sort pairs by first element Let dp(i) be longest chain ending at i for each pair i, check previous pairs and if A(j,1) &lt; A(i,0):     update dp(i) = max(dp(i), dp(j) + 1)</p> <pre><code>def pairLIS(A):\n    N = len(A)\n    dp = [1]*(N)\n    ans = 1\n    for i in range(0,N):\n        for j in range(0,i):\n            if A[j][1] &lt; A[i][0]:\n                dp[i] = max(dp[i], dp[j] + 1)\n        ans = max(ans, dp[i])\n    return ans\n</code></pre>"},{"location":"DSAyy/dp/#max-sum-without-adjacent-elements","title":"Max Sum without adjacent elements","text":""},{"location":"DSAyy/dp/#problem-statement_11","title":"Problem Statement","text":"<p>Given a \\(2 \\times N\\) grid A, select subsets of elements such that:     sum of selected nums is maximised     no two selected elements are adjacent horizontally vertically or diagonally</p> <p>Example: </p> <pre><code>1 2 3 4\n2 3 4 5\n</code></pre> <p>Output = 8</p>"},{"location":"DSAyy/dp/#how_26","title":"How","text":"<p>This is a variation of classical house robber problem extended to two rows</p> <p>maintain 3 dp states dp0 be maxsum picking nothing in this column dp1 be maxsi, picking the top cell dp2 be maxsum picking the bottom cell</p> <p>Transitions: dp0 = max(dp0, dp1,dp2) dp1 = dp0 + top(k) dp2 = dp0 + bottom(k)</p> <pre><code>def adjacent(A)\n    N = len(A[0])\n    T,B = A[0],A[1]\n    dp0,dp1,dp2 = 0, T[0], B[0]\n    for k in range(1,N):\n        dp0_n = max([dp0,dp1,dp2])\n        dp1_n = dp0 + T[k]\n        dp2_n = dp0 + B[k]\n        dp0,dp1,dp2 = dp0_n,dp1_n,dp2_n\n    return max([dp0,dp1,dp2])\n</code></pre>"},{"location":"DSAyy/dp/#merge-elements","title":"Merge Elements","text":""},{"location":"DSAyy/dp/#problem_21","title":"Problem","text":"<p>Given int arr, merge all elements into one by repeatedly merging 2 adjacent elements. Rule: merging X and Y, cost is X+Y, val is also X+Y return min total cost.</p> <p>Example:</p> <p>A =  1 3 7 Output 15</p> <p>costs : 4 + 11 = 15</p>"},{"location":"DSAyy/dp/#how_27","title":"How","text":"<p>This is a variation of Matrix Chain Multiplication let  <code>dp(i,j)</code> be min cost to merge <code>A(i to j)</code> sum <code>(i,j)</code> be sum of el from <code>A(i)</code> to <code>A(j)</code></p> <p>For each subarr A(i..j), try every split point k and compute $$ dp[i][j] = min_{k=i}^{j-1} (dp[i][k] + dp[k+1][j] + sum(i,j)) $$ sum(i,j) is ofc prefix sum</p> <pre><code>def mergeElement(A):\n    N = len(A)\n    psum = [0]*(N+1)\n    for i in range(1,N+1):\n        psum[i+1] = psum[i] + A[i]\n    def rangeSum(i,j):\n        return psum[j+1] - psum[i]\n    INF = 10**15\n    dp = [[INF]*(N+1) for _ in range(N+1)]\n    for i in range(N+1):\n        dp[i][i] = 0\n    for length in range(2,N+1):\n        for i in range(0,N - length):\n            j = i + len -1\n            best = INF\n            for k in range(i,j):\n                cost = dp[i][k] + dp[k+1][j] + rangeSum(i,j)\n                best = min(best, cost)\n            dp[i][j] = best\n    return dp[0][N-1]\n</code></pre>"},{"location":"DSAyy/dp/#flip-array","title":"Flip Array","text":""},{"location":"DSAyy/dp/#problem_22","title":"Problem","text":"<p>Array A of +ve int, flip sign of some elements such that resultant sum is as close to 0 as possible We need to minimize the number of elemnts flipped to achieve this.</p> <p>Return the numbers flipped.</p> <p>Example</p> <pre><code>A = 15 10 6\nOutput = 1\nWe just flip 15\n</code></pre>"},{"location":"DSAyy/dp/#how_28","title":"How","text":"<p>Variation of subset sum problem</p> <p>Let total be the arr sum Find a subset of element such that sum is close to total / 2</p> <p>Let dp(s) be the min num of el flipped to get subset sum s</p> <p>dp(0) = 0</p> <p>update from top to down to avoid using same el twice</p> <pre><code>def flip(A):\n    total = sum(A)\n    cap = total/2\n    N = len(A)\n    INF = 10**15\n    dp = [INF]*(N+1)\n    dp[0] = 0\n    for x in A:\n        for s in range(cap,x-1,-1):\n            dp[s] = min(dp[s], dp[s-x] + 1)\n    return min(dp)\n</code></pre>"},{"location":"DSAyy/dp/#tengu-bday-party-unbounded-knapsack","title":"Tengu Bday Party (Unbounded Knapsack)","text":""},{"location":"DSAyy/dp/#problem_23","title":"Problem","text":"<p>Tengu has to feed all his friends. Each friend has an eating capacity. Objective: Satisfy all friends by selecting dishes (each friend eats separately, and can use dishes any number of times). such that total cost is minimized.</p> <p>Example</p> <p>Friends A = 4 6</p> <p>Dish Fillings B = 1 3</p> <p>Dish Cost C = 5 3</p> <p>Output 14</p> <pre><code>Friend 1 eats dish 1  2 : cost: 5 + 3 = 8\nFriend 2 eats dish 2 twice: cost: 3 + 3 = 6\nTotal cost = 8 + 6 = 14\n</code></pre>"},{"location":"DSAyy/dp/#how_29","title":"How","text":"<p>This is a bounded knapsack applied for each friend. But we optimize by precomputing minimum cost to fill any capacity up to max (friend's need), using unbounded knapsack (since dishes can be reused)</p> <p>Let \\(dp[s]\\) be min cost to eat <code>s</code> fill of food.</p> <p>Now for each capacity s, try all dishes and  $$     dp[s] = min_{all\\space dishes}(dp[s], dp[s-fill(dish)] + cost(dish)) $$ Once computed the whole thing, sum up <code>dp[A[i]]</code> for each friend.</p> <pre><code>def unbounded_knapsack(A,B,C):\n    maxFill = max(A)\n    num_dishes = len(B)\n    INF = 10**15\n    dp = [INF]*(maxFill + 1)\n    dp[0] = 1\n    for fill in range(1,maxFill):\n        for j in range(num_dishes):\n            if B[j] &lt;= fill:\n                dp[fill] = min(dp[fill], dp[fill - B[j]] + C[j])\n    totalCost = 0\n    for f in A:\n        totalCost += dp[f]\n    return totalCost\n</code></pre>"},{"location":"DSAyy/dp/#0-1-knapsack","title":"0 - 1 Knapsack","text":"<p>Given A values, B weights, C as the capacity of our knapsack.</p> <p>Select a subset of items such that:     weight does not exceed C     total value is maximised     Either take the whole item or dont take at all</p> <p>Ex:</p> <pre><code>A = 60 100 120\nB = 10 20 30\nC - 50\n</code></pre> <p>Ans is 220 (pick 2 and 3)</p>"},{"location":"DSAyy/dp/#how_30","title":"How","text":"<p>Let \\(dp[w]\\) be max value achievable for capacity \\(w\\)</p> <p>Now the relation is</p> <p>$$ dp[w] = max(dp[w], dp[w - B[i]] + A[i]) $$ Since we can pick each el exactly once, loop backwards.</p> <pre><code>def knapsack_normal(A,B,C):\n    n = len(A)\n    dp = [0]*(C+1)\n    for i in range(n):\n        val,wt = A[i],B[i]\n        for w in range(C,wt-1,-1):\n            dp[w] = max(dp[w], dp[w - wt] + val)\n    return dp[C]\n</code></pre>"},{"location":"DSAyy/dp/#equal-average-partition-subset-sum-wt-avg-equality","title":"Equal Average Partition (subset sum wt avg equality)","text":"<p>Given an int arr A. Partition it into two non-empty subsets \\(A_1\\) and \\(A_2\\) such that:     \\(average(A_1) == average(A_2)\\) \\(|A_1| \\leq |A_2|\\)     even if equal, \\(A_1\\) must be lexicographically smaller Return the two subsets as a 2D array. If nothing, return an empty list.</p> <p>Example:     A = 1 7 15 29 11 9     Output: 9 15 and 1 7 11 29     Both have average 12</p>"},{"location":"DSAyy/dp/#how_31","title":"How","text":"<p>Let S be total sum of arr and n be the size</p> <p>We try all subset sizes k from 1 to \\(n/2\\) </p> <p>For each k, if a subset exists such that \\(\\(sum = \\frac{S\\cdot k}{n}\\)\\) and this sum is an int, then its valid candidate.</p> <p>Use dp with bitset to check reachability: $$ reachable[i][c][s] = true \\iff \\text{we can pick c elements from A[i..n-1] to sum to s}$$ Once it is reachable, reconstruct smallest subset</p> <pre><code>from collections import defaultdict\nfrom functools import lru_cache\n\ndef eq_avg_partition(A):\n    A.sort()\n    n = len(A)\n    total_sum = len(A)\n    @lru_cache(None) # memoise for checking subset existence of size k\n    def is_possible(i,k,target):\n        if k == 0:\n            return target == 0\n        if i &gt;= n or k &lt; 0 or target &lt; 0:\n            return False\n        #pick not pick for A[i]\n        return is_possible(i+1,k,target) or is_possible(i+1,k-1,target-A[i])\n    # reconstruct the actual target\n    def find_subset(i,k,target):\n        subset = []\n        while k &gt; 0:\n            if is_possible(i+1,k-1,target - A[i]):\n                subset.append(A[i])\n                target -= A[i]\n                k -= 1\n            i += 1\n        return subset\n    for k in range(1, n//2 + 1):\n        if (total_sum * k) % n != 0:\n            continue\n        target_sum = (total_sum * k) // n\n        if (is_possible(0,k,target_sum):\n            subset1 = find_subset(0,k,target_sum)\n            # build its complement\n            subset2 = A.copy()\n            for x in subset1:\n                subset2.remove(x)\n            return [subset1,subset2]\n    return []\n</code></pre>"},{"location":"DSAyy/dp/#potion-mixing-for-min-smoke","title":"Potion mixing for min smoke","text":"<p>Given an arr A of N potions, in range \\([0,99]\\), indicating its color. We have mix all into one, following the below rules     Mix only two adjacent potions     Mixing X and Y results in X+Y mod 100 color     smoke generate during a mix is \\(X \\times Y\\)  Find min amount of smoke required to mix all potions into one. A = 2 3 ans = 6 A = 2 3 4 5 ans = 71</p>"},{"location":"DSAyy/dp/#how_32","title":"How?","text":"<p>MCM variant haha loser     Let \\(dp[i][j]\\) be min smoke generated to mix potions from i to j     Let \\(color[i][j]\\) be final color obtained after mixing potions from i to j Base case:     for single potions, no smoke:         \\(dp[i][i] = 0,\\space color[i][i] = A[i]\\)  Relation:     $$     dp[i][j] = min_k(dp[i][k] + dp[k+1][j] + color[i][k] \\times color[k+1][j])     $$     and then just update the color     $$     color[i][j] = (color[i][k] + color[k+1][j])\\space  mod \\space 100     $$</p> <pre><code>def minSmoke(A):\n    if not A: return 0\n    N = len(A)\n    dp = [[0]*(101) for _ in range(101)]\n    color = [[0]*(101) for _ in range(101)]\n    for i in range(N):\n        color[i][i] = A[i] % 100\n    for len in range(2,N+1):\n        for i in range(0,N-len+1):\n            j = i + len - 1\n            dp[i][j] = 10**15 # some max value\n            for k in range(i,j):\n                smoke = dp[i][k] + dp[k+1][j] + color[i][k]*color[k+1][j]\n                if smoke &lt; dp[i][j]:\n                    dp[i][j] = smoke\n                    color[i][j] = (color[i][k] + color[k+1][j]) % 100\n    return dp[0][n-1]           \n</code></pre>"},{"location":"DSAyy/dp/#buy-and-sell-stock-ii","title":"Buy and Sell stock II","text":"<p>Given arr A of prices. Buy and Sell (transaction) any number of times, but not overlapping.</p> <p>Return max pos profit.</p> <p>A = 1 2 3, Output = 2</p>"},{"location":"DSAyy/dp/#how_33","title":"How","text":"<p>This is a greedy problem bruv</p> <p>Just sum all positive differences between \\(A[i] - A[i-1]\\) </p> <pre><code>def maxProfit(A):\n    n = len(A)\n    profit = 0\n    for i in range(1,n):\n        profit += A[i] - A[i-1] if A[i] &gt; A[i-1]\n    return profit\n</code></pre>"},{"location":"DSAyy/dp/#word-break-ii","title":"Word Break II","text":"<p>Given string S and dict of words B, insert spaces into A to construct all possible sentences such that each word is in the dict.     A = catsanddogs     B = cat cats and sand dog     Output = \"cat sand dog\" \"cats and dog\"</p>"},{"location":"DSAyy/dp/#broke-ass-boy","title":"Broke ass boy","text":"<p>This is DFS + Memoization</p> <p><code>dfs(start)</code> would return all valid sentences starting at index <code>start</code> and it would be memoized on dfs.</p> <pre><code>from functools import lru_cache\ndef wordBreak(s,wordDict):\n    word_set = set(wordDict)\n    #lru_cache(maxSize = None)\n    def dfs(start):\n        if start == len(s): return [\"\"]\n        sentences = []\n        for end in range(start + 1, len(s) + 1):\n            word = s[start:end]\n            if word in word_set:\n                for suffix in dfs(end):\n                    sentence = word + (\" \" + suffix if suffix else \"\")\n                    sentences.append(sentence)\n        return sentences\n    result = dfs(0)\n    return sorted(result)\n</code></pre>"},{"location":"DSAyy/dp/#unique-binary-search-trees-ii","title":"Unique Binary Search Trees II","text":"<p>Given int A, compute num of structurally unique BSTs that store value from 1 to A.     A = 3, output = 5</p>"},{"location":"DSAyy/dp/#how_34","title":"How","text":"<p>This is just a Catalan Number dp problem. $$ G(n) = \\text{number of unique BSTs with node n} $$ $$ G(n) = \\sum_{i=1}^{n} G(i - 1) \\cdot G(n-i) $$ G(i-1) counts left subtrees and G(n-i) counts right subtrees. Base Case:  G(0) = 1 (Empty tree)</p> <pre><code>def UniqueBST(A):\n    G = [0]*(A+1)\n    for n in range(1,A+1):\n        for root in range(1,n+1):\n            G[n] += G[root - 1]*G[n - root]\n    return G[A]\n</code></pre>"},{"location":"DSAyy/dp/#count-permutations-of-bst-with-given-height","title":"Count Permutations of BST with Given Height","text":"<p>Given two int A and B, count how many perms of set {1,2..A} produce a BST of height B.     A = 3, B = 1, Output = 2. (2 1 3 and 2 3 1)     Note vals are inserted from L to R     Remember to MOD</p>"},{"location":"DSAyy/dp/#how_35","title":"How","text":"<p>Let \\(dp[n][k]\\) be num of perms of size n that from a BST of height \\(\\leq\\) h</p> <p>Choose a root( say i, which partitions set into left and right subtrees of size i-1 and  n - i)     Left and right subtrees must have height \\(\\leq\\) h-1     $$     dp[n][h] += dp[i-1][h-1] \\cdot dp[n-i][h-1] \\cdot \\binom{n-1}{i-1}     $$     Precompute combinations and use memoization for dp</p> <pre><code>from functools import lru_cache\nimport math\nMOD = 10**9 + 7\nMAX = 51\n\n#precompute n choose k\nchoose [[0]*MAX for _ in range(MAX)]\nfor n in range(MAX):\n    choose[n][0] = choose[n][n] = 1\n    for k in range(1,n):\n        choose[n][k] = (choose[n-1][k-1] + choose[n-1][k]) % MOD\n@lru_cache(maxSize = None)\ndef count_permutations(n,h):\n    if h == 0: return 1 if n &lt;= 1 else 0\n    if n == 0: return 1\n    total = 0\n    for i in range(1,n+1):\n        left = count_permutations(i-1,h-1)\n        right = count_permutations(n-i,h-1)\n        total += (left * right % MOD)* choose[n-1][i-1]\n    return total\ndef count_exact_height_bsts(A,B):\n    at_most_B = count_permutations(A,B)\n    at_most_B_minus_1 = count_permutations(A,B-1)\n    return (at_most_B - at_most_B_minus_1 + MOD) % MOD\n</code></pre>"},{"location":"DSAyy/dp/#palindrome-partitioning-ii","title":"Palindrome Partitioning II","text":"<p>Given string A, partition such that every substring in the partition is a palindrome.</p> <p>Return min cuts needed to achieve such a partition.     A = aba, output = 0 (already palindrome)     A = aab, output = 1  (aa and b)</p>"},{"location":"DSAyy/dp/#how_36","title":"How","text":"<p>Let \\(isPal[i][j]\\) check if A{i..j} is a palindrome. Precompute this. A DP array <code>f[i]</code> representing mincuts needed for substring \\(A[0..i]\\)</p> <p>Transition $$     f[i] = min_{0\\leq j &lt; i}(f[j] + 1) \\text{ if A[j + 1...i] is a palindrome}     $$ <pre><code>def minCut(s: str) -&gt; int:\n    n = len(s)\n    isPalindrome = [[False]*n for _ in range(n)]\n    for i in range(n): isPalindrome[i][i] = True\n    for length in range(2,n+1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                isPalindrome[i][j] = isPalindrome[i+1][j-1] if length != 2 else True\n    f = [float(inf)]*n\n    for i in range(n):\n        if palindrome[0][i]:\n            f[i] = 0\n        else:\n            for j in range(i):\n                if isPalindrome[j+1][i]:\n                    f[i] = min(f[i],f[j] + 1)\n    return f[n-1]\n</code></pre></p>"},{"location":"DSAyy/dp/#word-break","title":"Word Break","text":"<p>Given a string A, and dict B of valid words. Can A be segmented into a space -separated sequence of one or more dict words.</p> <p>Input: A = myinterviewtrainer , B = trainer my interview     Output = 1</p>"},{"location":"DSAyy/dp/#how_37","title":"How","text":"<p>Let \\(dp[i]\\) be true if \\(A[0...i]\\) can be broken into words from dictionary. \\(dp[0]\\) is true , coz empty string is segmentable</p> <p>Iterate over all lengths, and check if any valid suffix ending at <code>i</code> is in the dictionary. To optimize this, we compute max word length in the dict, to reduce the substring checks.</p> <pre><code>def wordBreak(s: str, wordDict: list[str]) -&gt; bool:\n    word_set = set(wordDict)\n    n = len(s)\n    max_word_length = max(len(word) for word in wordDict)\n    dp = [False]*(n+1)\n    dp[0] = 1\n    for i in range(1,n+1):\n        for length in range(1, min(i, max_word_length) + 1):\n            if dp[i-length] and s[i-length:i] in word_set:\n                dp[i] = True\n                break\n    return dp[n]\n</code></pre>"},{"location":"DSAyy/graph/","title":"Graphs","text":""},{"location":"DSAyy/graph/#path-in-a-directed-graph","title":"Path in a directed graph","text":"<p>Directed graph A nodes, node labelled 1 to A. Directed edges B.</p> <p>Determine if a path exists from node 1 to node A.</p>"},{"location":"DSAyy/graph/#how","title":"How","text":"<p>BFS. duh</p> <pre><code>from collections import deque, defaultdict\ndef reachable(A,B) \n    adj = defaultdict(list)\n    for u,v in B:\n        adj[u].append(v)\n    visited = [False]*(A+1)\n    q = deque()\n    visited[0] = True\n    q.append(1)\n    while q:\n        q.popleft()\n        if u == A: return 1\n        for v in adj[u]:\n            if not visited[v]:\n                visited[v] =True\n                q.append(v)\n    return 0    \n</code></pre>"},{"location":"DSAyy/graph/#water-flow","title":"Water Flow","text":"<p>Given a N \\(\\times\\) M matrix A. It represents height of land cells. Determine how many cells can allow water to flow to both the:</p> <p>Blue Lake: which touches top and left border</p> <p>Red Lake: which touches bottom and right border</p> <p>Water can flow from a cell to its neighbors if the neighbors height \\(\\leq\\) cur height</p>"},{"location":"DSAyy/graph/#how_1","title":"How?","text":"<p>Do two BFS traversal</p> <p>one from blue lake connected cells</p> <p>one from red lake connected cells</p> <p>Only flow if height of neighbor \\(\\geq\\) our height</p> <pre><code>from collections import deque\ndef waterFlow(A):\n    n,m = len(A), len(A[0])\n    blue = [[False]*(m+1) for _ in range(n)]\n    red = [[False]*(m+1) for _ in range(n)]\n    qb,qr = deque(), deque()\n    for i in range(n):\n        blue[i][0], red[i][m-1] = True, True\n        qb.append([i,0])\n        qr.append([i,m-1])\n    for j in range(m):\n        blue[0][j], red[n-1][j] = True, True\n        qb.append([0,j])\n        qr.append([n-1,j])\n    dirs = [[1,0],[-1,0], [0,1], [0,-1]]\n    def bfs(q,vis):\n        while q:\n            i,j = q.popleft()\n            for dx,dy in dirs:\n                ni,nj = i + dx, j + dy\n                if 0 &lt;= ni &lt; n and 0 &lt;= nj &lt; m and not vis[ni][nj]:\n                    if A[ni][nj] &gt;= A[i][j]:\n                        vis[ni][nj] = True\n                        q.append([ni,nj])\n    bfs(qb, blue)\n    bfs(qr,red)\n    ans = 0\n    for i in range(n):\n        for j in range(m):\n            if blue[i][j] and red[i][j]: ans += 1\n    return ans\n</code></pre>"},{"location":"DSAyy/graph/#stepping-number","title":"Stepping number","text":"<p>step num: if abs dif between every pair of adjacent digits = 1</p> <p>find all step num in range A to B</p> <p>123 and 321 are stepping nums, but 358 is not</p>"},{"location":"DSAyy/graph/#how_2","title":"How","text":"<p>Perform bfs for each starting from 1 to 9 (and include 0 is A = 0)</p> <p>For each num extract the last digit</p> <p>Append digit that differ by 1 to the current num</p> <p>\\(12 \\times 10 + (2-1) = 121\\)</p> <p>\\(12 \\times 10 + (2+1) = 123\\)</p> <p>bas yahi karte reh until you reach B <pre><code>vector&lt;int&gt; stepNum(int A, int B){\n    vector&lt;int&gt; result;\n    if (A == 0) result.push_back(0);\n    for (int start - 1; start &lt;= 9; ++start){\n        queue&lt;int&gt; q; q.push(start);\n        while (!q.empty()){\n            int num = q.front(); q.pop();\n            if (num &gt; B) continue;\n            if (num &gt;= A) result.push_back(num);\n            int last = num % 10;\n            if (last &gt; 0) q.push(num * 10 + (last - 1));\n            if (last &lt; 9) q.push(num * 10 + (last + 1)) ;\n        }\n    }\n    sort(results.begin(),results.end());\n    return result;\n}\n</code></pre></p>"},{"location":"DSAyy/graph/#capture-regions-on-board","title":"Capture regions on board.","text":"<p>Given a 2d character matrix A size \\(N \\times M\\) , each cell contains either <code>X</code> or <code>0</code>. Capture all regions surrounded by <code>X</code></p> <p>A region is captured by flipping 0s into Xs in that surrounded region.</p> <p>Dont output anything, just change inplace.</p>"},{"location":"DSAyy/graph/#how_3","title":"How","text":"<p>Find all boundary connected 0s,</p> <p>Mark them as # using BFS.</p> <p>Then traverse the entire board and convert unmarked Os into Xs</p> <p>Then convert marked # into 0s</p> <pre><code>from collections import deque\ndef captureRegions(A):\n    n,m = len(A), len(A[0])\n    q = deque()\n    for i in range(n):\n        for j in range(m):\n            if A[i][j] == 'O':\n                A[i][j] = '#'\n                q.append((i,j))\n    dirs = [[1,0],[-1,0], [0,1], [0,-1]]\n    while q:\n        i,j = q.popleft()\n        for dx,dy in dirs:\n            x,y = i+dx,j + dy\n            if 0 &lt;= x &lt; n and 0 &lt;= y &lt; m and A[x][y] == 'O':\n                A[x][y] = '#'\n                q.append((x,y))\n    for i in range(n):\n        for j in range(m):\n            if A[i][j] == 'O': A[i][j] = 'X'\n            if A[i][j] == '#': A[i][j] = '0'    \n</code></pre>"},{"location":"DSAyy/graph/#word-search-on-a-board","title":"Word Search on a Board","text":"<p>2D char board and a word, determine if word exists in the grid. Word must be constructed through sequentially adjacent cells. Same letter can be used more than once on a cell</p> <p>Board = </p> <p>ABCE</p> <p>SFCS</p> <p>ADEE</p>"},{"location":"DSAyy/graph/#how_4","title":"How","text":"<p>Perform DFS from every cell in the board, check if the word can be constructed starting at that cell. Dont mark visited cells, since it can be resused.</p> <pre><code>def exist(board,word):\n    n,m = len(board), len(board[0])\n    dirs = [[1,0],[-1,0], [0,1], [0,-1]]\n    vis = [[False]*(m) for _ in range(n)]\n    def dfs(i, j ,pos):\n        if board[i][j] != word[pos]: return False\n        if pos == len(word) - 1: return True\n        vis[i][j] = 1\n        for dx,dy in dirs:\n            x,y = i + dx, j + dy\n            if 0 &lt;= x &lt; n and 0 &lt;= y &lt; m:\n                if dfs(i,j,pos+1):\n                    return True\n        vis[i][j] = 0\n        return False\n\n    for i in range(n):\n        for j in range(m):\n            if dfs(i,j,0): return True\n    return False\n</code></pre>"},{"location":"DSAyy/graph/#path-with-good-nodes","title":"Path with Good Nodes","text":"<p>Given a tree with N nodes. Each node is marked good/bad <code>A[i]</code> = 1 means node i+1 is good, warna its bad</p> <p>A 2D array B of (N-1) \\(\\times\\) 2 representing undirected edges of the tree.</p> <p>int C representing max good nodes on a path</p> <p>Compute num of root-to-leaf paths in the tree with atmost C good nodes.</p>"},{"location":"DSAyy/graph/#how_5","title":"How","text":"<p>Perform a dfs from node 1, keeping track of good nodes on the path If good nodes exceed C, prune the path.</p> <pre><code>from collections import defaultdict\ndef goodPath(A,B,C):\n    adj = defaultdict(list)\n    for u,v in B:\n        adj[u].append(v)\n        adj[v].append(u)\n    ans = 0\n    def dfs(node, parent, good_count):\n        if u != 1 and len(adj[u]) == 1:\n            if goodCnt &lt;= C: ans += 1\n            return\n        for v in adj[u]:\n            if v == parent: continue\n            nxtGood = goodCnt + A[v-1]\n            if nxtGood &lt;= C:\n                dfs(v,u,nxtGood)\n    dfs(1,0,A[0])\n    return ans\n</code></pre>"},{"location":"DSAyy/graph/#largest-dist-between-nodes-of-a-tree","title":"Largest Dist between nodes of a tree","text":"<p>Given an unweighted tree with N nodes numbered from 0 to N-1</p> <p>Find largest path in the tree.</p> <p>Given the parent array.</p> <p>if \\(parent[i]\\) = -1? i is the root, warna \\(parent[i]\\) has an edge with i</p>"},{"location":"DSAyy/graph/#how_6","title":"How","text":"<p>Find farthest node from root, then find farthest node from that node. The dist is the ans</p> <pre><code>from collections import defaultdict, deque\n\ndef largestDist(A):\n    n = len(A)\n    if n &lt;= 1: return 0\n    adj = defaultdict(list)\n    root = 0\n    for i in range(n):\n        if A[i] == -1:\n            root = i\n        else:\n            p = A[i]\n            adj[i].append(p)\n            adj[p].append(i)\n    def bfs(start):\n        dist = [-1]*(N)\n        q = deque()\n        dist[start] = 0\n        q.append(start)\n        farNode = start\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if dist[v] != -1: continue\n                dist[v] = dist[u] + 1\n                q.push(v)\n                farNode = v if dist[v] &gt; dist[farNode] else farNode\n        return (farNode, dist[farNode])\n    u,du = bfs(root)\n    v,dv = bfs(u)\n    return dv\n</code></pre>"},{"location":"DSAyy/graph/#good-graph","title":"Good Graph","text":"<p>Directed Graph, N nodes. Each node points to exactly one node. </p> <p>We are given the parent array.</p> <p>Node is good if</p> <p>it is node 1</p> <p>it is connected to node 1</p> <p>Find min number of edge changes such that all nodes become good.</p>"},{"location":"DSAyy/graph/#how_7","title":"How","text":"<p>So the input is a functional graph where all nodes have out degree 1</p> <p>This may contain many disjoint cycles.</p> <p>We aim to detect all cycles.</p> <p>If a cycle contains node 1, it is already good. </p> <p>If it does notm we must change atleast one point in the cycle to point towards node 1 or another good node.</p> <pre><code>def goodGraph(A):\n    N = len(A)\n    next = [0]*(N)\n    for i in range(N): # convert to 0 based indexing\n        next[i] = A[i] - 1\n    vis = [0]*(N)\n    ans = 0\n    for i in range(N):\n        if vis[i]: continue\n        path = []\n        curr = i\n        while True:\n            vis[curr] = 1\n            path.append(curr)\n            nxt = next[curr]\n            if vis[nxt] == 0:\n                curr = nxt\n            elif vis[nxt] == 1: # this is a cycle\n                containsOne = False\n                n = len(path)\n                for k in range(n-1,-1,-1): # look if 1 is in the cycle\n                    if path[k] == nxt:\n                        for t in range(k,n):\n                            if path[t] == 0:\n                                containsOne = True\n                                break\n                        break\n                if not containOne: \n                    ans += 1\n                break # break once done doin the cycle shit\n            else : break # break if we come across an already processed node\n        for v in path:\n            vis[v] = 2 # mark processed\n    return ans  \n</code></pre>"},{"location":"DSAyy/graph/#cycle-in-directed-graph","title":"Cycle in directed graph","text":"<p>A nodes and M edges Directed, check if it has a cycle</p> <p>B is a list of edges</p>"},{"location":"DSAyy/graph/#how_8","title":"How?","text":"<p>If the graph can be topo sorted, it has no cycles.</p> <p>Topo sort is just bfs but</p> <p>compute indegree of all nodes</p> <p>nodes with indegree 0 go to queue</p> <p>while queue is not empty,</p> <p>increment processed for front node</p> <p>decrease indegree of all neighbors, and if 0, add to queue</p> <p>if processed count is not the same as A, cycle exists</p> <pre><code>from collections import defaultdict, deque\ndef hasCycle(A,B):\n    adj = defaultdict(list)\n    indegree = [0]*(A+1)\n    for u,v in B:\n        adj[u].append(v)\n        indegree[v] += 1\n    q = deque()\n    processed = 0\n    for i in range(1,A+1):\n        if indegree[i] == 0:\n            q.append(i)\n    while q:\n        u = q.popleft()\n        processed += 1\n        for v in adj[u]:\n            indegree[v] -= 1\n            if indegree[v] == 0:\n                q.append(v)\n    return processed != A\n</code></pre>"},{"location":"DSAyy/graph/#delete-edge","title":"Delete Edge!","text":"<p>Given rooted undirected tree with N nodes and arr A having weight of each node. Delete one node such that the product of the sum of weights of the two resulting subtrees is maximised.</p> <p>Example:</p> <p>A = 10 5 12 6</p> <p>B = (1,2) (1,4) (4,3)</p> <p>Output = 270</p> <p>Removing (1,4): output = 15 \\(\\times\\) 18 = 270</p>"},{"location":"DSAyy/graph/#how_9","title":"How","text":"<p>Post order dfs to compute subtree sum at each node for every edge, compute: $$ \\text{Product = Sum of Subtree} \\times (\\text{Total Sum - Sum of Subtree}) $$ <pre><code>from collections import defaultdict\nMOD = 10**9 + 7\n\ndef mxDelEdge(A,B):\n    adj = defaultdict(list)\n    for u,v in B:\n        adj[u].append(v)\n        adj[v].append(u)\n    n = len(A)\n    weights = [0]+A\n    totalSum = sum(weights)\n    maxProd = 0\n    subtreeSum = [0]*(n+1)\n    def dfs(u,parent):\n        nonlocal maxProd\n        subtreeSum[u] = weights[u]\n        for v in adj[u]:\n            if v != parent:\n                dfs(v,u)\n                subtreeSum[u] += subtreeSum[v]\n        prod = subtreeSum[u]*(totalSum - subtreeSum[u])\n        maxProd = max(maxProd,prod)\n    dfs(1,-1)\n    return maxProd % MOD\n</code></pre></p>"},{"location":"DSAyy/graph/#two-teams-if-graph-is-bipartite","title":"Two Teams? (if graph is bipartite)","text":"<p>A people, 1 to A. Divide them into two teams. Given list B of \\(M\\times 2\\) having edges. Person u and v are enemies and cant be on the same team. Determine if its possible to divide them into two teams.</p> <p>A = 5</p> <p>B = (1,2) (2,3) (1,5) (2,4)</p> <p>Output: 1 (Yes)</p>"},{"location":"DSAyy/graph/#how_10","title":"How","text":"<p>Bipartite Coloring kar, if not possible then ret 0</p> <p>BFS to traverse path</p> <p>Assign opp colors to the neighbors</p> <p>If adj nodes have same color, ret 0</p> <p>check all connected components</p> <pre><code>from collections import deque, defaultdict\ndef twoTeamsPossible(A,B):\n    adj = defaultdict(list)\n    for u,v in B:\n        adj[u].append(v)\n        adj[v].append(u)\n    color = [0]*(A+1)\n    q = deque()\n    for i in range(1,A+1):\n        if color[i]: continue # Already processed\n        color[i] = 1\n        q.append(i)\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if color[v] == 0:\n                    color[v] = -color[u]\n                    q.append(v)\n                elif color[v] == color[u]:\n                    return 0\n    return 1\n</code></pre>"},{"location":"DSAyy/graph/#valid-path","title":"Valid Path","text":"<p>Grid of size \\(x \\times y\\) and N circular obstacles of radius R centered inside the grid. Determine if its to go from (0,0) to (x,y) without touching any circular region.</p> <p>Movement:</p> <p>8D including the diagonals</p> <p>Cannot go outside grid boundaries (chutiya hai kya)</p> <p>Cannot step into a cell that intersects any circle</p> <p>Note: a circle blocks a cell (i,j) if the dist from the centre is less than or equal to R</p> <p>Example:</p> <p>x = 2, y= 3, N = 1, R = 1, A = (2), B = (3) Output? No. Circle at (2,3) blocks the path to dest</p>"},{"location":"DSAyy/graph/#how_11","title":"How","text":"<p>Preprocess Blocked Cells</p> <p>$$ (x-a)^2 + (y-b)^2 \\leq R^2 $$ Check this for every cell</p> <p>Perform BFS from 0,0 and check if any one reaches x,y</p> <pre><code>from collections import deque\ndef validPath(x,y,N,R,A,B):\n    blocked = [[False]*(y) for _ in range(x)]\n    center= []\n    for i in range(N):\n        center.append((A[i],B[i]))\n    for i in range(x):\n        for j in range(y):\n            for a,b in center:\n                if (i-a)**2 + (j-b)**2 &lt;= R**2:\n                    blocked[i][j] = True\n    if blocked[0][0] or blocked[x][y]:\n        return 0\n    q = deque()\n    q.append((0,0))\n    visited = [[False]*(y) for _ in range(x)]\n    dir = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),         (0, 1),\n                  (1, -1),  (1, 0),  (1, 1)]\n    while q:\n        i,j = q.popleft()\n        if (i,j) == (x,y): return 1\n        for dx,dy in dir:\n            nx = i+dx, ny= j+dy\n            if 0 &lt;= nx &lt;= x and 0 &lt;= ny &lt;= y:\n                if not blocked[nx][ny] and not visited[nx][ny]:\n                    visited[nx][ny] = 1\n                    q.append((nx,ny))\n    return 0\n</code></pre>"},{"location":"DSAyy/graph/#region-in-binary-matrix","title":"Region in binary matrix","text":"<p>Given binary matrix \\(N \\times M\\) . Each cell is either 1 (filled) or 0 (not).</p> <p>Region is formed by one or more connected components in 8D.</p> <p>Return the size of the largest connected component.</p> <p>Example</p> <p>A = 0 0 1 1 0     1 0 1 1 0     0 1 0 0 0     0 0 0 0 1 Ans : 6</p>"},{"location":"DSAyy/graph/#how_12","title":"How","text":"<p>Simple bfs from every unvisited cell and counting all reachable cells and marking them visited.</p> <pre><code>from collections import deque\ndef largestRegion(A):\n    n,m = len(A), len(A[0])\n    maxRegion = 0\n    seen = [[False]*(m) for _ in range(n)]\n    dir = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),         (0, 1),\n                  (1, -1),  (1, 0),  (1, 1)]\n\n    for i in range(n):\n        for j in range(m):\n            if not seen[i][j] and A[i][j]:\n                regionSize = 0\n                q = deque()\n                q.append((i,j))\n                seen[i][j] = 1\n                while q:\n                    x,y = q.popleft()\n                    regionSize += 1\n                    for dx,dy in dir:\n                        nx,ny = x + dx , y + dy\n                        if 0 &lt;= nx &lt; n and 0 &lt;= ny &lt; m:\n                            if not seen[nx][ny] and A[nx][ny]:\n                                seen[nx][ny] = 1\n                                q.append((nx,ny))\n                maxRegion = max(maxRegion,regionSize)\n    return maxRegion                        \n</code></pre>"},{"location":"DSAyy/graph/#path-in-matrix","title":"Path in Matrix","text":"<p>\\(N \\times M\\) matrix where 0 -&gt; wall (cant move), 1 -&gt; source, 2 -&gt; dest, 3 -&gt; blank (can move through)</p> <p>4D movement. Check if path exists from source to destination</p>"},{"location":"DSAyy/graph/#how_13","title":"How","text":"<p>BFS and explore the matrix and find the path.</p> <pre><code>from collections import deque\ndef checkPath(A):\n    n,m = len(A), len(A[0])\n    source,dest = (-1,-1),(-1,-1)\n    for i in range(n):\n        for j in range(m):\n            if A[i][j] == 1:\n                source = (i,j)\n            elif A[i][j] == 2:\n                dest = (i,j)\n    if source == (-1,-1) or dest == (-1,-1):\n        return 0\n    q = deque()\n    visited = [[False]*(m) for _ in range(n)]\n    q.append(source)\n    visited[source[0]][source[1]] = 1\n    dirs = [[1,0],[-1,0], [0,1], [0,-1]]\n    while q:\n        cur = q.popleft()\n        if cur == dest: return 1\n        i,j = cur\n        for dx,dy in dir:\n            x,y = i+dx, j+dy\n            if 0&lt;= x &lt; n and 0 &lt;= y &lt; m:\n                if not visited[x][y] or A[x][y] != 0:\n                    visited[x][y] = 1\n                    q.append((x,y))\n    return 0\n</code></pre>"},{"location":"DSAyy/graph/#level-order-traversal-of-binary-tree","title":"Level Order Traversal of Binary Tree","text":"<p>Given binary tree, return its level order traversal as 2D array. Level order is visiting nodes level by level starting from root</p>"},{"location":"DSAyy/graph/#how_14","title":"How","text":"<p>BFS. <pre><code>from collections import deque\ndef levelOrder(root):\n    if not root: return []\n    q = deque()\n    q.append(root)\n    result = []\n    while q:\n        levelSize = len(q)\n        level = []\n        for i in range(levelSize):\n            node = q.popleft()\n            level.append(node)\n            if node.left: q.append(node.left)\n            if node.right: q.append(node.right)\n        result.append(level)\n    return result\n</code></pre></p>"},{"location":"DSAyy/graph/#smallest-multiple-with-0-and-1","title":"Smallest multiple with 0 and 1","text":"<p>Given a pos int A, find smallest mult of A such that it only consists of 0 or 1. Output the num as string.</p> <p>Example, A = 55, ans = 110. </p>"},{"location":"DSAyy/graph/#how_15","title":"How","text":"<p>Shortest path search, each node is a remainder mod A.</p> <p>Edge are like adding 0 or 1 to current number</p> <p>start from <code>1</code></p> <p>for \\(d \\in {0,1}\\) : \\(newRem = (r\\times 10 + d) mod \\space A\\) Track parent and digit to reconstruct once we reach remainder 0.</p> <pre><code>from collections import deque\n\ndef multiple(A):\n    if A == 0:\n        return \"0\"\n\n    q = deque()\n    parent = [-1] * A\n    digit = [''] * A\n    visited = [False] * A\n\n    rem = 1 % A\n    visited[rem] = True\n    digit[rem] = '1'\n    q.append(rem)\n\n    while q:\n        r = q.popleft()\n        if r == 0:\n            break\n\n        for d in ['0', '1']:\n            newRem = (r * 10 + int(d)) % A\n            if not visited[newRem]:\n                visited[newRem] = True\n                parent[newRem] = r\n                digit[newRem] = d\n                q.append(newRem)\n\n    # Reconstruct the answer from remainder 0\n    rem = 0\n    result = []\n    while rem != -1:\n        result.append(digit[rem])\n        rem = parent[rem]\n\n    return ''.join(reversed(result))\n</code></pre>"},{"location":"DSAyy/graph/#snake-ladder-problem","title":"Snake Ladder Problem","text":"<p>Given a \\(10 \\times 10\\) snake ladder board, numbered from 1  to 100 with list of <code>N</code> ladders, each ladder is a pair <code>(u,v)</code> indicating a move from <code>u</code> to <code>v</code> (u &lt; v)</p> <p>A list of M snakes <code>(u,v)</code> where it moves from <code>v</code> to <code>u</code></p> <p>Find the min dice rolls, to reach from square <code>1</code> to square <code>100</code></p> <p>Rule: if you land on a ladder or a snake, you have to take it. (note no overlaps in ladder and snakes)</p>"},{"location":"DSAyy/graph/#how_16","title":"How?","text":"<p>BFS, node (1,100) where</p> <p>each node has edge to atmost 6 next nodes (dice roll)</p> <p>each edge leads to a destination after taking ladder or snake</p> <p>BFS, track min dice rolls to reach each square. Try all values of dice roll at each edge.</p> <pre><code>def snakeLadder(A,B):\n    jumps = [i for i in range(1,101)]\n    for u,v in A:\n        jump[u] = v\n    for u,v in B:\n        jump[v] = u\n    visited = [False]*(101)\n    q = deque()\n    visited[1] = 1\n    q.push((1,0)) # square , roll count\n    while q:\n        sq,rolls = q.popleft()\n        if sq == 100:\n            return rolls\n        for d in range(1,7):\n            nxt = sq + d\n            if nxt &gt; 100: break\n            nxt = jump[nxt]\n            if not visited[nxt]:\n                visited[nxt] = 1\n                q.append((nxt,rolls + 1))\n    return -1\n</code></pre>"},{"location":"DSAyy/graph/#min-cost-path","title":"Min Cost Path","text":"<p>Given matrix <code>C</code> of \\(A \\times B\\) where each cell has <code>U</code>, <code>D</code>, <code>L</code>, <code>R</code> Start from <code>0,0</code> and reach <code>A-1,B-1</code></p> <p>Rules:</p> <p>Following the dir on the current cell, move costs <code>0</code></p> <p>if you move in diff direction, it costs <code>1</code></p> <p>return min total cost to reach the destination</p> <p>Example:</p> <p>C = RRR     DDD     UUU Output = 1</p>"},{"location":"DSAyy/graph/#how_17","title":"How?","text":"<p>New Topic: (0-1) BFS</p> <p>If you move in the given dir, it costs <code>0</code>. (enqueue it at front)</p> <p>if you move in other dir, it costs <code>1</code> (enqueue it at the back)</p> <p>Simple deque bfs that always prefers lower cost</p> <pre><code>def minCost(A,B,C):\n    if A == 1 and B == 1: return 0\n    INF = 10**9\n    dist = [[INF]*(B) for _ in range(A)]\n    dist[0][0] = 0\n    q = deque()\n    q.append((0,0))\n    dir = {'U': (-1,0),'D': (1,0), 'L': (0,-1),'R': (0,1)}\n    while q:\n        i,j = q.popleft()\n        curCost = dist[i][j]\n        for d in ['U','D','L','R']:\n            dx,dy = dir[d]\n            x,y = i + dx, j + dy\n            if not (0 &lt;= x &lt; A and 0 &lt;= y &lt; B): continue\n            cost = 0 if C[x][y] == d else 1\n            if curCost + cost &lt; dist[x][y]:\n                dist[x][y] = curCost + cost\n                if cost == 0: q.appendleft((x,y))\n                else: q.append((x,y))\n    return dist[A-1][B-1]\n</code></pre>"},{"location":"DSAyy/graph/#permutation-swaps","title":"Permutation Swaps","text":"<p>Given two perm A and B of int from 1 to N, and list of M good pairs C. good pair \\((i,j)\\) meaning you can swap those \\((A[i],A[j])\\) as many times.</p> <p>Find if its possible to transform A into B.</p> <p>Example:</p> <p>A = 1 3 2 4 B = 1 4 2 3 C = (2,4)</p> <p>Output = Yes</p>"},{"location":"DSAyy/graph/#how_18","title":"How","text":"<p>DSU babyyy</p> <p>Build DSU from good pairs.</p> <p>In each component (group of indices), collect A and B at those indices</p> <p>Sort both subarrs. If the sorted val match, they can be rearranged.</p> <p>If any component mismatch, return 0</p> <pre><code>from collections import defaultdict\nclass DSU:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0]*n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    def unite(self,x,y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root == y_root:\n            return\n        if self.rank[x_root] &lt; self.rank[y_root]:\n            self.parent[x_root] = y_root\n        elif self.rank[y_root] &lt; self.rank[x_root]:\n            self.parent[y_root] = x_root\n        else:\n            self.parent[y_root] = x_root\n            self.rank[x_root] += 1\ndef can_transform(A,B,C):\n    if A== B:\n        return true\n    N = len(A)\n    dsu = DSU(N)\n    for u,v in C:\n        dsu.unite(u-1,v-1)\n    groups = defaultdict(list)\n    for i in range(N):\n        groups[dsu.find(i)].append(i)\n    for indices in groups.values():\n        a_vals = sorted([A[i] for i in indices])\n        b_vals = sorted([B[i] for i in indices])\n        if a_vals != b_vals:\n            return False\n    return True\n</code></pre>"},{"location":"DSAyy/graph/#commutable-islands-mst","title":"Commutable Islands (MST)","text":"<p>Given A islands and M bidirectional bridges.  Each bridge has a cost. Your goal is to find the min total cost to connect all islands such that all of them are in one component.</p> <p>A= num of islands, B = \\(M \\times 3\\) arr with weighted undirected edges</p> <p>Output: Minimum total cost</p> <p>A = 4 B = 1 2 1     2 3 4     1 4 3     4 3 2     1 3 10 Output = 6</p>"},{"location":"DSAyy/graph/#how_19","title":"How","text":"<p>Kruskals Algorithm for MST with DSU</p> <p>Sort all bridges by ascending cost.</p> <p>Use disjoint set union to maintain connected components</p> <p>Iteratively add A-1 lowest ccost bridges which connects two different components.</p> <pre><code>class DSU:\n    def __init__(self,n):\n        self.parent = list(range(n))\n        self.rank = [0]*n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    def unite(self,x,y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        if self.rank[xr] &lt; self.rank[yr]:\n            self.parent[xr] = yr\n        if self.rank[yr] &lt; self.rank[xr]:\n            self.parent[yr] = xr\n        else:\n            self.parent[yr] = xr\n            self.rank[xr] += 1\n        return True\ndef minCost(A,B):\n    B.sort(key = lambda x: x[2])\n    dsu = DSU(A)\n    total_cost = 0\n    edges_used = 0\n    for u,v in B:\n        if  dsu.unite(u-1,v-1):\n            total_cost += cost\n            edges_used += 1\n            if edges_used == A-1:\n                break\n    return total_cost\n</code></pre>"},{"location":"DSAyy/graph/#possibility-of-finishing-all-courses-cycles-in-directed-graph-toposort","title":"Possibility of Finishing all courses (Cycles in directed Graph, TopoSort)","text":"<p>Given A courses, 1 to A.  pair \\(B[i],C[i]\\) means to take course \\(C[i]\\) you have to take \\(B[i]\\) first Determine if its possible to finish all courses.</p> <p>Example: A = 3, B = 1 2          C = 2 3     Output = 1</p> <p>Take 1 then 2 then 3</p>"},{"location":"DSAyy/graph/#how_20","title":"How","text":"<p>Topological Sort using Kahn's Algorithm</p> <p>Let courses be nodes and \\(prereq(u,v)\\) be directed node from \\((u,v)\\)</p> <p>To check that the courses can be completed, we need to make sure it has no cycles.</p> <p>Construct adj, and indegrees</p> <p>Toposort using BFS</p> <p>If all nodes are visited at the end(no cycle), return 1, else 0</p> <pre><code>from collections import deque, defaultdict\ndef topoSort(A,B,C):\n    adj = defaultdict(list)\n    indeg = [0]*(A+1)\n    M = len(B)\n    for i in range(M):\n        adj[B[i]].append(C[i])\n        indegree[C[i]]+= 1\n    q = deque()\n    for i in range(1,A+1):\n        if indegree[i] == 0:\n            q.append(i)\n    processed = 0\n    while q:\n        u = q.popleft()\n        processed += 1\n        for v in adj[u]:\n            indegree[v]-= 1\n            if indegree[v] == 0:\n                q.append(v)\n    return processed == A\n</code></pre>"},{"location":"DSAyy/graph/#cycles-in-undirected-graph","title":"Cycles in undirected graph","text":"<p>A nodes from 1 to A. M edges represented in \\(M \\times 2\\) arr B, check whether graph has a cycle</p> <p>Return if a cycle exists</p>"},{"location":"DSAyy/graph/#how_21","title":"How?","text":"<p>DSU</p> <p>for each node (u,v), if they are already connected, adding this edge would create a cycle.</p> <pre><code>class DSU:\n    def __init__(self,n):\n        self.parent = list(range(n))\n        self.rank = [0]*n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    def unite(self,x,y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        if self.rank[xr] &lt; self.rank[yr]:\n            self.parent[xr] = yr\n        elif self.rank[yr] &lt; self.rank[xr]:\n            self.parent[yr] = xr\n        else:\n            self.parent[yr] = xr\n            self.rank[xr] += 1\n        return True\ndef cycleExists(A,B):\n    dsu = DSU(A)\n    for u,v in B:\n        if not unite(u,v):\n            return 1\n    return 0\n</code></pre>"},{"location":"DSAyy/graph/#mother-vertex","title":"Mother Vertex","text":"<p>A vertices 1 to A, M directed edges given in a \\(M \\times 2\\) matrix B. Determine whether there is a mother.  Mother is a vertex from which all the vertices are reachable.</p> <p>Output boolean</p>"},{"location":"DSAyy/graph/#how_22","title":"How","text":"<p>Candidate find: perform dfs, keep track of vertex with max finishing time. Then waha se verify by running a dfs and checking is all are visited.</p> <pre><code>from collections import defaultdict\n\ndef motherVertex(A,B):\n    adj = defaultdict(list)\n    for u,v in B:\n        adj[u].append(v)\n    visited = [False]*(A+1)\n    candidate = 1\n    def dfs(u):\n        visited[u] = True\n        for v in adj[u]:\n            if not visited[v]:\n                dfs(v)\n    for i in range(1,n+1):\n        if not visited[i]:\n            dfs(i)\n            candidate = i\n    visited = [False]*(A+1)\n    dfs(candidate)\n    for i in range(1,A+1):\n        if not visited[i]:\n            return 0\n    return 1\n</code></pre>"},{"location":"DSAyy/graph/#file-search","title":"File Search","text":"<p>Organise records into sets. Each record is a pair (<code>ID</code>, <code>parentID</code>). If a record <code>(X,Y)</code> exists, then both <code>X</code> and <code>Y</code> belong to the same set.  Find max number of sets into which the records can be partitioned, such that the condition holds.</p>"},{"location":"DSAyy/graph/#how_23","title":"How","text":"<p>Just DSU and return the number of disjoint sets.</p> <pre><code>class DSU:\n    def __init__(self,n):\n        self.parent = list(range(n))\n        self.rank = [0]*(n)\n    def find(self,x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    def unite(self,x,y):\n        rx,ry = self.find(x), self.find(y)\n        if rx == ry:\n            return False\n        if self.rank[rx] &lt; self.rank[ry]:\n            self.parent[rx] = ry\n        elif self.rank[ry] &lt; self.rank[rx]:\n            self.parent[ry] = rx\n        else:\n            self.parent[ry] = rx\n            self.rank[rx] += 1\ndef fileSearch(A,B):\n    dsu = DSU(A)\n    for u,v in B:\n        dsu.unite(u,v)\n    groups = set()\n    for i in range(A+1):\n        groups.insert(dsu.find(i))\n    return len(groups)\n</code></pre>"},{"location":"DSAyy/graph/#black-shapes","title":"Black Shapes","text":"<p>Given a grid A, having char <code>O</code> (white cells) and <code>X</code> black cells. Count the number of black shapes in the grid.  Black shape is just the connected component of black cells.</p>"},{"location":"DSAyy/graph/#how_24","title":"How","text":"<p>Just count components using BFS</p> <pre><code>from collections import deque\ndef blackShapes(A):\n    if not A: return 0\n    n, m = len(A), len(A[0])\n    dirs = [[1,0],[-1,0], [0,1], [0,-1]]\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if A[i][j] == 'X':\n                count += 1\n                q = deque()\n                q.append((i,j))\n                A[i][j] = 'O'\n                while q:\n                    x,y = q.popleft()\n                    for dx,dy in dirs:\n                        a,b = x + dx, y + dy\n                        if 0 &lt;= a &lt; n and 0 &lt;= b &lt; m:\n                            if A[a][b] == 'X':\n                                A[a][b] = 'O'\n                                q.append((a,b))\n    return count\n</code></pre>"},{"location":"DSAyy/graph/#convert-sorted-list-to-binary-tree","title":"Convert Sorted List to Binary Tree","text":"<p>Given a linked list, where elements are in ascending order, convert it into a height balanced BST.</p> <p>Height balanced maane depth of two subtrees of a node does not differ by more than 1</p>"},{"location":"DSAyy/graph/#how_25","title":"How","text":"<p>Simulate \\(in-order\\) traversal over the BST and advance the LL pointer in parallel</p> <p>Count the length of linked list: n</p> <p>Recursively build the BST using a helper function with start and end indices.</p> <p>The function constructs left subtree first, then creates root using the current list node, then constructs the right subtree.</p> <pre><code>class ListNode:\n    def __init__(self, val = 0, next = None):\n        self.val = val\n        self.next = next\nclass TreeNode:\n    def __init__(self,val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef sortedListToBST(head: ListNode) -&gt; TreeNode:\n    # get length of LL\n    def getLength(node):\n        count = 0\n        while node:\n            count += 1\n            node =node.next\n        return count\n    n = get_length(head)\n    current = head\n    # Recursively build BST\n    def build_BST(start,end):\n        nonlocal current\n        if start &gt; end: return None\n        mid = (start + end) // 2\n        left= build_BST(start,mid - 1)\n        root = TreeNode(current.val)\n        root.left = left\n        current = current.next\n        root.right = build_BST(mid + 1,end)\n        return root\n    return build_BST(0,n-1)\n</code></pre>"},{"location":"DSAyy/graph/#sum-of-fibonacci-numbers","title":"Sum of Fibonacci Numbers","text":"<p>Given a pos int <code>A</code>, return min num of fibonacci numbers such that their sum is <code>A</code>. Repetition of numbers is allowed.</p> <p>Example</p> <p>A = 4, Output = 2 (2 + 2) A = 7, Output = 2 (5 + 2)</p>"},{"location":"DSAyy/graph/#how_26","title":"How","text":"<p>Generate all fibonacci numbers \\(\\leq\\) A.</p> <p>Repeatedly subtract largest fibonacci number \\(\\leq\\) remaining value.</p> <p>Count steps until <code>A</code> = 0</p> <p>This works due to Zeckendorf's Theorem that every number can be represented as the sum of non consecutive fibonacci numbers. </p> <pre><code>import bisect\ndef fibSum(A):\n    fib = [1,1]\n    while True:\n        nxt = fib[:-1] + fib[:-2]\n        if nxt &gt; A: break\n        fib.append(nxt)\n    # greedy subtraction\n    count = 0\n    while A &gt; 0:\n        idx = bisect.bisect_right(fib,A) # bisect right = upper bound\n        A -= fib[idx]\n        count += 1\n    return count\n</code></pre>"},{"location":"DSAyy/graph/#knight-on-chess-board","title":"Knight on chess board","text":"<p>Given a chessboard of size \\(A \\times B\\), a knight starts at pos \\((C,D)\\) and wants to reach pos \\((E,F)\\). Find min num of moves to reach the destination. If not pos, return -1</p>"},{"location":"DSAyy/graph/#how_27","title":"How","text":"<p>Its simple bfs idk bro</p> <pre><code>from collections import deque\ndef knight(A,B,C,D,E,F):\n    if C == E and D == F: return 0\n    dirs = [[2,1],[2,-1],[-2,1], [-2,-1], [1,2],[1,-2],[-1,2], [-1,-2]]\n    visited = [[False]*(B+1) for _ in range(A+1)]\n    q = deque((C,D,0))\n    visited[C][D] = 1\n    while q:\n        x,y,dist = q.popleft()\n        for dx,dy in dirs:\n            i,j = x + dx, y+dy\n            if 1 &lt;= i &lt;= A and 1 &lt;= j  &lt;= B and not visited[i][j]:\n                if (i,j) == (E,F):\n                    return dist + 1\n                visited[i][j] = 1\n                q.append((i,j,dist+1))\n    return -1\n</code></pre>"},{"location":"DSAyy/graph/#useful-extra-edges","title":"Useful Extra Edges","text":"<p>A Nodes, undirected weighted edges \\(B[i] = [u,v,w]\\) .</p> <p>Given source C and dest D. List of extra edges \\(E[j] = [u,v,w]\\)  You are allowed to add atmost one extra edge from E.</p> <p>Return the shortest path length from C to D. If no such path, return -1.</p>"},{"location":"DSAyy/graph/#how_28","title":"How","text":"<p>Run dijkstra from source, and compute <code>distFromC[x]</code> </p> <p>Run dijkstra from destination, and compute distFromD[x]</p> <p>let \\(best = distFromC[D]\\)  For each extra edge (u,v,w) $$ minpath = min(distFromC[u] + w + distFromD[v], distFromC[v] + w + distFromD[u]) $$ Update the best dist if a shorter path is found.</p> <pre><code>import heapq\nfrom collections import defaultdict\ndef dijkstra(start, graph, A):\n    dist = [float('inf')*(A+1)]\n    dist[start] = 0\n    pq = [(0, start)]\n    while pq:\n        d,u = heapq.heappop(pq)\n        if d &gt; dist[u]:\n            continue\n        for v,w in graph[u]:\n            if dist[u] + w &lt; dist[v]:\n                dist[v] = dist[u] + w\n                heapq.heappush(pq,(dist[v],v))\n    return dist\ndef shortest_path_with_extra_edge(A,B,C,D,E):\n    graph = defaultdict(list)\n    for u,v,w in B:\n        graph[u].append((v,w))\n        graph[v].append((u,w)) \n    distFromC = dijkstra(C,graph,A)\n    distFromD = dijkstra(D,graph,A)\n    best = distFromC[D]\n    for u,v,w in E:\n        if distFromC[u] + w + distFromD[v] &lt; best:\n            best = distFromC[u] + w + distFromD[v]\n        if distFromC[v] + w + distFromD[u] &lt; best:\n            best = distFromC[v] + w + distFromD[u]\n    return best if best != float('inf') else -1\n</code></pre>"},{"location":"DSAyy/graph/#word-ladder-i","title":"Word Ladder I","text":"<p>Given two words <code>A</code> and <code>B</code>. Find shortest transformation from A to B where one letter can be changed at a time. The transformed word must be in the dictionary C.</p> <p>Return num of words in the shortest path. Return 0 if no such path exists.</p>"},{"location":"DSAyy/graph/#how_29","title":"How","text":"<p>BFS. </p> <p>Add all dict words in a set for \\(O(1)\\) lookup</p> <p>BFS starting from A. Each level of BFS represents one transformation.</p> <p>For each word, try single letter mutations and push valid transformations into queue.</p> <p>Stop when you reach B.</p> <pre><code>from collections import deque\ndef wordLadder(A,B,C):\n    if A == B: return 1\n    word_set = set(C)\n    if B not in word_set:\n        return 0\n    queue = deque([(A,1)])\n    visited = set([A])\n    L = len(A)\n    while queue:\n        word, steps = queue.popleft()\n        for i in range(L):\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                if word[i] == c:\n                    continue\n                nxt_word = word[:i] + c + word[i+1:]\n                if nxt_word == B:\n                    return steps + 1\n                if nxt_word in word_set and nxt_word not in visited:\n                    visited.add(nxt_word)\n                    queue.append((nxt_word,steps + 1))\n    return 0\n</code></pre>"},{"location":"DSAyy/graph/#word-ladder-ii","title":"Word Ladder II","text":"<p>Given two words, \\(start\\) and \\(end\\) , and a dict of words C, return all shortest transformation sequences from start to end with the same rules as Word Ladder I</p> <p>Example</p> <p>start = hit, end = cog, dict = hot dot dog lot log</p> <p>Output : hit hot dot dog cog</p> <p>hit hot lot log cog</p>"},{"location":"DSAyy/graph/#how_30","title":"How","text":"<p>Advanced BFS tbh</p> <p>Track all words at each level, and remove them once fully processed.  Just keep storing the traversals at each level.</p> <pre><code>from collections import deque, collections\ndef word_ladder_ii(beginWord, endWord, wordList):\n    wordSet = set(wordList)\n    if endWord not in wordSet:\n        return []\n\n    level = {beginWord}\n    parents = defautdict(set)\n    found = False\n\n    while level and not found:\n        next_level = defaultdict(set)\n        for word in level:\n            wordSet.discard(word)\n        for word in level:\n            for i in range(len(word)):\n                for c in range 'abcdefghijklmnopqrstuvwxyz':\n                    newWord = word[:i] + c + word[i+1:]\n                    if newWord in wordSet:\n                        next_level[newWord].add(word)\n                        if newWord == endWord:\n                            found = True\n        level = next_level\n        for child, parSet in next_level.items():\n            parents[child].update(parSet)\n    # back track to get the solution\n    res = []\n    def backtrack(word, path):\n        if word == beginWord:\n            res.append([beginWord] + path[::-1])\n            return\n        for par in parents[word]:\n            backtrack(par, path + [word])\n    if found:\n        backtrack(endWord,[])\n    return res\n</code></pre>"},{"location":"DSAyy/graph/#clone-graph","title":"Clone Graph","text":"<p>Clone an undirected graph.</p> <p>Each node in the graph contains a label and a list of its neighbors.</p> <p>Given pointer to the node in the graph, return a deep copy.</p>"},{"location":"DSAyy/graph/#how_31","title":"How","text":"<p>BFS traversal while cloning each node and its neigbors.</p> <p>Use a hash map to maintain the mapping from orignal node to its clone</p> <p>For each node visited, clone it, and clone its neighbors and link them</p> <p>Return the cloned version of the original starting node.</p> <pre><code>from collections import deque\n\nclass Node:\n    def __init__(self, val, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\ndef cloneGraph(node):\n    if not node:\n        return None\n    # map the starting node\n    clones = {node : Node(node.val)}\n\n    queue = deque([node])\n\n    while queue:\n        current = queue.popleft()\n        for neighbor in current.neighbors:\n            if neighbor not in clones:\n                clones[neighbor] = Node(neighbor.val)\n                queue.append(neighbor)\n            clones[current].neighbors.append(clones[neighbor])\n    return clones[node]\n</code></pre>"},{"location":"DSAyy/hashing/","title":"Hashing","text":""},{"location":"DSAyy/hashing/#colorful-numbers","title":"Colorful Numbers","text":"<p>Given an int A, determine whether its colorful or not.</p> <p>Number if colorful if product of digits of every contiguous subsequence is unique.</p>"},{"location":"DSAyy/hashing/#how","title":"How??","text":"<p>Slide a window of size k over the digits and multiply as you go. If two windows ever yield the same product, the number is not colorful.</p> <pre><code>def is_colorful(A):\n    digits = [int(d) for d in str(A)]\n    seen = set()\n    for i in range(len(digits)):\n        prod = 1\n        for j in range(i,len(digits)):\n            prod *= digits[j]\n            if prod in seen:\n                return 0\n            seen.add(prod)\n    return 1\n</code></pre>"},{"location":"DSAyy/hashing/#largest-continuous-sequence-zero-sum","title":"Largest Continuous Sequence Zero Sum","text":"<p>Given an \\(int\\) array, find the longest contiguous subarray whose elements sum to zero. If multiple exist, return the one that appears first.</p>"},{"location":"DSAyy/hashing/#how_1","title":"How","text":"<p>Compute the prefix sum, and store the first index where each sum occurs in a hash map. Whenever the same sum reappears at index \\(j\\), the subarr \\((firstIdx  + 1) .. j\\) sums to zero.</p> <p>Track the maximum length.</p> <pre><code>def longest_zero_sum_subarray(A):\n    first_occ = {0: -1}\n    total, best_len, best_start = 0,0,0\n    for i in range(len(A)):\n        total += A[i]\n        if total in first_occ:\n            length = i - first_occ[total]\n            if length &gt; best_len:\n                best_len = length\n                best_start = first_occ[total] + 1\n        else:\n            first_occ[total] = i\n    return A[best_start:best_start + best_len]\n</code></pre>"},{"location":"DSAyy/hashing/#longest-subarray-length","title":"Longest Subarray Length","text":"<p>Given a binary array, find the length of the longest contiguous subarray in which the number of 1's is exactly one more than number of 0's.</p>"},{"location":"DSAyy/hashing/#how_2","title":"How","text":"<p>Treat each 1 as +1, and each 0 as -1. Compute the prefix sum.</p> <p>Subarray \\([j+1...i]\\) has \\(cnt(1) - cnt(0) = 1\\) when \\(S[i] - S[j] = 1\\), or \\(S[j] = S[i] - 1\\)</p> <p>Store in a hash_map the earliest index where each prefix sum occurs. At every index, look for \\(S[i] - 1\\) to extend the longest valid segment ending at i.</p> <pre><code>def longest_subarray_len(A):\n    first_occ = {0: -1}\n    total = 0\n    max_len = 0\n    for i in range(len(A)):\n        total += 1 if A[i] == 1 else -1\n        if (total - 1) in first_occ:\n            max_len = max(max_len, i - first_occ[total - 1])\n        if total not in first_occ:\n            first_occ[total] = i\n    return max_len\n</code></pre>"},{"location":"DSAyy/hashing/#first-repeating-element","title":"First Repeating Element.","text":"<p>Find the first repeating element in an array.</p> <pre><code>def first_repeating(A):\n    seen = set()\n    candidate = None #will hold the left-most repeating value\n    #scan right to left\n    for x in reversed(A):\n        if x in seen:\n            candidate =x\n        else:\n            seen.add(x)\n    return candidate if candidate is not None else -1\n</code></pre>"},{"location":"DSAyy/hashing/#two-sum","title":"Two Sum","text":"<p>Given an int array, and a target B, find two distinct elements whose sum is \\(B\\). Return their 1-based indexes, \\(i &lt; j\\).  If multiple exists, choose the pair with the smallest \\(j\\): if tied, smallest i.  Nahi mila toh return empty list.</p> <pre><code>def two_sum(A,B):\n    first_pos = {}\n    for j in range(len(A)):\n        want = B - A[j]\n        if want in first_pos:\n            return [first_pos[want] + 1, j+1]\n        if A[j] not in first_pos:\n            first_pos[A[j]] = j\n    return []\n</code></pre>"},{"location":"DSAyy/hashing/#4-sum","title":"4 Sum","text":"<p>Given an int array, and a target B. Find all unique quadruplets \\((a,b,c,d)\\) in A such that \\(a + b + c + d = B\\), where \\(a \\leq b \\leq c \\leq d\\).</p> <p>Return the list in lex order without duplicates.</p> <p>Sort arr, two nested loops, remaining use two pointer.</p> <pre><code>def fourSum(A,B):\n    A.sort()\n    A = len(A)\n    res = []\n    for i in range(n-3):\n        if i &gt; 0 and A[i] == A[i-1]:\n            continue\n        for j in range(i+1,n-2):\n            if j &gt; i+1 and A[j] == A[j-1]:\n                continue\n            left,right = j+1,n-1\n            while left &lt; right:\n                total = A[i] + A[j] + A[left] + A[right]\n                if total == target:\n                    res.append(A[i],A[j],A[left], A[right])\n                    while left &lt; right and A[left] == A[left + 1]:\n                        left += 1\n                    while left &lt; right and A[right] == A[right-1]:\n                        right -= 1\n                    left += 1\n                    right -=1\n                elif total &lt; target:\n                    left += 1\n                else: right -=1\n    return res\n</code></pre>"},{"location":"DSAyy/hashing/#valid-sudoku","title":"Valid Sudoku","text":"<p>Given a 9 \\times 9 sudoku board filled with digits from <code>1</code> to <code>9</code>, and empty cells as <code>.</code>. Determine if the filled cells form a valid sudoku.</p> <p>Just no row and col duplicates, and each \\(3 \\times 3\\) sub box has no duplicate digits.</p>"},{"location":"DSAyy/hashing/#how_3","title":"How","text":"<p>\\(3 \\times 3\\) boxes can be tracked using bitmasks. Same for rows and cols.</p> <p>Boxes can be indexed as \\(b = 3 \\times (i/3) + (j/3)\\).</p> <pre><code>def is_valid_sudoku(A):\n    rows,cols,boxes = [0]*9,[0]*9,[0]*9\n    for i in range(9):\n        for j in range(9):\n            c = A[i][j]\n            if c == '.':\n                continue\n            d = int(c) -1 #convert 1-9 to 0-8\n            mask = 1 &lt;&lt; d\n            b = 3*(i//3) + (j//3)\n            if rows[i] &amp; mask or cols[j] &amp; mask or boxes[i] &amp; mask:\n                return 0\n            rows[i] |= mask\n            cols[j] |= mask\n            boxes[b] |= mask\n    return mask\n</code></pre>"},{"location":"DSAyy/hashing/#diffk-ii","title":"Diffk II","text":"<p>Given an int arr, and a int B, find if there are two distinct indices i and j, such that \\(A[i] - A[j] = B\\).</p> <p>Return 1 if such a pair exists, otherwise 0.</p>"},{"location":"DSAyy/hashing/#how_4","title":"How","text":"<p>For every x in A:  Just check in the hashset if you have seen \\(x+B\\) or \\(x-B\\)</p> <pre><code>def diffk(A,B):\n    seen = set()\n    for x in A:\n        if (x+B) in seen or (x-B) in seen:\n            return 1\n        seen.insert(x)\n    return 0\n</code></pre>"},{"location":"DSAyy/hashing/#pairs-with-given-xor","title":"Pairs with given XOR.","text":"<p>Given an int arr, and int B, count the unique pairs \\((x,y)\\) in A such that \\(x \\oplus y = B\\) </p> <pre><code>def count_pairs_xor(A,B):\n    s = set(A)\n    count = 0\n    for x in A:\n        y = x^B\n        if y in S and x &lt; y:\n            count += 1\n    return count\n</code></pre>"},{"location":"DSAyy/hashing/#anagrams","title":"Anagrams","text":"<p>Given an array of lowercase strings, return all groups of anagrams. Represent the group by a list of 1-based indices in A. Within each group, maintain the original relative order of strings. Group themselves should be ordered by the first occurence of any member.</p>"},{"location":"DSAyy/hashing/#how_5","title":"How","text":"<p>Two strings are anagrams iff they ahve identical character counts.</p> <p>For each string, compute a signature encoding of its letter frequencies. Use hashmap from signature to list of idx. </p> <p>Track the order in which distinct signatures first appear to output groups in correct order.</p> <pre><code>def group_anagrams(A):\n    from collections import defaultdict\n    groups = defaultdict(list)\n    keys = []\n    for i,word in enumerate(A):\n        count = [0]*26\n        for c in word:\n            count[ord(c) - ord('a')] += 1\n        sig = tuple(count) #use tuple of count as signature\n        if sig not in groups:\n            keys.append(sig)\n        groups[sig].append(i+1) #store 1-based\n    result = []\n    for sig in keys:\n        result.append(groups[sig])\n    return result\n</code></pre>"},{"location":"DSAyy/hashing/#equal","title":"Equal","text":"<p>Given an int array, find indices a,b,c,d such that:  $$     A[a] + A[b] = A[c] + A[d] $$ and \\(a &lt; b\\space c &lt; d\\space a &lt; c \\space b \\neq c,\\space b \\neq d\\) Return the lexicographically smallest one.</p> <pre><code>def find_equal_quadruple(A):\n    first_pair = {}\n    best = []\n    n = len(A)\n    for i in range(n-1):\n        for j in range(i+1,n):\n            s = A[i] + A[j]\n            if s not in first_pair:\n                first_pair[s] = (i,j)\n            else:\n                p,q = first_pair[s]\n                if p &lt; i and q != i and q != j:\n                    cand = [p,q,i,j]\n                    if not best or cand &lt; best:\n                        best = cand\n    return best\n</code></pre>"},{"location":"DSAyy/hashing/#copy-list-with-random-pointer","title":"Copy List with Random Pointer","text":"<p>A singly LL with an extra random pointer (may be null or any node). Return a deep copy of the list. </p> <pre><code>class Node:\n    def __init__(self,label,next = None, random = None):\n        self.label = label\n        self.next = next\n        self.random = random\ndef copy_random_list(head):\n    if head is None:\n        return None\n    #interleave copied nodes with og nodes\n    cur = head\n    while cur:\n        copy = Node(cur.label)\n        copy.next = cur.next\n        cur.next = copy\n        cur = copy.next\n    #assign random pointers\n    cur = head\n    while cur:\n        if cur.random:\n            cur.next.random = cur.random.next\n        cur = cur.next.next\n    #separate og and copied nodes\n    pseudo_head = Node(0)\n    copy_iter = pseudo_head\n    cur = head\n\n    while cur:\n        copy = cur.next\n        cur.next = copy.next\n        copy_iter.next = copy\n        copy_iter = copy\n        cur = cur.next\n    return pseudo_head.next\n</code></pre>"},{"location":"DSAyy/hashing/#check-palindrome-possible","title":"Check palindrome possible","text":"<p>Given a lowercase string, check if it can be rearranged to form a palindrome.</p> <pre><code>def can_form_palindrome(A):\n    freq = [0]*26\n    for c in A:\n        freq[ord(c) - ord('a')] += 1\n    odd_count = 0\n    for count in freq:\n        if count % 2 == 1:\n            odd_count += 1\n            if odd_count &gt; 1:\n                return 0\n    return 1\n</code></pre>"},{"location":"DSAyy/hashing/#fraction-to-recurring-decimal","title":"Fraction to Recurring Decimal","text":"<p>Given two integers A and B (numerator and denominator), return their fraction in string form. If the decimal part is repeating, enclose the repeating sequence in parenthesis.</p> <pre><code>def fraction_to_decimal(A,B):\n    if A == 0:\n        return \"0\"\n    res = []\n    sign = \"-\" if (A &lt; 0) ^ (B &lt; 0) else \"\"\n    num,den = abs(A),abs(B)\n    q = num // den\n    res.append(str(q))\n    rem = num % den\n    if rem == 0:\n        return sign + \"\".join(res)\n    res.append(\".\")\n    seen = {}\n    while rem != 0:\n         if rem in seen:\n             pos = seen[rem]\n             rem.insert(pos, \"(\")\n             res.append(\")\")\n             break\n        seen[rem] = len(res)\n        rem *= 10\n        d = rem // den\n        res.append(str(d))\n        rem %= den\n    return sign + \"\".join(res)\n</code></pre>"},{"location":"DSAyy/hashing/#points-on-the-straight-line","title":"Points on the Straight Line","text":"<p>Given N points \\((A[i], B[i])\\) on the 2D plane, find maximum points that lie on the same straight line.</p>"},{"location":"DSAyy/hashing/#how_6","title":"How","text":"<p>The trick is to generate a unique slope key.</p> <p>For two points (\\(x_i,y_i\\)) and (\\(x_j,y_j\\)), let \\(dx = x_j - x_i\\) and \\(dy = y_j - y_i\\).</p> <p>If both dx and dy are zero, they coincide, otherwise compute \\(g = gcd(dy,dx)\\), and \\(dy<code>= \\frac{dy}{y}$ and $dx</code> = \\frac{dx}{y}\\) . Normalize the sign so that \\(dx`\\) is \\(\\geq 0\\) . Represent vertical lines as (1,0) and horizontal lines as (0,1). </p> <p>Now we use \\(dy<code>, dx</code>\\) pair as unique slope key.</p> <pre><code>from math import gcd\nfrom collections import defaultdict\ndef max_points_on_line(A,B):\n    n = len(A)\n    if n &lt; 2: return n\n    result = 1\n    for i in range(n):\n        slope_count = defaultdict(int)\n        duplicates = 1\n        local_max = 0\n        for j in range(i+1,n):\n            dx = A[j] - A[i]\n            dy = B[j] - B[i]\n            if dx == 0 and dy == 0:\n                duplicates += 1\n            else:\n                g = gcd(dx,dy)\n                dy //= g\n                dx //= g\n                if dx &lt; 0:\n                    dx = -dx\n                    dy = -dy\n                if dx == 0:\n                    dy = 1\n                if dy == 0:\n                    dx = 1\n                slope_count[(dy,dx)] += 1\n                local_max(local_max, slope_count[(dy,dx)])\n        result = max(result, local_max + duplicates)\n    return result\n</code></pre>"},{"location":"DSAyy/hashing/#an-increment-problem","title":"An Increment Problem","text":"<p>Given a stream of integers, for each incoming element \\(x\\), if it has appeared before, increment the first occ by \\(1\\), then append the new \\(x\\) to the end. Return the final stream after processing all arrivals.</p> <p>Maintain :</p> <ul> <li> <p>a dynamic arr for stream.</p> </li> <li> <p>For each val \\(v\\), a min-heap of indices in stream where \\(v\\) currently resides. When x arrives:</p> </li> <li> <p>If heap for \\(x\\) is nonempty, pop the smallest index \\(j\\), increment the stream there, and push \\(j\\) into the heap for \\(x+1\\)</p> </li> <li> <p>Append \\(x\\) to the end at index \\(k\\), and push \\(k\\) into heap for \\(x\\).</p> </li> </ul> <pre><code>from collections import defaultdict\nimport heapq\ndef process_increment_stream(A):\n    stream = []\n    idx_heap = default_dict(list)\n    for x in A:\n        if idx_heap[x]:\n            j = heapq.heappop(idx_heap[x])\n            stream[j] += 1\n            heapq.heappush(idx_heap[x+1],j)\n        k = len(stream)\n        stream.append(x)\n        heapq.heappush(idx_heap[x],k)\n    return stream\n</code></pre>"},{"location":"DSAyy/hashing/#subarray-with-given-xor","title":"Subarray with Given XOR","text":"<p>Given int array \\(A\\) and an int \\(B\\), count the subarrays whose bitwise xor of elements equals \\(B\\).</p>"},{"location":"DSAyy/hashing/#how_7","title":"How","text":"<p>Bhai prefix sum toh xor ka bhi hota. $$ xor(A[L..R]) = prefix[R] \\oplus prefix[L] $$</p> <pre><code>from collections import defaultdict\n\ndef count_subarrays_with_xor(A,B):\n    freq = defaultdict(int)\n    freq[0] = 1\n    prefix = 0\n    ans = 0\n    for x in A:\n        prefix ^= x\n        need = prefix ^ B\n        ans += freq[need]\n        freq[prefix] += 1\n    return ans\n</code></pre>"},{"location":"DSAyy/hashing/#two-out-of-three","title":"Two out of Three","text":"<p>Given three int arrays, A B and C, return a sorted list of all numbers that appear in atleast two of the arrays. Arrays may contain duplicates internally, but each value is counted at mmost once per array.</p>"},{"location":"DSAyy/hashing/#how_8","title":"How","text":"<p>Use a small integer mask per value to record which of the tree arrays it appears in. bit 0 for A, 1 for B and samajh le. Scan every array once, OR-ing appropriate bit into \\(mask[x]\\). Finally any value whose mask has atleast two bits set belongs to the answer.</p> <pre><code>def two_out_of_three(A,B,C):\n    max_val = max(max(A), max(B), max(C), 0)\n    mask = [0]*(max_val + 1)\n    for x in set(A):\n        mask[x] |= 1\n    for x in set(B):\n        mask[x] |= 2\n    for x in set(C):\n        mask[x] |= 4\n    result = []\n    for x in range(1,max_val + 1):\n        if bin(mask[x]).count('1') &gt;= 2:\n            result.append(x)\n    return result\n</code></pre>"},{"location":"DSAyy/hashing/#substring-concatenation","title":"Substring Concatenation","text":"<p>Given a string S of length n, and list L of m words, each of length k. Find all starting indices in S where a substring is formed by adding each word in L exactly once without any gaps. Return the list of indices in any order.</p> <ul> <li> <p>This algorithm finds all starting indices in <code>S</code> where a concatenation of all words in <code>L</code> occurs exactly once and without any intervening characters.</p> </li> <li> <p>Uses a sliding window technique with an offset loop to handle all alignment positions modulo <code>k</code>.</p> </li> <li> <p><code>target</code> counts how many times each word is expected.</p> </li> <li> <p><code>window</code> tracks how many times each word appears in the current sliding window.</p> </li> </ul>"},{"location":"DSAyy/hashing/#how_9","title":"How","text":"<p>Simple sliding window.</p> <pre><code>from collections import defaultdict, Counter\ndef find_substring_concatenation(S,L):\n    if not S or not L or not L[0]:\n        return []\n    n,m,k = len(S), len(L), len(L[0])\n    target = counter(L)\n    result = []\n    for r in range(k):\n        window = defaultdict(int)\n        count = 0\n        left = r\n        for right in range(r,n-k+1,k):\n            w = S[right:right+k]\n            if w not in target:\n                window.clear()\n                count = 0\n                left = right + k\n            else:\n                window[w] += 1\n                if window[w] &lt;= target[w]:\n                    count += 1\n                else:\n                    while window[w] &gt; target[w]:\n                        w_left = S[left:left + k]\n                        window[w_left] -= 1\n                        if window[w_left] &lt; target[w_left]:\n                            count -= 1\n                        left += k\n                if count == m:\n                    result.append(left)\n                    w_left = S[left:left + k]\n                    window[w_left] -= 1\n                    count -= 1\n                    left += k\n    return result\n</code></pre>"},{"location":"DSAyy/hashing/#subarray-with-exactly-b-odd-numbers","title":"Subarray with exactly B odd numbers","text":"<p>Given an int array, and an int B, count how many subarrays contain exactly B odd numbers.</p> <pre><code>def count_subarrays_with_b_odds(A,B):\n    n = len(A)\n    odd_pos = [i for i,x in enumerate(A) if x % 2 == 1]\n    #special case: B == 0, count all even only subarrays\n    if B == 0:\n        ans = 0\n        length = 0\n        for x in A:\n            if x % 2 == 0:\n                length += 1\n            else:\n                ans += length*(length+1)//2\n                length = 0\n        ans += length*(length + 1) // 2\n        return ans\n    m = len(odd_pos)\n    if m &lt; B:\n        return 0\n    ans = 0\n    for i in range(1,m-B+2):\n        L = odd_pos[i] - odd_pos[i-1]\n        R = odd_pos[i+B] - odd_pos[i+B-1]\n        ans += L*R\n    return ans\n</code></pre>"},{"location":"DSAyy/hashing/#minimum-window-substring","title":"Minimum Window Substring","text":"<p>Given a string S of length n and a pattern T of length m. Find the smallest substring (window) of S that contains all characters of T. If no such window, return empty string. If multiple exists, return the one with smallest starting index.</p>"},{"location":"DSAyy/hashing/#how_10","title":"How","text":"<p>Sliding Sliding maa chod dunga google ki. <pre><code>from collections import Counter, defaultdict\ndef min_window_substring(S,T):\n    n,m = len(S), len(T)\n    if n &lt; m:\n        return \"\"\n    need = Counter(T)\n    have = defaultdict(int)\n    required = len(need)\n    formed = 0\n    l = r =0\n    min_len = float('inf')\n    min_l = 0\n    while r &lt; n:\n        c = S[r]\n        have[c] += 1\n        if c in need and have[c] == need[c]:\n            formed += 1\n        while l &lt;= r and formed == required:\n            window = r - l + 1\n            if window_len &lt; min_len:\n                min_len = window_len\n                min_l = l\n            d = S[l]\n            have[d] -= 1\n            if d in need and have[d] &lt; need[d]:\n                formed -= 1\n            l += 1\n        r += 1\n    return \"\" if min_len == float('inf') else S[min_l:min_l + min_len]\n</code></pre></p>"},{"location":"DSAyy/hashing/#longest-substring-without-repeating-characters","title":"Longest Substring without repeating characters.","text":"<pre><code>def longest_unique_substring(S):\n    last = [-1]*256 #assuming ASCII\n    start = best = 0\n    for i,c in enumerate(S):\n        ascii_c = ord(c)\n        start = max(start, last[ascii_c] + 1)\n        best = max(best, i - start + 1)\n        last[ascii_c] = i\n    return best\n</code></pre>"},{"location":"DSAyy/heaps_and_maps/","title":"Heaps and Maps","text":""},{"location":"DSAyy/heaps_and_maps/#problem-1-ways-to-form-a-max-heap","title":"Problem 1: Ways to Form a Max Heap","text":""},{"location":"DSAyy/heaps_and_maps/#problem-statement","title":"Problem Statement","text":"<p>Given <code>A</code> distinct integers, count the number of distinct Max Heaps that can be formed using all of them. The heap must satisfy:</p> <ol> <li> <p>It is a complete binary tree.</p> </li> <li> <p>Each parent node has a value strictly greater than those of its children.</p> </li> </ol> <p>Return the result modulo \\(10^9 + 7\\).</p>"},{"location":"DSAyy/heaps_and_maps/#combinatorial-insight","title":"Combinatorial Insight","text":"<p>Let the distinct integers be labeled as \\({1, 2, \\dots, A}\\). In any max heap, the largest element \\(A\\) must be at the root.</p> <p>Let:</p> <ul> <li> <p>\\(n = A\\)</p> </li> <li> <p>\\(h = \\lfloor \\log_2 n \\rfloor\\)</p> </li> <li> <p>\\(\\text{nodesAbove} = 2^h - 1\\)</p> </li> <li> <p>\\(\\text{lastLevel} = n - \\text{nodesAbove}\\)</p> </li> <li> <p>\\(\\text{leftLast} = \\min(\\text{lastLevel}, 2^{h-1})\\)</p> </li> </ul> <p>Then the number of nodes in the left subtree is:</p> <p>L=(2h\u22121\u22121)+leftLastL = (2^{h-1} - 1) + \\text{leftLast}</p>"},{"location":"DSAyy/heaps_and_maps/#recurrence-relation","title":"Recurrence Relation","text":"<p>Let \\(D[n]\\) denote the number of valid Max Heaps that can be built with \\(n\\) distinct values.</p> <p>D[0]=D[1]=1D[0] = D[1] = 1 D[n]=(n\u22121L)\u22c5D[L]\u22c5D[n\u22121\u2212L]D[n] = \\binom{n - 1}{L} \\cdot D[L] \\cdot D[n - 1 - L]</p> <p>where:</p> <ul> <li> <p>\\(\\binom{n - 1}{L}\\) is the number of ways to choose elements for the left subtree,</p> </li> <li> <p>\\(L\\) is the number of nodes in the left subtree.</p> </li> </ul>"},{"location":"DSAyy/heaps_and_maps/#clean-python-implementation","title":"Clean Python Implementation","text":"<pre><code>import math\n\nMOD = 10**9 + 7\nMAXN = 105\n\nfact = [1] * MAXN\ninvfact = [1] * MAXN\ndp = [0] * MAXN\n\ndef modexp(base, exp=MOD - 2):\n    result = 1\n    while exp:\n        if exp % 2:\n            result = result * base % MOD\n        base = base * base % MOD\n        exp //= 2\n    return result\n\ndef precompute(n):\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % MOD\n    invfact[n] = modexp(fact[n])\n    for i in range(n, 0, -1):\n        invfact[i - 1] = invfact[i] * i % MOD\n\ndef choose(n, k):\n    if k &lt; 0 or k &gt; n:\n        return 0\n    return fact[n] * invfact[k] % MOD * invfact[n - k] % MOD\n\ndef count_max_heaps(A):\n    precompute(A)\n    dp[0] = dp[1] = 1\n\n    for n in range(2, A + 1):\n        h = n.bit_length() - 1\n        nodes_above = (1 &lt;&lt; h) - 1\n        last_level = n - nodes_above\n        left_last = min(last_level, 1 &lt;&lt; (h - 1))\n        L = (1 &lt;&lt; (h - 1)) - 1 + left_last\n\n        ways = choose(n - 1, L)\n        dp[n] = ways * dp[L] % MOD * dp[n - 1 - L] % MOD\n\n    return dp[A]\n</code></pre>"},{"location":"DSAyy/heaps_and_maps/#time-and-space-complexity","title":"Time and Space Complexity","text":"<ul> <li> <p>Precomputation of factorials and inverse factorials: \\(O(A)\\)</p> </li> <li> <p>DP computation for all \\(n \\leq A\\): \\(O(A)\\)</p> </li> <li> <p>Total Time Complexity: \\(O(A)\\)</p> </li> <li> <p>Space Complexity: \\(O(A)\\)</p> </li> </ul>"},{"location":"DSAyy/heaps_and_maps/#problem-2-n-maximum-pair-sum-combinations","title":"Problem 2: N Maximum Pair Sum Combinations","text":""},{"location":"DSAyy/heaps_and_maps/#problem-statement_1","title":"Problem Statement","text":"<p>Given two integer arrays \\(A\\) and \\(B\\), each of size \\(N\\), compute the \\(N\\) largest sums of the form \\(A_i + B_j\\) and return them in descending order.</p> <p>Formally, compute:</p> <p>Output:\u00a0{s1,s2,\u2026,sN}where\u00a0each\u00a0sk=Aik+Bjk\\text{Output: } {s_1, s_2, \\dots, s_N} \\quad \\text{where each } s_k = A_{i_k} + B_{j_k}</p> <p>such that \\(s_1 \\geq s_2 \\geq \\dots \\geq s_N\\) and each \\((i_k, j_k)\\) is a valid index pair.</p>"},{"location":"DSAyy/heaps_and_maps/#key-insight","title":"Key Insight","text":"<ul> <li> <p>Sort both arrays \\(A\\) and \\(B\\) in descending order.</p> </li> <li> <p>The largest sum is \\(A_0 + B_0\\).</p> </li> <li> <p>From position \\((i, j)\\) in the implicit \\(N \\times N\\) sum matrix, you can move:</p> <ul> <li> <p>Right to \\((i, j+1)\\)</p> </li> <li> <p>Down to \\((i+1, j)\\)</p> </li> </ul> </li> </ul> <p>Use a max-heap to always choose the next largest unvisited sum from this matrix.</p> <p>Maintain a <code>seen</code> set to avoid pushing duplicate index pairs.</p>"},{"location":"DSAyy/heaps_and_maps/#clean-python-implementation_1","title":"Clean Python Implementation","text":"<pre><code>import heapq\n\ndef max_pair_sums(A, B):\n    N = len(A)\n    A.sort(reverse=True)\n    B.sort(reverse=True)\n\n    max_heap = []\n    seen = set()\n    result = []\n\n    heapq.heappush(max_heap, (-(A[0] + B[0]), 0, 0))\n    seen.add((0, 0))\n\n    while len(result) &lt; N:\n        total, i, j = heapq.heappop(max_heap)\n        result.append(-total)\n\n        if i + 1 &lt; N and (i + 1, j) not in seen:\n            heapq.heappush(max_heap, (-(A[i + 1] + B[j]), i + 1, j))\n            seen.add((i + 1, j))\n\n        if j + 1 &lt; N and (i, j + 1) not in seen:\n            heapq.heappush(max_heap, (-(A[i] + B[j + 1]), i, j + 1))\n            seen.add((i, j + 1))\n\n    return result\n</code></pre>"},{"location":"DSAyy/heaps_and_maps/#time-and-space-complexity_1","title":"Time and Space Complexity","text":"<ul> <li> <p>Sorting both arrays: \\(O(N \\log N)\\)</p> </li> <li> <p>Heap operations: Up to \\(2N\\) pushes, \\(N\\) pops \u2192 \\(O(N \\log N)\\)</p> </li> <li> <p>Space: \\(O(N)\\) for heap and visited set</p> </li> </ul>"},{"location":"DSAyy/heaps_and_maps/#problem-3-k-largest-elements","title":"Problem 3: K Largest Elements","text":""},{"location":"DSAyy/heaps_and_maps/#problem-statement_2","title":"Problem Statement","text":"<p>Given an integer array \\(A\\) of size \\(N\\) and an integer \\(B\\) (\\(1 \\leq B \\leq N\\)), return any \\(B\\) largest elements from the array. The output can be in any order.</p>"},{"location":"DSAyy/heaps_and_maps/#key-insight_1","title":"Key Insight","text":"<p>There are two efficient approaches:</p>"},{"location":"DSAyy/heaps_and_maps/#1-partition-based-quickselectnth-element","title":"1. Partition-Based (Quickselect/Nth Element)","text":"<ul> <li> <p>Use a partitioning algorithm to position the \\((N-B)\\)-th smallest element at index \\(N-B\\).</p> </li> <li> <p>All elements from index \\(N-B\\) to \\(N-1\\) are the \\(B\\) largest elements (in any order).</p> </li> <li> <p>This approach uses in-place partitioning and avoids full sorting.</p> </li> </ul>"},{"location":"DSAyy/heaps_and_maps/#2-min-heap-of-size-b","title":"2. Min-Heap of Size \\(B\\)","text":"<ul> <li> <p>Build a min-heap with the first \\(B\\) elements.</p> </li> <li> <p>For every new element \\(x\\) in the rest of the array:</p> <ul> <li>If \\(x\\) is greater than the root, replace the root with \\(x\\).</li> </ul> </li> <li> <p>The heap contains the \\(B\\) largest elements.</p> </li> </ul>"},{"location":"DSAyy/heaps_and_maps/#clean-python-implementation-min-heap-approach","title":"Clean Python Implementation (Min-Heap Approach)","text":"<pre><code>import heapq\n\ndef k_largest_elements(A, B):\n    if B == 0:\n        return []\n\n    min_heap = A[:B]\n    heapq.heapify(min_heap)\n\n    for x in A[B:]:\n        if x &gt; min_heap[0]:\n            heapq.heappushpop(min_heap, x)\n\n    return min_heap\n</code></pre> <p>If you'd prefer the partition-based approach (like <code>nth_element</code>), here's an alternative using <code>heapq.nlargest</code>:</p> <pre><code>import heapq\n\ndef k_largest_elements_quick(A, B):\n    return heapq.nlargest(B, A)\n</code></pre>"},{"location":"DSAyy/heaps_and_maps/#time-and-space-complexity_2","title":"Time and Space Complexity","text":""},{"location":"DSAyy/heaps_and_maps/#min-heap-approach","title":"Min-Heap Approach:","text":"<ul> <li> <p>Build heap: \\(O(B)\\)</p> </li> <li> <p>Remaining \\(N - B\\) insertions: \\(O((N - B) \\log B)\\)</p> </li> <li> <p>Total time: \\(O(N \\log B)\\)</p> </li> <li> <p>Space: \\(O(B)\\)</p> </li> </ul>"},{"location":"DSAyy/heaps_and_maps/#quickselectnth-element-via-heapqnlargest","title":"Quickselect/Nth Element (via <code>heapq.nlargest</code>):","text":"<ul> <li> <p>Time: \\(O(N + B \\log B)\\) average</p> </li> <li> <p>Space: \\(O(B)\\)</p> </li> </ul>"},{"location":"DSAyy/heaps_and_maps/#problem-4-profit-maximisation","title":"Problem 4: Profit Maximisation","text":""},{"location":"DSAyy/heaps_and_maps/#problem-statement_3","title":"Problem Statement","text":"<p>You are given an array \\(A\\) of size \\(N\\), where \\(A_i\\) is the number of vacant seats in row \\(i\\) of a stadium. You need to sell tickets to \\(B\\) people, one ticket at a time.</p> <ul> <li> <p>Each ticket sold from row \\(i\\) earns profit equal to the current number of vacant seats in that row.</p> </li> <li> <p>After selling one ticket in row \\(i\\), the vacancy count in that row decreases by 1.</p> </li> </ul> <p>Compute the maximum total profit from selling all \\(B\\) tickets.</p>"},{"location":"DSAyy/heaps_and_maps/#key-insight_2","title":"Key Insight","text":"<p>To maximize profit:</p> <ul> <li> <p>Always sell the next ticket from the row with the most vacant seats.</p> </li> <li> <p>Use a max-heap to always access the row with the highest seat count.</p> </li> </ul> <p>Steps:</p> <ol> <li> <p>Add all seat counts to a max-heap.</p> </li> <li> <p>For \\(B\\) iterations:</p> <ul> <li> <p>Pop the largest seat count.</p> </li> <li> <p>Add it to the total profit.</p> </li> <li> <p>Decrease the seat count by 1 and push it back if it\u2019s still positive.</p> </li> </ul> </li> </ol> <p>This greedy strategy ensures the highest marginal gain at every step.</p>"},{"location":"DSAyy/heaps_and_maps/#clean-python-implementation_2","title":"Clean Python Implementation","text":"<pre><code>import heapq\n\ndef max_profit(A, B):\n    MOD = 10**9 + 7\n    max_heap = [-x for x in A]  # simulate max-heap using min-heap\n    heapq.heapify(max_heap)\n\n    profit = 0\n    for _ in range(B):\n        if not max_heap:\n            break\n        top = -heapq.heappop(max_heap)\n        profit = (profit + top) % MOD\n        if top &gt; 1:\n            heapq.heappush(max_heap, -(top - 1))\n\n    return profit\n</code></pre>"},{"location":"DSAyy/heaps_and_maps/#time-and-space-complexity_3","title":"Time and Space Complexity","text":"<ul> <li> <p>Heap initialization: \\(O(N)\\)</p> </li> <li> <p>Selling \\(B\\) tickets:</p> <ul> <li>Each ticket \u2192 1 pop and possibly 1 push \u2192 \\(O(\\log N)\\)</li> </ul> </li> <li> <p>Total Time: \\(O((N + B) \\log N)\\)</p> </li> <li> <p>Space: \\(O(N)\\) for the heap</p> </li> </ul>"},{"location":"DSAyy/heaps_and_maps/#problem-5-merge-k-sorted-arrays","title":"Problem 5: Merge K Sorted Arrays","text":""},{"location":"DSAyy/heaps_and_maps/#problem-statement_4","title":"Problem Statement","text":"<p>You are given \\(K\\) sorted integer arrays, each of length \\(N\\), forming a \\(K \\times N\\) matrix \\(A\\). Merge them into one single sorted array of length \\(K \\cdot N\\).</p> <p>Input: A list of \\(K\\) sorted lists: A=[A0,A1,\u2026,AK\u22121]A = [A_0, A_1, \\dots, A_{K-1}] Each \\(A_i\\) is sorted in non-decreasing order.</p> <p>Output: A single list with all elements from all \\(K\\) arrays in sorted order.</p>"},{"location":"DSAyy/heaps_and_maps/#key-insight_3","title":"Key Insight","text":"<p>Use a min-heap to merge \\(K\\) sorted arrays efficiently:</p> <ol> <li> <p>Initialize the heap with the first element of each array:     Each heap entry is a tuple:     (value,row\u00a0index,element\u00a0index)(\\text{value}, \\text{row index}, \\text{element index})</p> </li> <li> <p>Repeatedly extract the minimum element from the heap and push the next element from the same row (if any).</p> </li> <li> <p>Append the extracted element to the result list.</p> </li> </ol> <p>This way, you always pull the smallest available value across all \\(K\\) arrays.</p>"},{"location":"DSAyy/heaps_and_maps/#clean-python-implementation_3","title":"Clean Python Implementation","text":"<pre><code>import heapq\n\ndef merge_k_sorted_arrays(arrays):\n    min_heap = []\n    result = []\n\n    # Initialize heap with first element of each array\n    for i, row in enumerate(arrays):\n        if row:\n            heapq.heappush(min_heap, (row[0], i, 0))\n\n    while min_heap:\n        val, row, idx = heapq.heappop(min_heap)\n        result.append(val)\n\n        if idx + 1 &lt; len(arrays[row]):\n            next_val = arrays[row][idx + 1]\n            heapq.heappush(min_heap, (next_val, row, idx + 1))\n\n    return result\n</code></pre>"},{"location":"DSAyy/heaps_and_maps/#time-and-space-complexity_4","title":"Time and Space Complexity","text":"<ul> <li> <p>Total elements to process: \\(K \\cdot N\\)</p> </li> <li> <p>Each heap operation: \\(O(\\log K)\\)</p> </li> <li> <p>Time complexity:     O(KNlog\u2061K)O(KN \\log K)</p> </li> <li> <p>Space complexity:</p> <ul> <li> <p>Heap: \\(O(K)\\)</p> </li> <li> <p>Output: \\(O(KN)\\)</p> </li> </ul> </li> </ul>"},{"location":"DSAyy/heaps_and_maps/#problem-6-connect-ropes","title":"Problem 6: Connect Ropes","text":""},{"location":"DSAyy/heaps_and_maps/#problem-statement_5","title":"Problem Statement","text":"<p>You are given an array \\(A\\) of rope lengths. Your task is to connect all ropes into one single rope. Each time you connect two ropes of lengths \\(x\\) and \\(y\\), the cost is \\(x + y\\). Return the minimum total cost to connect all ropes into one.</p> <p>Input: An array \\(A = [a_1, a_2, \\dots, a_N]\\), where \\(a_i\\) is the length of the \\(i\\)-th rope.</p> <p>Output: Minimum total cost to connect all ropes.</p>"},{"location":"DSAyy/heaps_and_maps/#key-insight_4","title":"Key Insight","text":"<p>This is a classic greedy problem similar to building a Huffman tree.</p> <p>To minimize total cost:</p> <ol> <li> <p>Always connect the two shortest ropes first.</p> </li> <li> <p>Repeat until all ropes are merged.</p> </li> </ol> <p>Use a min-heap to efficiently extract the two smallest ropes at each step.</p>"},{"location":"DSAyy/heaps_and_maps/#clean-python-implementation_4","title":"Clean Python Implementation","text":"<pre><code>import heapq\n\ndef connect_ropes(A):\n    heapq.heapify(A)\n    total_cost = 0\n\n    while len(A) &gt; 1:\n        x = heapq.heappop(A)\n        y = heapq.heappop(A)\n        cost = x + y\n        total_cost += cost\n        heapq.heappush(A, cost)\n\n    return total_cost\n</code></pre>"},{"location":"DSAyy/heaps_and_maps/#example","title":"Example","text":"<pre><code>connect_ropes([1, 2, 3, 4, 5])  # Output: 33\n</code></pre> <p>Steps:</p> <ul> <li> <p>Connect 1 + 2 = 3 \u2192 heap: [3, 3, 4, 5]</p> </li> <li> <p>Connect 3 + 3 = 6 \u2192 heap: [4, 5, 6]</p> </li> <li> <p>Connect 4 + 5 = 9 \u2192 heap: [6, 9]</p> </li> <li> <p>Connect 6 + 9 = 15 \u2192 heap: [15]</p> </li> <li> <p>Total = 3 + 6 + 9 + 15 = 33</p> </li> </ul>"},{"location":"DSAyy/heaps_and_maps/#time-and-space-complexity_5","title":"Time and Space Complexity","text":"<ul> <li> <p>Heap initialization: \\(O(N)\\)</p> </li> <li> <p>Merging steps: \\((N - 1)\\) pops + pushes, each \\(O(\\log N)\\)</p> </li> <li> <p>Time: \\(O(N \\log N)\\)</p> </li> <li> <p>Space: \\(O(N)\\) for the heap</p> </li> </ul>"},{"location":"DSAyy/heaps_and_maps/#problem-7-magician-and-chocolates","title":"Problem 7: Magician and Chocolates","text":""},{"location":"DSAyy/heaps_and_maps/#problem-statement_6","title":"Problem Statement","text":"<p>You are given an integer \\(A\\) (number of time units) and an array \\(B\\) of size \\(N\\), where \\(B_i\\) denotes the initial number of chocolates in bag \\(i\\).</p> <p>Every second (for \\(A\\) seconds), a kid performs the following:</p> <ol> <li> <p>Chooses the bag with the maximum number of chocolates.</p> </li> <li> <p>Eats all chocolates in that bag.</p> </li> <li> <p>The magician refills the bag with \\(\\left\\lfloor \\frac{x}{2} \\right\\rfloor\\) chocolates.</p> </li> </ol> <p>Return the maximum number of chocolates the kid can eat over \\(A\\) seconds, modulo \\(10^9 + 7\\).</p>"},{"location":"DSAyy/heaps_and_maps/#key-insight_5","title":"Key Insight","text":"<p>At every step, to maximize chocolates eaten:</p> <ul> <li> <p>Always choose the bag with the most chocolates.</p> </li> <li> <p>Use a max-heap to track the current state of all bags.</p> </li> <li> <p>For each second:</p> <ul> <li> <p>Pop the max,</p> </li> <li> <p>Add it to total,</p> </li> <li> <p>Push back \\(\\left\\lfloor \\frac{x}{2} \\right\\rfloor\\).</p> </li> </ul> </li> </ul>"},{"location":"DSAyy/heaps_and_maps/#clean-python-implementation_5","title":"Clean Python Implementation","text":"<pre><code>import heapq\n\ndef max_chocolates(A, B):\n    MOD = 10**9 + 7\n    max_heap = [-x for x in B]\n    heapq.heapify(max_heap)\n\n    total = 0\n    for _ in range(A):\n        if not max_heap:\n            break\n        x = -heapq.heappop(max_heap)\n        total = (total + x) % MOD\n        heapq.heappush(max_heap, -(x // 2))\n\n    return total\n</code></pre>"},{"location":"DSAyy/heaps_and_maps/#example_1","title":"Example","text":"<pre><code>max_chocolates(3, [6, 5])  # Output: 14\n</code></pre> <p>Steps:</p> <ul> <li> <p>Eat 6 \u2192 refill with 3</p> </li> <li> <p>Eat 5 \u2192 refill with 2</p> </li> <li> <p>Eat 3 \u2192 refill with 1</p> </li> <li> <p>Total eaten: 6 + 5 + 3 = 14</p> </li> </ul>"},{"location":"DSAyy/heaps_and_maps/#time-and-space-complexity_6","title":"Time and Space Complexity","text":"<ul> <li> <p>Heap initialization: \\(O(N)\\)</p> </li> <li> <p>Each second:</p> <ul> <li>1 pop and 1 push \u2192 \\(O(\\log N)\\)</li> </ul> </li> <li> <p>Total time: \\(O((A + N) \\log N)\\)</p> </li> <li> <p>Space: \\(O(N)\\) for the heap</p> </li> </ul>"},{"location":"DSAyy/heaps_and_maps/#problem-8-maximum-sum-combinations","title":"Problem 8: Maximum Sum Combinations","text":""},{"location":"DSAyy/heaps_and_maps/#problem-statement_7","title":"Problem Statement","text":"<p>Given two integer arrays \\(A\\) and \\(B\\) of length \\(N\\) and an integer \\(C\\), return the top \\(C\\) maximum sums of the form \\(A_i + B_j\\), in non-increasing order.</p> <p>Input:</p> <ul> <li> <p>Two arrays: \\(A, B \\in \\mathbb{Z}^N\\)</p> </li> <li> <p>An integer \\(C\\) such that \\(1 \\leq C \\leq N\\)</p> </li> </ul> <p>Output:</p> <ul> <li>An array of length \\(C\\) containing the largest \\(C\\) sums formed by adding one element from \\(A\\) and one from \\(B\\)</li> </ul>"},{"location":"DSAyy/heaps_and_maps/#key-insight_6","title":"Key Insight","text":"<ul> <li> <p>Sort both \\(A\\) and \\(B\\) in descending order.</p> </li> <li> <p>The largest sum is always \\(A[0] + B[0]\\).</p> </li> <li> <p>Model the problem as exploring a virtual matrix \\(M[i][j] = A[i] + B[j]\\):</p> <ul> <li>Each row and column is non-increasing.</li> </ul> </li> <li> <p>Start at \\((0, 0)\\) and always pick the next largest sum from the max-heap.</p> </li> <li> <p>Use a visited set to avoid revisiting index pairs.</p> </li> </ul> <p>Each time you pop \\((i, j)\\):</p> <ul> <li>Push \\((i+1, j)\\) and \\((i, j+1)\\) if not already visited.</li> </ul>"},{"location":"DSAyy/heaps_and_maps/#clean-python-implementation_6","title":"Clean Python Implementation","text":"<pre><code>import heapq\n\ndef max_sum_combinations(A, B, C):\n    N = len(A)\n    A.sort(reverse=True)\n    B.sort(reverse=True)\n\n    max_heap = [(-(A[0] + B[0]), 0, 0)]\n    visited = set((0, 0))\n    result = []\n\n    while len(result) &lt; C:\n        total, i, j = heapq.heappop(max_heap)\n        result.append(-total)\n\n        if i + 1 &lt; N and (i + 1, j) not in visited:\n            heapq.heappush(max_heap, (-(A[i + 1] + B[j]), i + 1, j))\n            visited.add((i + 1, j))\n\n        if j + 1 &lt; N and (i, j + 1) not in visited:\n            heapq.heappush(max_heap, (-(A[i] + B[j + 1]), i, j + 1))\n            visited.add((i, j + 1))\n\n    return result\n</code></pre>"},{"location":"DSAyy/heaps_and_maps/#example_2","title":"Example","text":"<pre><code>A = [1, 4, 2, 3]\nB = [2, 5, 1, 6]\nC = 4\n\nmax_sum_combinations(A, B, C)  # Output: [10, 9, 9, 8]\n</code></pre>"},{"location":"DSAyy/heaps_and_maps/#time-and-space-complexity_7","title":"Time and Space Complexity","text":"<ul> <li> <p>Sorting: \\(O(N \\log N)\\)</p> </li> <li> <p>Heap operations: Up to \\(2C\\) pushes, \\(C\\) pops \u2192 \\(O(C \\log C)\\)</p> </li> <li> <p>Total time: \\(O(N \\log N + C \\log C)\\)</p> </li> <li> <p>Space: \\(O(C)\\)</p> </li> </ul>"},{"location":"DSAyy/heaps_and_maps/#problem-9-merge-k-sorted-lists","title":"Problem 9: Merge K Sorted Lists","text":""},{"location":"DSAyy/heaps_and_maps/#problem-statement_8","title":"Problem Statement","text":"<p>Given a list of \\(K\\) sorted singly linked lists, merge them into a single sorted linked list and return its head.</p> <p>Input:</p> <ul> <li>A list of \\(K\\) pointers to sorted linked lists.</li> </ul> <p>Output:</p> <ul> <li>A single sorted linked list containing all the nodes from the \\(K\\) input lists.</li> </ul>"},{"location":"DSAyy/heaps_and_maps/#key-insight_7","title":"Key Insight","text":"<p>This is a classical heap-based k-way merge problem.</p> <p>Use a min-heap to repeatedly select the node with the smallest value:</p> <ol> <li> <p>Initialize the heap with the head node of each list.</p> </li> <li> <p>At each step:</p> <ul> <li> <p>Pop the node with the smallest value.</p> </li> <li> <p>Append it to the merged list.</p> </li> <li> <p>If the node has a <code>.next</code>, push that into the heap.</p> </li> </ul> </li> </ol> <p>This guarantees the merged list remains sorted.</p>"},{"location":"DSAyy/heaps_and_maps/#clean-python-implementation_7","title":"Clean Python Implementation","text":"<pre><code>import heapq\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n    def __lt__(self, other):  # necessary for heapq\n        return self.val &lt; other.val\n\ndef merge_k_lists(lists):\n    heap = []\n    for node in lists:\n        if node:\n            heapq.heappush(heap, node)\n\n    dummy = ListNode(0)\n    tail = dummy\n\n    while heap:\n        smallest = heapq.heappop(heap)\n        tail.next = smallest\n        tail = tail.next\n        if smallest.next:\n            heapq.heappush(heap, smallest.next)\n\n    return dummy.next\n</code></pre>"},{"location":"DSAyy/heaps_and_maps/#example_3","title":"Example","text":"<pre><code># Helper to build a list from Python list\ndef build_linked_list(values):\n    dummy = ListNode(0)\n    cur = dummy\n    for v in values:\n        cur.next = ListNode(v)\n        cur = cur.next\n    return dummy.next\n\n# Usage\nl1 = build_linked_list([1, 4, 5])\nl2 = build_linked_list([1, 3, 4])\nl3 = build_linked_list([2, 6])\nmerged = merge_k_lists([l1, l2, l3])\n</code></pre>"},{"location":"DSAyy/heaps_and_maps/#time-and-space-complexity_8","title":"Time and Space Complexity","text":"<ul> <li> <p>Total number of nodes: \\(N\\)</p> </li> <li> <p>Each push/pop in heap: \\(O(\\log K)\\)</p> </li> <li> <p>Total time: \\(O(N \\log K)\\)</p> </li> <li> <p>Space: \\(O(K)\\) for the heap</p> </li> </ul>"},{"location":"DSAyy/heaps_and_maps/#problem-10-distinct-numbers-in-a-window","title":"Problem 10: Distinct Numbers in a Window","text":""},{"location":"DSAyy/heaps_and_maps/#problem-statement_9","title":"Problem Statement","text":"<p>Given an integer array \\(A\\) of size \\(N\\) and an integer \\(B\\), return a list of length \\(N - B + 1\\) where each element represents the number of distinct integers in the subarray (window) of size \\(B\\) starting at that index.</p> <p>If \\(B &gt; N\\), return an empty list.</p>"},{"location":"DSAyy/heaps_and_maps/#key-insight_8","title":"Key Insight","text":"<p>Use a sliding window with a frequency map (dictionary):</p> <ul> <li> <p>Initialize the first window and count distinct elements.</p> </li> <li> <p>As the window slides:</p> <ul> <li> <p>Remove the outgoing element from the frequency map.</p> <ul> <li>If its count drops to zero, it's no longer in the window.</li> </ul> </li> <li> <p>Add the incoming element.</p> <ul> <li>If it's a new element, increment the distinct count.</li> </ul> </li> </ul> </li> </ul> <p>This gives an \\(O(N)\\) solution using a hash map to track counts.</p>"},{"location":"DSAyy/heaps_and_maps/#clean-python-implementation_8","title":"Clean Python Implementation","text":"<pre><code>from collections import defaultdict\n\ndef distinct_in_window(A, B):\n    N = len(A)\n    if B &gt; N:\n        return []\n\n    freq = defaultdict(int)\n    result = []\n    distinct = 0\n\n    # First window\n    for i in range(B):\n        if freq[A[i]] == 0:\n            distinct += 1\n        freq[A[i]] += 1\n    result.append(distinct)\n\n    # Slide the window\n    for i in range(B, N):\n        out_elem = A[i - B]\n        freq[out_elem] -= 1\n        if freq[out_elem] == 0:\n            distinct -= 1\n\n        in_elem = A[i]\n        if freq[in_elem] == 0:\n            distinct += 1\n        freq[in_elem] += 1\n\n        result.append(distinct)\n\n    return result\n</code></pre>"},{"location":"DSAyy/heaps_and_maps/#example_4","title":"Example","text":"<pre><code>distinct_in_window([1, 2, 1, 3, 4, 3], 3)\n# Output: [2, 3, 3, 2]\n</code></pre> <p>Explanation:</p> <ul> <li> <p>Window [1, 2, 1] \u2192 2 distinct</p> </li> <li> <p>Window [2, 1, 3] \u2192 3 distinct</p> </li> <li> <p>Window [1, 3, 4] \u2192 3 distinct</p> </li> <li> <p>Window [3, 4, 3] \u2192 2 distinct</p> </li> </ul>"},{"location":"DSAyy/heaps_and_maps/#time-and-space-complexity_9","title":"Time and Space Complexity","text":"<ul> <li> <p>Each element enters and exits the window exactly once.</p> </li> <li> <p>Time: \\(O(N)\\)</p> </li> <li> <p>Space: \\(O(B)\\) for the frequency map</p> </li> </ul>"},{"location":"DSAyy/heaps_and_maps/#problem-11-lru-cache","title":"Problem 11: LRU Cache","text":""},{"location":"DSAyy/heaps_and_maps/#problem-statement_10","title":"Problem Statement","text":"<p>Design a Least Recently Used (LRU) Cache with the following operations:</p> <ul> <li> <p><code>get(key)</code>: Return the value if the key exists in the cache, otherwise return <code>-1</code>. Accessing a key marks it as most recently used.</p> </li> <li> <p><code>set(key, value)</code>: Insert or update the <code>(key, value)</code>. If the cache exceeds capacity, evict the least recently used item.</p> </li> </ul>"},{"location":"DSAyy/heaps_and_maps/#constraints","title":"Constraints","text":"<ul> <li> <p>All operations should run in O(1) average time.</p> </li> <li> <p>Capacity \\(C\\) is fixed at initialization.</p> </li> </ul>"},{"location":"DSAyy/heaps_and_maps/#key-insight_9","title":"Key Insight","text":"<p>Use a combination of two data structures:</p> <ol> <li> <p>Doubly Linked List (DLL): to store <code>(key, value)</code> pairs ordered from most-recently to least-recently used.</p> </li> <li> <p>Hash Map: maps each <code>key</code> to its corresponding node in the DLL.</p> </li> </ol> <p>On every access or insertion:</p> <ul> <li> <p>Move the node to the front of the DLL (most recently used).</p> </li> <li> <p>If inserting causes overflow, remove the node from the back of the DLL (least recently used).</p> </li> </ul>"},{"location":"DSAyy/heaps_and_maps/#clean-python-implementation-using-ordereddict","title":"Clean Python Implementation (Using <code>OrderedDict</code>)","text":"<pre><code>from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.cache = OrderedDict()\n        self.cap = capacity\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        self.cache.move_to_end(key, last=False)\n        return self.cache[key]\n\n    def set(self, key, value):\n        if key in self.cache:\n            self.cache.move_to_end(key, last=False)\n            self.cache[key] = value\n        else:\n            if len(self.cache) == self.cap:\n                self.cache.popitem(last=True)\n            self.cache[key] = value\n            self.cache.move_to_end(key, last=False)\n</code></pre>"},{"location":"DSAyy/heaps_and_maps/#example-usage","title":"Example Usage","text":"<pre><code>lru = LRUCache(2)\nlru.set(1, 10)\nlru.set(2, 20)\nlru.get(1)      # Returns 10\nlru.set(3, 30)  # Evicts key 2\nlru.get(2)      # Returns -1 (not found)\n</code></pre>"},{"location":"DSAyy/heaps_and_maps/#time-and-space-complexity_10","title":"Time and Space Complexity","text":"<ul> <li> <p><code>get</code>, <code>set</code>: \\(O(1)\\) average time (due to <code>OrderedDict</code>)</p> </li> <li> <p>Space: \\(O(C)\\) where \\(C\\) is the cache capacity</p> </li> </ul>"},{"location":"DSAyy/stacks_queues/","title":"Stacks and Queues","text":""},{"location":"DSAyy/stacks_queues/#valid-parenthesis","title":"Valid Parenthesis","text":"<p>Given a string containing bracket sequences, determine if the string is valid. brackets can be <code>(</code> ,<code>{</code> <code>[</code></p> <pre><code>def validParent(S):\n    stack = []\n    bracket_map = {')' : '(', '}' : '{', ']' : '['}\n    for char in S:\n        if char in bracket_map.values(): #opening bracket\n            stack.append(char)\n        elif char in bracket_map: #closing bracket\n            if not stack or stack[-1] != bracket_map[char]:\n                return False\n            stack.pop()\n    return not stack\n</code></pre>"},{"location":"DSAyy/stacks_queues/#reverse-string-using-stack","title":"Reverse String Using Stack","text":"<p>Given a string S, reverse the string using a stack. <pre><code>def reverse(s):\n    stack  = []\n    for char in S:\n        stack.append(char)\n    for i in range(len(S)):\n        S[i] = stack.pop()\n    return S\n</code></pre></p>"},{"location":"DSAyy/stacks_queues/#balanced-parentheses","title":"Balanced Parentheses","text":"<p>Given a string, consisting only of <code>(</code> and <code>)</code>. Determine if this sequence is balanced. <pre><code>def balanced(S):\n    balance = 0\n    for char in S:\n        balance += 1 if char == '(' else -1\n        if balance &lt; 0: return 0\n    return 1\n</code></pre></p>"},{"location":"DSAyy/stacks_queues/#simplify-directory-path","title":"Simplify Directory Path","text":"<p>Given a string representing absolute path for a file, return the simplified absolute path. Ex: 1. \"/home/\" -&gt; \"/home\" 2. \"/a/./b/../../c/\" -&gt; \"/c\"</p>"},{"location":"DSAyy/stacks_queues/#how","title":"How","text":"<ol> <li>Split the input path on '/' to get tokens.</li> <li>For .., pop the last directory fron the stack.</li> <li>Otherwise push directory name into the stack. <pre><code>def simplify_path(path):\n    stack = []\n    tokens = path.split('/')\n    for token in tokens:\n        if token == '' or token == '.':\n            continue\n        elif token == '..':\n            if stack:\n                stack.pop()\n        else:\n            stack.append(token)\n    return '/' + '/'.join(stack)\n</code></pre></li> </ol>"},{"location":"DSAyy/stacks_queues/#redundant-braces-in-expressions","title":"Redundant Braces in Expressions","text":"<p>Given a string denoting arithmetic expression (+ - * /), check whether it has redundant braces.</p> <p>Ex: 1. ((a+b)) : yes 2. (a + (a+b)) : no</p>"},{"location":"DSAyy/stacks_queues/#how_1","title":"How","text":"<ol> <li>Push everything onto the stack except when you see a closing parenthesis.</li> <li>On seeing ), pop untill you find a (.</li> <li>If no operator is found inside, they are redundant.</li> </ol> <pre><code>def has_redundant_braces(expression):\n    stack = []\n    for char in expression:\n        if char == ')':\n            has_operator = False\n            while stack and stack[-1] != '(':\n                top = stack.pop()\n                if top in ['+','-','*','/']:\n                    has_operator = True\n            if stack:\n                stack.pop() #pop the (\n            if not has_operator:\n                return True\n        else:\n            stack.append(char)\n    return False\n</code></pre>"},{"location":"DSAyy/stacks_queues/#min-stack-stack-with-constant-time-minimum","title":"Min Stack: Stack with constant time minimum","text":"<p>Design a stack with push pop top, and getMin(): retrieves the min element.</p> <p>getMin and top should return -1 on an empty stack. pop should do nothing on an empty stack.</p>"},{"location":"DSAyy/stacks_queues/#how_2","title":"How","text":"<p>Use two stacks, one for elements, other for min. Also push to minSt if its a new minimum, when you pop, also pop from minSt if it was the current minimum.</p> <pre><code>class MinStack:\n    def __init__(self):\n        self.st = []\n        self.minSt = []\n    def push(self,x):\n        self.st.append(x)\n        if not self.minSt or x &lt;= self.minSt[-1]:\n            self.minSt.append(x)\n    def pop(self):\n        if not self.st:\n            return\n        val = self.st.pop()\n        if self.minSt and val == self.minSt[-1]:\n            self.minSt.pop()\n    def top(self):\n        if not self.st:\n            return -1\n        return self.st[-1]\n    def getMin(self):\n        if not self.minSt:\n            return -1\n        return self.minSt[-1]\n</code></pre>"},{"location":"DSAyy/stacks_queues/#maxpprod-maximum-special-product","title":"MAXPPROD: Maximum Special Product","text":"<p>Given an array of integers, define for each index i: 1. LeftSpecialValue(LSV): the max index <code>j</code> such that \\(A[j] &gt; A[i]\\) . If none, LSV = 0 2. RightSpecialValue(RSV): the min index <code>i</code> such that \\(A[j] &gt; A[i]\\) if none, RSV = 0 3. Special Product for i is \\(LSV \\times RSV\\) </p>"},{"location":"DSAyy/stacks_queues/#how_3","title":"How","text":"<p>basically nearest greatest element to the left, and nearest greatest element to the right.</p> <pre><code>def max_special_product(A):\n    n = len(A)\n    left = [0]*n\n    right = [0]*n\n    stack = []\n    #compute left special\n    for i in range(n):\n        while stack and A[stack[-1]] &lt;= A[i]:\n            stack.pop()\n        left[i] = stack[-1] if stack else 0\n        stack.append(i)\n    stack.clear()\n    #compute right special\n    for i in range(n-1,-1,-1):\n        while stack and A[stack[-1]] &lt;= A[i]:\n            stack.pop()\n        right[i] = stack[-1] if stack else 0\n        stack.append(i)\n    #compute maxProd\n    maxProd = 0\n    for i in range(n):\n        prod = left[i]*right[i]\n        maxProd = max(maxProd, prod)\n    return maxProd % (10 **9 + 7)\n</code></pre>"},{"location":"DSAyy/stacks_queues/#nearest-smaller-element","title":"Nearest Smaller Element.","text":"<p>Monotonic Stack basic. Find nearest smaller element to the left. Return \\(G[i]\\) aka all the values of nearest smaller. If no element, \\(G[i] = -1\\) .</p> <pre><code>def prevSmaller(A):\n    n = len(A)\n    G = [0]*(n)\n    stack = []\n    for i in range(n):\n        while stack and A[stack[-1]] &gt;= A[i]:\n            stack.pop()\n        G[i] = stack[-1] if stack else -1\n        stack.append(A[i])\n    return G\n</code></pre>"},{"location":"DSAyy/stacks_queues/#largest-rectange-in-histogram","title":"Largest Rectange in Histogram.","text":"<p>Given an array containing height of histogram bars (Each width 1). Find the area of largest histogram.</p> <p>Ex: A = 2 1 5 6 2 3, Output = 10</p>"},{"location":"DSAyy/stacks_queues/#how_4","title":"How","text":"<ol> <li>Use a monotonic increasing stack to keep the value of left greatest.</li> <li>For each bar, while stack top is greater than current bar, pop and commute height times width. width is determined by the index. <pre><code>def largestRectArea(A):\n    n = len(A)\n    stack = []\n    maxArea = 0\n    for i in range(n+1):\n        h = 0 if i == n else A[i]\n        while stack and h &lt; A[stack[-1]]:\n            height = A[stack.pop()]\n            j = stack[-1] if stack else -1\n            width = i - j - 1\n            area = height * width\n            maxArea = max(maxArea, area)\n        stack.append(i)\n    return maxArea\n</code></pre></li> </ol>"},{"location":"DSAyy/stacks_queues/#hotel-service-nearest-hotel-in-a-grid","title":"Hotel Service (Nearest Hotel in a grid)","text":"<p>Given a matrix of \\(N \\times M\\) of 0s and 1s. \\(1 == hotel\\) and <code>Q</code> queries <code>B</code> (coordinates). Find the shortest distance from each query cell to nearest hotel. (measured in 4D).</p> <p>A = </p> <pre><code>0 0\n1 0\n</code></pre> <p>B = </p> <pre><code>1 1\n2 1\n1 2\n</code></pre> <p>Output: 1 0 2</p>"},{"location":"DSAyy/stacks_queues/#how_5","title":"How","text":"<p>Use multisource BFS 1. Stack BFS from every hotel cell (\\(A[i][j] = 1\\)) simultaneously. 2. Fill out a dist grid so that minimal steps to each coordinate is recorded. 3. After BFS, answer each query in \\(O(1)\\)</p> <pre><code>from collections import deque\ndef nearest_hotel_bfs(A,queries):\n    N = len(A)\n    M = len(A[0]) if N &gt; 0 else 0\n    dist = [[-1]*M for _ in range(N)]\n    Q = deque()\n    #enqueue all hotels\n    for i in range(N):\n        for j in range(M):\n            if A[i][j] == 1:\n                dist[i][j] = 0\n                Q.append((i,j))\n    directions = [(-1,0), (1,0), (0,-1), (0,1)]\n    while Q:\n        x,y = Q.popleft()\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 &lt;= nx &lt; N and 0 &lt;= ny &lt; M and dist[nx][ny] == -1:\n                dist[nx][ny] = dist[nx][ny] + 1\n                Q.append((nx,ny))\n    results = []\n    for X,Y in queries:\n        results.append(dist[X-1][Y-1])\n    return results\n</code></pre>"},{"location":"DSAyy/stacks_queues/#first-non-repeating-character-in-stream","title":"First Non-repeating character in stream","text":"<p>Given string representing a stream of lowercase letters, construct B such that \\(B[i]\\) is the first non repeating chracter in the prefix \\(A[0...i]\\) of the stream. If none, append #.</p> <p>A = abadbc, output = aabbdd</p>"},{"location":"DSAyy/stacks_queues/#how_6","title":"How","text":"<p>for each char 1. increase its frequency 2. push c into a queue if its a candidate for non repetition. 3. while the char at front of queue is a repeater(\\(\\text{frequency &gt; 1}\\)), pop it. 4. If the queue is empty, append <code>#</code> </p> <pre><code>from collections import deque\ndef first_non_repeating_char_stream(A):\n    freq = [0]*26 \n    Q = deque()\n    B = []\n    for c in A:\n        idx = ord(c) - ord('a')\n        freq[idx] +=  1\n        Q.append(c)\n        while Q and freq[ord(Q[0]) - ord('a')] &gt; 1:\n            Q.popleft()\n        if not Q:\n            B.append('#')\n        else:\n            B.append(Q[0])\n    return ''.join(B)\n</code></pre>"},{"location":"DSAyy/stacks_queues/#sliding-window-maximum","title":"Sliding Window Maximum","text":"<p>Given an array and a window size, for each window of that size moving from left to right, find the maximum in that window.</p> <p>A: 1 3 -1 -3 5 3 6 7</p> <p>B: 3</p> <p>Output: 3 3 5 5 6 7</p>"},{"location":"DSAyy/stacks_queues/#how_7","title":"How","text":"<p>Use a double-ended queue, to maintain a list of candidates for the maximum (monotonically decreasing) 1. When the window moves, remove the indices that are out of range from the front. 2. Remove indices from the back that are less than the current element (not maximum). 3. The front of the deque always gives maximum for the current window.</p> <pre><code>from collections import deque\ndef sliding_window_maximum(A,B):\n    n = len(A)\n    if B &gt; n: return [max(A)]\n    dq = deque()\n    C = []\n    for i in range(n):\n        if dq and dq[0] == i - B: #out of window index\n            dq.popleft()\n        #remove indices whose val &lt; A[i]\n        while dq and A[dq[-1]] &lt; A[i]:\n            dq.pop()\n        dq.append(i)\n        #record max for current window\n        if i &gt;= B-1:\n            C.append(A[dq[0]])\n    return C\n</code></pre>"},{"location":"DSAyy/stacks_queues/#evaluate-expression-reverse-polish-notation","title":"Evaluate Expression (Reverse Polish Notation)","text":"<p>Given a string <code>A</code> representing arithmetic expression in Reverse Polish Notation, evaluate and return its value.</p> <p>A = 2 1 + 3 * , Output = 9</p>"},{"location":"DSAyy/stacks_queues/#how_8","title":"How","text":"<p>traverse the tokens 1. If a number, push to stack. 2. If an operator, pop two numbers, compute the result, and push it back.</p> <pre><code>def RPN(tokens):\n    stack = []\n    for token in tokens:\n        if token in [\"+\", \"-\", \"*\", \"/\"]:\n            b = stack.pop()\n            a = stack.pop()\n            if token == \"+\":\n                res = a+b\n            elif token == \"-\":\n                res = a-b\n            elif token  == \"*\":\n                res = a*b\n            else:\n                res = int(a/b)\n            stack.append(res)\n        else:\n            stack.append(int(token))\n    return stack[-1]\n</code></pre>"},{"location":"DSAyy/stacks_queues/#trapping-rain-water-total-this-time","title":"Trapping Rain Water (total this time)","text":"<p>Given <code>A[i]</code> representing the height of the wall. width of each wall is <code>1</code>. Compute total units of water that can be trapped after it rains.</p> <p>A = 0 1 0 2 1 0 1 3 2 1 2 1, Output = 6</p>"},{"location":"DSAyy/stacks_queues/#how_9","title":"How","text":"<p>Water is trapped if there are taller bars on both sides. $$ \\text{water at i = } min(maxLeft_i, maxRight_i) - A[i] $$ Instead of precomputing maxLeft and maxRight, we can traverse both ends and track the highest bar from left to right on the go.</p> <ol> <li>Two pointers (left and right) at both ends, and two variables (left_max and right_max).</li> <li>Move the smaller inwards (if left is smaller):<ol> <li>If \\(A[left] \\geq \\text{left\\_max}\\), update left_max.</li> <li>Else, add left_max - A[left] to water. Increment left.</li> </ol> </li> <li>Else do the same for right.</li> <li>Continue until pointers meet. <pre><code>def trap_rain_water(A):\n    n = len(A)\n    left, right = 0, n-1\n    left_max, right_max = 0, 0\n    water = 0\n    while left &lt;= right:\n        if A[left] &lt; A[right]:\n            if A[left] &gt;= left_max:\n                left_max = A[left]\n            else:\n                water += left_max - A[left]\n            left += 1\n        else:  \n            if A[right] &gt;= right_max:\n                right_max = A[right]\n            else:\n                water += right_max - A[right]\n            right -= 1\n    return water\n</code></pre></li> </ol>"},{"location":"DSAyy/trees/","title":"Trees","text":""},{"location":"DSAyy/trees/#next-greater-number-in-bst","title":"Next Greater Number in BST","text":"<p>Given a BST Node, return the node which has val greater than given node.</p>"},{"location":"DSAyy/trees/#how","title":"How","text":"<p>This is basically finding inorder sucessor.</p> <p>For finding node with val just &gt; B,</p> <ol> <li>While searching for node with val B, whenever we move to left child, curr node is candidate for successor. We record that candidate and move ahead.</li> <li>Once we find the node with val B:<ol> <li>If N has a right subtree, then the sucessor is the leftmost node in the right subtree.</li> <li>Else sucessor is the latest recorded ancestor (candidate)</li> </ol> </li> </ol> <pre><code>class TreeNode:\n    def __init__(self,val):\n        self.val = val\n        self.left = None\n        self.right = None\ndef inorder_sucessor(root,target):\n    successor = None\n    #search for node while tracking sucessors\n    while root:\n        if target.val &lt; root.val:\n            successor = root\n            root = root.left\n        elif target.val &gt; root.val:\n            root = root.right\n        else:\n            break # found root\n    if target.right:\n        successor = target.right\n        while successor.left:\n            successor = successor.left\n    return successor\n</code></pre>"},{"location":"DSAyy/trees/#valid-bst-from-preorder","title":"Valid BST from PreOrder","text":"<p>Given and int arr A representing a preorder traversal of a BST.</p> <p>Determine if A can correspond to the preorder traversal of some valid BST.</p> <p>$$ (\\text{left subtree keys}) &lt; (\\text{node key}) &lt; (\\text{right subtree keys}) $$ Return if its a valid preorder of BST. </p>"},{"location":"DSAyy/trees/#how_1","title":"How","text":"<p>A valid preorder of BST would have {root, left subtree, right subtree} order.</p> <p>Each new preorder value should: 1. Be strictly greater than some lower bound 2. Fit into a position consistent with BST constraints implied previously</p> <p>We can simulate building the BST without constructing it by 1. A stack to track the chain of ancestors for which we have not yet assigned a right child. 2. A lower_bound variable that tracks the smallest permissible value for the current node (once we pop from the stack, that popped value becomes the new lower bound) <pre><code>def is_valid_bst_preorder(preorder):\n    stack = []\n    lower_bound = float('-inf')\n    for value in preorder:\n        #val must be greater than the lowest allowed val (left subtree needs a right)\n        if value &lt; lower_bound:\n            return False\n        #nodes popped mean we are in the right subtree now\n        while stack and value &gt; stack[-1]:\n            lower_bound = stack.pop() #pop all right subtree val\n        stack.append(value)\n    return True\n</code></pre></p>"},{"location":"DSAyy/trees/#kth-smallest-element-in-tree","title":"Kth Smallest Element in Tree","text":"<p>Given a BST, write a func to find the Kth smallest element in the tree.</p>"},{"location":"DSAyy/trees/#how_2","title":"How","text":"<p>The Kth smallest element is just the Kth element in the inorder traversal 1. Traverse BST iteratively using a stack to simulate recursion. 2. Always push left children onto the stack until we reach a null 3. Pop one node at a time, each pop node corresponds to the next smallest element in the sorted order. 4. Maintain a counter, when counter reaches k, return the popped value</p> <pre><code>class TreeNode:\n    def __init__(self,val):\n        self.val = val\n        self.left = None\n        self.right = None\ndef kth_smallest(root,k):\n    stack = []\n    current = root\n    while True:\n        #go as left as possible\n        while current:\n            stack.append(current)\n            current = current.left\n        #pop from stack\n        current = stack.pop()\n        k -= 1\n        if k == 0: return current.val\n        current = current.right\n</code></pre>"},{"location":"DSAyy/trees/#2-sum-binary-tree","title":"2-Sum Binary Tree","text":"<p>Given a BST, and an int B. Determine whether there are 2 distinct nodes X and Y in the tree such that $$ X.val + Y.val = B $$</p>"},{"location":"DSAyy/trees/#how_3","title":"How","text":"<p>Normally we use 2 pointer in a sorted array, we need to simulate this in BST. 1. An inorder iterator (left to right) that yields val in asc order. 2. A reverse-inorder iterator (right to left) that yields val in des order.</p> <p>Both iterators can be implemented with a stack 1. Init \\(next-smallest\\) stack by pushing all left descendents from root down to leftmost node. 2. Init \\(next-largest\\) stack by pushing all right descendents from root down to rightmost node. 3. getNext(): Pop from \\(s_1\\) call that node's val \\(v\\) . Then if that node has a right child, push its right child and all of that child's left descendents onto \\(s_1\\) . Return v. 4. getPrev(): Pop from \\(s_2\\) , Call that node's val \\(u\\). Then if that node has a left child, push its left child and all of its right descendents into \\(s_2\\) Return u. </p> <p>Then have a two-pointer loop. leftVal would be getNext(), rightVal would be getPrev(). Then normal 2 pointer approach.</p> <pre><code>class TreeNode:\n    def __init__(self,val):\n        self.val = val\n        self.left = None\n        self.right = None\nclass BSTIterator:\n    def __init__(self,root,forward):\n        self.stack = []\n        self.forward = forward #true is next val, false for prev\n        self.__push_all(root)\n    def __push_all(self,node):\n        while node:\n            self.stack.append(node)\n            node = node.left if self.forward else node.right\n    def next(self):\n        node = self.stack.pop()\n        val = node.val\n        if self.forward:\n            self.__push_all(node.right)\n        else:\n            self.__push_all(node.left)\n        return val\n    def has_next(self):\n        return len(stack) &gt; 0\ndef find_target(root,k):\n    if not root: return False\n    left_iter = BSTIterator(root,True)\n    right_iter = BSTIterator(root,False)\n    left_val = left_iter.next()\n    right_val = right_iter.next()\n    while left_val &lt; right_val:\n        cur_sum = left_val + right_val\n        if cur_sum == k:\n            return True\n        elif cur_sum &lt; k:\n            if left_iter.has_next():\n                left_val = left_iter.next()\n            else: \n                break\n        else:\n            if right_iter.has_next():\n                right_val = right_iter.next()\n            else:\n                break\n    return False\n</code></pre>"},{"location":"DSAyy/trees/#bst-iterator","title":"BST Iterator","text":"<p>Implement an iterator over a BST. Iterator is init with root of BST. 1. next() return the next smallest number in the BST 2. hasNext() return true if there is a next smallest number, otherwise false</p>"},{"location":"DSAyy/trees/#how_4","title":"How","text":"<p>Abhi just toh kiya upar</p> <pre><code>class TreeNode:\n    def __init__(self,val):\n        self.val = val\n        self.left = None\n        self.right = None\nclass BSTIterator:\n    def __init__(self,root):\n        self.stack = []\n        self._push_left(root)\n    def _push_left(self,node):\n        while node:\n            self.stack.append(node)\n            node = node.left\n    def next(self):\n        node = self.stack.pop()\n        val = node.val\n        if node.right:\n            self._push_left(node.right)\n        return val\n    def hasNext(self):\n        return len(stack) &gt; 0       \n</code></pre>"},{"location":"DSAyy/trees/#recover-binary-search-tree","title":"Recover Binary Search Tree","text":"<p>Two nodes of a BST are swapped by mistake. Identify which, and swap them back. Return a two-element list \\([v_1, v_2]\\) in asc order, wherte swapping \\(v_1\\) and \\(v_2\\) corrects the tree.</p>"},{"location":"DSAyy/trees/#how_5","title":"How","text":"<p>A correct BST inorder traversal produces a strictly increasing seq of node values. If  2 nodes are swapped, their inorder will have exactly one or two inversions.</p> <ol> <li>Case 1 (Non-adjacent swap): 2 inversions occur. First pair identifies the first wrong node, and second identifies the second wrong node.</li> <li>Case 2 (adjacent swap): Exactly one inversion occurs; just swap the 2 nodes in the inversion.</li> </ol> <p>Perform a Morris inorder traversal, with \\(O(1)\\) space. Keep track of prev pointer. Whenever \\(prev.val &gt; curr.val\\), we found an inversion.</p> <p>If first inversion, first = prev, second = curr, if second, second = curr</p> <pre><code>class TreeNode:\n    def __init__(self,val):\n        self.val = val\n        self.left = None\n        self.right = None\ndef recover_bst(root):\n    first = second = prev = None\n    current = root\n    while current:\n        if not current.left:\n            # check for inversion\n            if prev and prev.val &gt; current.val:\n                if not first:\n                    first = prev\n                second = current.right\n        else:\n            # morris traversal setup\n            pred = current.left\n            while pred.right and pred.right != current:\n                pred = pred.right\n            if not pred.right:\n                pred.right = current\n                current = current.left\n            else:\n                pred.right = None\n                if prev and prev.val &gt; current.val:\n                    if not first:\n                        first = prev\n                    second = current\n                prev = current\n                current = current.right\n    return sorted([first.val,second.val])\n</code></pre>"},{"location":"DSAyy/trees/#xor-between-two-arrays","title":"Xor Between Two Arrays","text":"<p>Given two Int arrays A and B. Pick one element \\(a \\in\\) A and one element \\(b\\in\\) B so to maximie the val of \\(a \\oplus b\\)  Where \\(\\oplus\\) is bitwise XOR. </p> <p>Return this max XOR value.</p> <p>Example: A = 1 2 3, B = 4 1 2. Max is \\(3 \\oplus 4\\) which is 7</p>"},{"location":"DSAyy/trees/#how_6","title":"How","text":"<p>We can insert all elements of A into a Binary Trie, instead of manually checking all the values.</p> <p>Insert all element \\(a \\in A\\)  into binary trie (a bitwise trie), and then, for each b \\(\\in\\) B, walk the trie greedily to pick bits that maximise \\(b \\oplus a\\) .</p> <p>Represent each int in 31 bits, and build a binary trie of depth 31, where each node has two children, \\(\\(child[0] \\space \\text{  bit = 0}, \\text{ child[1]      bit = 1}\\)\\) Inserting an int x simply means descending from root, examining bits and creating child pointers as needed.</p> <p>To query \\(b \\in B\\) , we walk the root, and at bit index \\(i\\) , we know b's ith bit is \\(b_i\\) . To maximise \\(b \\oplus a\\) at that bit, we would like to pick \\(a_i = 1 - b_i\\) if such a branch exists. Otherwise we must follow \\(a_i = b_i\\) </p> <p>Accumulating these chosen bits builds the best possible partner \\(a\\) from trie, and we compute (\\(b \\oplus a\\)).</p> <pre><code>class TrieNode:\n    def __init__(self):\n        self.child = [None,None] #child[0] for bit 0, child[1] for bit 1\ndef max_xor_between_arrays(A,B):\n    #build trie from elements of A\n    root = TrieNode()\n    for x in A:\n        node = root\n        for i in range(30,-1,-1):\n            bit = (x &gt;&gt; i) &amp; 1\n            if not node.child[bit]:\n                node.child[bit] = TrieNode()\n            node = node.child[bit]\n    #step 2\n    max_xor = 0\n    for b in B:\n        node = root\n        curr_xor = 0\n        for i in range(30,-1,-1):\n            bit = (b &gt;&gt; i) &amp; 1\n            desired = bit ^ 1 # opp bit for maximising xor\n            if node.child[desired]:\n                curr_xor |= (1 &lt;&lt; i)\n                node = node.child[desired]\n            else:\n                node = node.child[desired]\n        max_xor = max(max_xor, curr_xor)\n    return max_xor\n</code></pre>"},{"location":"DSAyy/trees/#hotel-reviews","title":"Hotel Reviews","text":"<p>Given a string <code>A</code> of good words, separated by <code>_</code> and a vector B of review strings, where sequence of words are also separated by underscore.</p> <p>Define the goodness value of a review, as the num of words in the review which match one of the good words. Return a vec of original indices of reviews in B, sorted in descending value of Goodness. If two reviews have same goodness, their relative order must be stable. (preserving original order)</p> <p>Example: A = cool_ice_wifi, B = {water_is_cool, cold_ice_drink, cool_wifi_speed} Ans: 2 0 1</p>"},{"location":"DSAyy/trees/#how_7","title":"How","text":"<p>Because num of good words and length of review can be large, we cannot compare every word, so we have to build a trie (prefix tree).</p> <p>Build a trie of all good words: 1. Split string A on '' to extract good word. (length \\(\\leq\\)  4 in this problem). 2. Insert each good word into a 26-ary trie (one child for each letter 'a'-'z'). And mark the end of a good word with a boolean flag. 3. For each review in B split on '', traverse trie to check if its marked good or not. 4. Count how many tokens appear in the review and that is the goodness val. 5. Finally perform the stable sort by comparing goodness in descending order.</p> <pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = True\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    def insert(self,word):\n         cur = self.root\n         for char in word:\n             if char not in cur.children:\n                 cur.children[char] = TrieNode()\n                cur = cur.children[char]\n        cur.is_end = True\n    def search(self,word);\n        cur = self.root\n        for char in word:\n            if char not in cur.children:\n                return False\n            cur = cur.children[char]\n        return cur.is_end\ndef hotel_reviews(A,B):\n    trie = Trie()\n    good_words = A.split('_')\n    for word in good_words:\n        trie.insert(word)\n    review_scores = []\n    for index, review in enumerate(B):\n        words = review.split('_')\n        score = sum(1 for word in words if trie.search(word))\n        review_scores.append((score,index))\n    # sort by desc goodness\n    review_scores.sort(key = lambda x: (-x[0],x[1]))\n    #ret indices\n    return [idx for _,idx in review_scores]\n</code></pre>"},{"location":"DSAyy/trees/#shortest-unique-prefix","title":"Shortest Unique Prefix","text":"<p>Given a list of words (all lowercase with no word being a prefix of the other), find the shortest unique prefix for each word that distinguishes it from all other words in the list.</p> <p>Example: zebra,dog,duck, dove. -&gt; output z,dog,dy,dov</p> <p>Simply prefix that no one else has.</p>"},{"location":"DSAyy/trees/#how_8","title":"How","text":"<p>We build a prefix tree, of all inputs and store at each node, the number of words that pass through the node (<code>count</code>) . Then: 1. Insert each word into the trie, incrementing <code>count</code> at every node along its path. 2. To find the shortest unique prefix of a word, traverse its path from root, char by char, appending to the prefix string. As soon as we reach a node where the count is 1, the prefix is going to be unique. 3. Because no word is a prefix of other, ans is guaranteed.</p> <pre><code>class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.count = 0 #num of words passing through\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    def insert(self, word):\n        cur = self.root\n        for char in word:\n            if char not in cur.childrem:\n                cur.children[char] = TrieNode()\n            cur = cur.children[char]\n            cur.count += 1\n    def find_prefix(self,word):\n        cur = self.root\n        prefix = \"\"\n        for char in word:\n            prefix += char\n            cur = cur.children[char]\n            if cur.count == 1:\n                return prefix\n        return prefix #fallback, full word\ndef shortest_unique_prefix(words):\n    trie = Trie()\n    for word in words: trie.insert(word)\n    return [trie.find_prefix(word) for word in words]\n</code></pre>"},{"location":"DSAyy/trees/#path-to-given-node","title":"Path to Given Node","text":"<p>Given a binary tree <code>A</code> with N nodes. Each node has unique int value. And a target <code>B</code>. Find the path from <code>root</code> to the node whose value is <code>B</code>.</p> <p>Given a root pointer, return a 1D array with the path from root to B.</p>"},{"location":"DSAyy/trees/#how_9","title":"How","text":"<p>A common approach for this is DFS and keeping track of node's parent. Once we discover node <code>B</code>, we can reconstruct the path by walking backwards to the root using <code>parent</code> pointers. The just reverse the sequence.</p> <ol> <li>Init an empty map parent, with \\(nodeValue -&gt; parentValue\\)</li> <li>Use an explicit stack to DFS the tree. When we visit a child, record \\(parent[child.val] = current.val\\) </li> <li>As soon as we pop a node who value equals B, stops the DFS, and start reconstructing using the parent chain.</li> </ol> <pre><code>class TreeNode:\n    def __init__(self,val = 0, left= None, right= None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef path_to_node(root,B):\n    if not root: return []\n    parent = {root.val : None}\n    stack = [root]\n    target_node = None\n\n    while stack:\n        node = stack.pop()\n        if node.val == B:\n            target_node= node\n            break\n        if node.left:\n            parent[node.left.val] = node.val\n            stack.append(node.left)\n        if node.right:\n            parent[node.right.val] = node.val\n            stack.append(node.right)\n    if target_node is None:\n        return []\n    path = []\n    while B is not None:\n        path.append(B)\n        B = parent[B]\n    return path[::-1]\n</code></pre>"},{"location":"DSAyy/trees/#remove-half-nodes","title":"Remove Half Nodes","text":"<p>Given a binary tree A with N nodes, remove all half nodes - nodes that have exactly one child- and return the root of the resulting tree. </p> <p>A leaf should not be removed.</p>"},{"location":"DSAyy/trees/#how_10","title":"How","text":"<p>If a node has 2 children, keep it, else if it has one child, bypass it by linking it directly with its non-null child.</p> <p>A bottom-up traversal (post order?) 1. Recursively process left and right subtrees, so all the half nodes below are already removed. 2. After recursion, examine node \\(u\\) :     1. if u is a leaf, keep it     2. if it has 2 children, keep it     3. if it has one child, return <code>u.left</code> or <code>u.right</code> whichever is non-null 3. Recursive call returns the root of the new pruned tree.</p> <pre><code>class TreeNode:\n    def __init__(self, val = 0, left= None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef remove_half_nodes(root):\n    if not root: return None\n    root.left = remove_half_nodes(root.left)\n    root.right = remove_half_nodes(root.right)\n    if root.left and not root.right:\n        return root.left\n    if root.right and not root.left:\n        return root.right\n    return root\n</code></pre>"},{"location":"DSAyy/trees/#nodes-at-distance-k","title":"Nodes at distance K","text":"<p>Given the root of a binary tree <code>A</code>, and a target node value <code>B</code>, and an integer <code>C</code> Return the array of all nodes that are exactly at distance <code>C</code> from the node with value <code>B</code>.  You can return ans in any order.</p>"},{"location":"DSAyy/trees/#how_11","title":"How","text":"<p>We treat binary tree as an undirected graph. Then we perform a BFS starting from target node, expanding outwards in all three directions (left, right, parent). After <code>C</code> BFS levels, all nodes in the queue are at distance C.</p> <pre><code>from collections import defaultdict, deque\nclass TreeNode:\n    def __init__(self,val = 0, left = None, right = None):\n        self.val = val\n        self.left=  left\n        self.right = right\ndef distance_k(root, target_val, k):\n    graph = defaultdict(list)\n    def build_graph(node, parent = None):\n        if node:\n            if parent:\n                graph[node.val].append(parent.val)\n                graph[parent.val].append(node.val)\n            build_graph(node.left,node)\n            build_graph(node.right, node)\n    build_graph(root)\n    visited = set()\n    queue = deque([target_val])\n    visited.add(target_val)\n    distance = 0\n    while queue and distance &lt; k:\n        for _ in range(len(queue)):\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n        distance += 1\n    return list(queue)\n</code></pre>"},{"location":"DSAyy/trees/#last-node-in-a-complete-binary-tree","title":"Last Node in a complete binary tree.","text":"<p>Given the root of a complete binary tree A. Return the value of the rightmost node, in the last level of the tree. Aim for better than \\(O(N)\\) time.</p>"},{"location":"DSAyy/trees/#how_12","title":"How","text":"<p>In a complete binary tree of height <code>h</code>, the last level has indices 0 to \\(2^k - 1\\). </p> <p>Define \\(exists(idx)\\) that checks if a node at index <code>idx</code> exists. To do this, we start at root, and examine the bits of <code>idx</code> from (<code>h-1</code>) floor down to 0. A bit of <code>0</code> means go left, <code>1</code> means go right . If you never reach <code>NULL</code>, then that <code>index</code> exists. This costs \\(O(h)\\) </p> <p>This is like binary search on <code>idx</code>. </p> <pre><code>class TreeNode:\n    def __init__(self,val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef compute_height(node):\n    height = 0\n    while node.left:\n        height += 1\n        node = node.left\n    return height\ndef exists(idx, height, node):\n    left = 0\n    right = (1 &lt;&lt; height) - 1\n    for i in range(height):\n        mid = (left + right)//2\n        if idx &lt;= mid:\n            node = node.left\n            right = mid\n        else:\n            node = node.right\n            left = mid + 1\n        if not node:\n            return False\n    return True\ndef last_node_value(root):\n    if not root: return None\n    height = compute_height(root)\n    if height == 0: return root.val\n    left = 0\n    right = (1 &lt;&lt; height) - 1 #max pos nodes at last level\n    # binary search for last existing node index\n    while left &lt;= right:\n        mid = (left + right) // 2\n        if exists(mid,height,root):\n            left = mid + 1\n        else:\n            right = mid - 1\n    # traverse the node at index 'right' to get its value\n    idx = right\n    node= root\n    left=  0\n    right = (1 &lt;&lt; height) - 1\n    for _ in range(height):\n        mid = (left + right) // 2\n        if idx &lt;= mid:\n            node = node.left\n            right = mid\n        else:\n            node = node.right\n            left = mid + 1\n    return node.val if node else None\n</code></pre>"},{"location":"DSAyy/trees/#consecutive-parent-child","title":"Consecutive Parent-Child","text":"<p>Given root of binary tree A, count number of parent-child pais such that their values differ by exactly 1.  $$ |parent.val - child.val| = 1 $$</p>"},{"location":"DSAyy/trees/#how_13","title":"How","text":"<p>Simple tree traversal, (BFS or DFS), For each node: 1. If it has a left child, check if \\(|node.val - node.left.val| = 1,\\)  if yes increment the count. 2. Same for the right.</p> <pre><code>class TreeNode:\n    def __init__(self, val = 0, left= None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef count_consec_pairs(root):\n    if not root: return 0\n    count = 0\n    stack = [root]\n    while stack:\n        node= stack.pop()\n        if node.left:\n            if abs(node.val - node.left.val) == 1:\n                count += 1\n            stack.append(node.left)\n        if node.right:\n            if abs(node.val - node.right.val) == 1L\n                count += 1\n            stack.append(node.right)\n    return count\n</code></pre>"},{"location":"DSAyy/trees/#balanced-binary-tree","title":"Balanced Binary Tree","text":"<p>Given root of binary tree A, determine if its height balanced. A binary tree is height balanced. </p> <p>Height balanced means \\(|depth(A.left) - depth(A.right)| \\leq 1\\)</p> <p>Return the boolean if its height balanced.</p>"},{"location":"DSAyy/trees/#how_14","title":"How","text":"<p>Naive way would be computing height of its left and right subtree and checking the difference.</p> <p>But we can use a single post-order traversal: 1. Recursively compute the height of each subtree 2. If any tree if already unbalanced, propogate a sentinel (ex: \\(-1\\) ) upward immediately. 3. At each node, obtain the leftH and rightH, and if either is \\(-1\\) otherwise do the usual check. <pre><code>class TreeNode:\n    def __init__(self, val= 0 , left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right= right\ndef is_balanced(root):\n    def check_height(node):\n        if not node: return 0\n        left_height = check_height(node.left)\n        if left_height == -1: return -1\n        right_height = check_height(node.right)\n        if right_height == -1: return -1\n\n        if abs(left_height - right_height) &gt; 1:\n            return -1\n        return max(left_height, right_height) + 1\n    return 0 if check_height(root) == -1 else 1\n</code></pre></p>"},{"location":"DSAyy/trees/#maximum-edge-removal","title":"Maximum Edge Removal","text":"<p>Given an undirected tree, with an even number of nodes A. You may remove as many edges as possible so that each resulting connected component (subtree) has an even number of nodes.</p> <p>Return the maximum number of edges that can be removed.</p>"},{"location":"DSAyy/trees/#how_15","title":"How","text":"<p>Root the tree at node 1, we want to cut as many parent-child edges such that resulting connected components have even size. 1. If a subtree is rooted at u and has even number of nodes, we may cut te edge connecting it to its parent.  2. If a subtree has odd size, we cannot cut its root to parent edge.</p> <p>So 1. Compute, for every node <code>u</code>, the size of its subtree. 2. Process nodes in post order, (children first). Whenever a node \\(u\\neq\\) 1 has an even subtree size, increment the answer by 1, and do not add u's size to its parent.  3. If it has odd size, add u's size to its parent's running total. 4. Root's final collected size is A, which is even, but we can never cut above the root.</p> <pre><code>from collections import defaultdict\ndef max_edge_removal_even_tree(A,B):\n    #build adj\n    adj = defaultdict(list)\n    for u,v in B:\n        adj[u].append(v)\n        adj[v].append(u)\n    #post order setup\n    parent = [0]*(A+1)\n    parent[1] = 0\n    stack = [(1,0)]\n    postorder = []\n\n    while stack:\n        u,p = stack.pop()\n        postorder.append(u)\n        parent[u] = p\n        for v in adj[u]:\n            if v != p:\n                stack.append((v,u))\n    subsize = [1]*(A+1) #subtree size, default itself (1)\n    answer = 0\n    for u in reversed(postorder):\n        if u != 1 and subsize[u] % 2 == 0:\n            answer += 1\n        else:\n            p = parent[u]\n            if p != 0:\n                subsize[p] += u\n    return answer\n</code></pre>"},{"location":"DSAyy/trees/#merge-binary-trees","title":"Merge Binary Trees","text":"<p>Given two binary trees <code>A</code> and <code>B</code>. merge them into a single binary tree according to this rule 1. if two nodes overlap (both non-null at same position). sum their value to form a new node. 2. otherwise use the non-null node as in the merged tree. Return a pointer to the root of the merged tree.</p> <p>Input, ptr to A and B, Output the root ptr to merged binary tree.</p>"},{"location":"DSAyy/trees/#how_16","title":"How","text":"<p>We perform a simultaneous pre-order traversal of both trees: 1. if both current nodes u (from A) and v (from B) are non-null, create (or reuse) a node with value \\(u.val + v.val\\)      1. Recursively merge left children     2. Recursively merge right children</p> <pre><code>class TreeNode:\n    def __init__(self,val = 0, left= None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef mergeTrees(u,v):\n    if not u: return v\n    if not v: return u\n    u.val += v.val\n    u.left = mergeTrees(u.left,v.left)\n    u.right = mergeTrees(u.right,v.right)\n    return u\n</code></pre>"},{"location":"DSAyy/trees/#symmetric-binary-tree","title":"Symmetric Binary Tree","text":"<p>Given the root of binary tree A, determine whether it is symmetric around its center (i.e a mirror of itself). In other words, left and right subtree should be mirror images.</p>"},{"location":"DSAyy/trees/#how_17","title":"How","text":"<ol> <li>If both nodes are null, they match</li> <li>if one is null and other is not, they dont</li> <li>otherwise we repeat the top 2 for pair (left.left,right.right) and (left.right, right.left)</li> </ol> <pre><code>from collections import deque\nclass TreeNode:\n    def __init__(self, val = 0, left =None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef is_symmetric(root):\n    if not root: return 1\n    queue = deque()\n    queue.append((root.left,root.right))\n    while queue:\n        u,v = queue.popleft()\n        if not u and not v: continue\n        if not u or not v: return 0\n        if u.val != v.val: return 0\n        queue.append((u.left,v.right))\n        queue.append((u.right,v.right))\n    return 1 \n</code></pre>"},{"location":"DSAyy/trees/#identical-binary-tree","title":"Identical Binary Tree","text":"<p>Given two trees A and B, return if they are identical, structurally and value vise.</p>"},{"location":"DSAyy/trees/#how_18","title":"How","text":"<pre><code>class TreeNode:\n    def __init__(self,val = 0, left= None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef is_same_tree(u,v):\n    if not u and not v: return 1\n    if not u or not v: return 0\n    if u.val != v.val: return 0\n    return (is_same_tree(u.left,v.left) and is_same_tree(u.right,v.right)):\n</code></pre>"},{"location":"DSAyy/trees/#construct-bst-from-preorder","title":"Construct BST from PreOrder","text":"<p>Given an int arr of distinct elements representing the preorder traversal of a BST, construct the corresponding BST, and return its root pointer.</p>"},{"location":"DSAyy/trees/#how_19","title":"How","text":"<p>In a BST, for a node with val <code>v</code>, all subsequent preorder values less than <code>v</code> belong to the left subtree. Values greater than <code>v</code> belong to the right subtree or higher up.</p> <p>Simulate insertion using a stack: 1. First element \\(A[0]\\) becomes the root. 2. Maintain a stack of nodes representing the path from the root down to the most recently inserted node. 3. For each new value \\(A[i]\\) :     1. If \\(A[i]\\) is less than the value at the top of the stack, it must be the left child of that top value. Create a new node and attach it as top.left and push it on to the stack.     2. Else: pop from stack until you find a node that is greater than \\(A[i]\\). The last popped node is the parent of the new node in its right subtree.  Create the new node as parent.right, then push it onto the stack. 4. Continue until all elements are processed.</p> <pre><code>class TreeNode:\n    def __init__(self,val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef bst_from_preorder(preorder):\n    if not preorder: return Node\n    root = TreeNode(preorder[0])\n    stack = [root]\n    for i in range(1,len(preorder)):\n        curr = TreeNode(preorder[i])\n        #smaller than stack top? left child\n        if preorder[i] &lt; stack[-1].val:\n            stack[-1].left = curr\n        else: #find parent in right chain\n            parent = None\n            while stack and preorder[i] &gt; stack[-1].val:\n                parent = stack.pop()\n            parent.right = curr\n        stack.append(curr)\n    return root\n</code></pre>"},{"location":"DSAyy/trees/#inorder-traversal-of-a-cartesian-tree","title":"Inorder Traversal Of a Cartesian Tree","text":"<p>Given arr <code>A</code> on distinct integers, representing inorder traversal of a cartesian tree. Return the cartesian tree and its root. </p> <p>Cartesian Tree: 1. Heap Property: every node's value is greater than all values in its subtree. 2. Inorder property: an inorder traversal of the tree yields exactly the orignal array <code>A</code>.</p>"},{"location":"DSAyy/trees/#how_20","title":"How","text":"<p>To build the cartesian tree in \\(O(n)\\) time, we process A from left to right using a stack. 1. Init an empty stack <code>st</code> of TreeNode pointers. 2. For each value x = <code>A[i]</code>     1. Create a new node <code>curr</code> = TreeNode(x)     2. Pop nodes from the top of the stack while they have value less than x. Let last be the last node popped (or <code>nullptr</code> if none). Attach last as <code>curr.left</code>. This would maintain the inorder property: everything popped lies to the left of <code>x</code>.     3. If the stack is nonempty aftert popping, the new top's value is &gt; x, so we attach <code>curr</code> as <code>st.top().right</code>. This would ensure <code>curr</code> becomes the right child of the nearest larger node to its left.     4. Push <code>curr</code> onto the stack. 3. After processing all elements, bottom of the stack (first el pushed) is the root of cartesian tree.</p> <pre><code>class TreeNode:\n    def __init__(self,val):\n        self.val = val\n        self.left = None\n        self.right = None\ndef build_cartesian_tree(A):\n    st = []\n    for i in range(len(A)):\n        curr = TreeNode(A[i])\n        last = None\n        while st and st[-1].val &lt; A[i]:\n            last = st.pop()\n        curr.left = last\n        if st:\n            st[-1].right = curr\n        st.append(cur)\n    return st[0] if st else None\n</code></pre>"},{"location":"DSAyy/trees/#sorted-array-to-balanced-bst","title":"Sorted Array to Balanced BST","text":"<p>Given an array <code>A</code> of length <code>n</code> whose elements are sorted in strictly ascending order, convert it into a height balanced BST. </p> <p>Basically the depth of right and left subtree differ by atmost 1.</p>"},{"location":"DSAyy/trees/#how_21","title":"How","text":"<ol> <li>In a BST, in-order traversal yields the sorted sequence.</li> <li>To keep it balanced, choose the mid element of the array as root,  and half of the elements go to the left subtree and half to the right.</li> <li>Recursively apply the same procedure to the left subarray's midpoint and right subarray's midpoint.</li> </ol> <pre><code>class TreeNode:\n    def __init__(self,val):\n        self.val = val\n        self.left = None\n        self.right = None\ndef sorted_arr_to_bst(A):\n    def build_bst(l,r):\n        if l &gt; r:\n            return None\n        mid = l + (r- l) //2\n        node = TreeNode(A[mid])\n        node.left = build_bst(l,mid - 1)\n        node.right = build_bst(mid + 1, r)\n        return node\n    return build_bst(0, len(A) - 1)\n</code></pre>"},{"location":"DSAyy/trees/#construct-binary-tree-from-inorder-and-preorder","title":"Construct Binary Tree from Inorder and preorder","text":"<p>Given 2 int arrays A and B having pre-order and in-order traversal. Construct the binary tree and return its root pointer.</p>"},{"location":"DSAyy/trees/#how_22","title":"How","text":"<p>In preorder, first element is always the root. In inorder, the elements to the lest of that root are in left subtree, and els to the right are in right subtree.</p> <ol> <li>Maintain a global preIndex into the preorder array.</li> <li>Define a recursive function \\(build(inL,inR)\\) that constructs the subtree whose in-order indices range from \\(inL\\) to \\(inR\\) .</li> <li>In \\(build(inL,inR)\\):<ol> <li>root would be \\(A[preIndex]\\) , increment this ptr</li> <li>look for this value in inOrder array. call this <code>mid</code></li> <li>Now left subtree would be \\(B[inL...mid-1]\\)  and right subtree would be \\(build(mid+1 ... inR)\\) </li> <li>return root <pre><code>class TreeNode:\n    def __init__(self,val):\n        self.val = val\n        self.left=  None\n        self.right = None\ndef build_tree(preorder, inorder):\n    idx_map = {val : idx for idx,val in enumerate(inorder)}\n    pre_index = [0] #to pass by index\n    def build(left,right):\n        if left &gt; right: return None\n        root_val = preorder[pre_index[0]]\n        pre_index[0] += 1\n        root = TreeNode(root_val)\n        mid = idx_map[root_val]\n        root.left = build(left, mid - 1)\n        root.right = build(mid + 1, right)\n        return root\n    return build(0, len(inorder) - 1)\n</code></pre></li> </ol> </li> </ol>"},{"location":"DSAyy/trees/#binary-tree-from-inorder-and-postorder","title":"Binary Tree from Inorder and PostOrder","text":"<p>Given inorder and post-order traversal in an array, construct the binary tree and return the root pointer.</p>"},{"location":"DSAyy/trees/#how_23","title":"How","text":"<p>In the post order traversal, last element is always the root of the sub tree. Like above we use it but backwards.</p> <pre><code>class TreeNode:\n    def __init__(self,val):\n        self.val = val\n        self.left = None\n        self.right = None\ndef build_tree(inorder, postorder):\n    idx_map = {val,idx for idx,val in enumerate(inorder)}\n    post_index = [len(postorder) - 1] #use list for mutable int\n    def build(left,right):\n        if left &gt; right: return None\n        root_val = postorder[post_index[0]]\n        post_index[0] -= 1\n        root = TreeNode(root_val)\n        mid = idx_map[root_val]\n        root.right = build(mid + 1, right) #make the right first\n        root.left = build(left, mid - 1)\n        return root\n    return build(0,len(inorder) - 1)\n</code></pre>"},{"location":"DSAyy/trees/#vertical-order-traversal-of-binary-tree","title":"Vertical Order Traversal of Binary Tree","text":"<p>Given a binary tree of <code>N</code> nodes. Return a 2d array denoting its vertical order traversal. Label the root's column index as <code>0</code>; for any node at column <code>c</code>, its left child at column <code>c-1</code>, and its right child at column <code>c+1</code>.</p> <p>Group nodes by column. Basically column index is the array index. Give all elements column wise.</p>"},{"location":"DSAyy/trees/#how_24","title":"How","text":"<p>Perform a BFS but with node, also carry the current column index. When sending in left child, bas do <code>c-1</code>, and when going right, do <code>c+1</code>.</p> <pre><code>from collections import defaultdict, deque\nclass TreeNode:\n    def __init__(self,val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef vertical_order_traversal(root):\n    result = []\n    if root is None: return result\n    col_map = defaultdict(list)\n    min_col = max_col = 0\n    q = deque([(root,0)])\n    while q:\n        node , col = q.popleft()\n        col_map[col].append(node.val)\n        min_col = min(min_col,col)\n        max_col = max(max_col,col)\n        if node.left: q.append((node.left, col - 1))\n        if node.right: q.append((node.right, col + 1))\n    total_cols = max_col - min_col + 1\n    result = [[] for _ in range(total_cols)]\n    for col in range(min_col,max_col + 1):\n        result[col - min_col] = col_map[col]\n    return result\n</code></pre>"},{"location":"DSAyy/trees/#diagonal-traversal-of-binary-tree","title":"Diagonal Traversal Of Binary Tree","text":"<p>Given a binary tree A with N nodes, output all nodes in a diagonal order. Where nodes lying on the same line of slope - 1 belong to the same diagonal. Label the node's diagonal as 0.</p> <p>Within each diagonal, node must be in preorder. Finally concatenate the diagonals from smallest index to largest. (leftmost to rightmost)</p> <p>Input: Root of binary tree. Output: 1D array</p>"},{"location":"DSAyy/trees/#how_25","title":"How","text":"<p>A node's diagonal index d is defined as: $$ d(root) = 0, \\space d(node.left) = d(node) + 1, \\space d(node.right) = d(node) $$ Bas bhai map ke saath banate reh.</p> <pre><code>class TreeNode:\n    def __init__(self, val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef diagonal_traversal(root):\n    if not root: return []\n    diag_nodes = [] #list of lists\n    max_diag = 0\n    stack = [(root,0)]\n    while stack:\n        node, d = stack.pop() #dfs style\n        if len(diag_nodes) &lt;= d: #extend if diagonal too big\n            diag_nodes.extend([[] for _ in range(d - len(diag_nodes) + 1)])\n        diag_nodes[d].append(node.val)\n        max_diag = max(max_diag,d)\n        if node.right:\n            stack.append((node.right, d))\n        if node.left:\n            stack.append((node.left, d+1))\n    for i in range(max_diag + 1):\n        result.extend(diag_nodes[i])\n    return result\n</code></pre>"},{"location":"DSAyy/trees/#vertical-sum-of-a-binary-tree","title":"Vertical Sum of a Binary Tree","text":"<p>Given the root pointer of a binary tree. Comput the vertical sum for each vertical line of the tree. Label the root's column as 0; for any node at column c, its left child is at column <code>c-1</code> and right at <code>c+1</code> . The vertical sum for a column is the sum of all node values that lie in that column. Return an array of these sums, ordered from the leftmost column to the rightmost column.</p>"},{"location":"DSAyy/trees/#how_26","title":"How","text":"<p>Perform a BFS of the tree while tracking each node's column index. Keep a hasmap as column's sum metric.  Similar to what we solved above.</p> <pre><code>from collections import defaultdict, deque\nclass TreeNode:\n    def __init__(self,val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef vertical_sum(root):\n    if not root: return []\n    col_sum = defaultdict(int)\n    min_col = max_col = 0\n    q = deque([(root,0)])\n    while q:\n        node,col = q.popleft()\n        col_sum[col] += node.val\n        min_col = min(min_col,col)\n        max_col = max(max_col,col)\n        if node.left:\n            q.append((node.left,col - 1))\n        if node.right:\n            q.append((node.right, col + 1))\n    total_cols = max_col - min_col + 1\n    result = [0]*total_cols\n    for col in range(min_cols, max_cols + 1):\n        result[col - min_col] = col_sum[col]\n    return result\n</code></pre>"},{"location":"DSAyy/trees/#covered-uncovered-nodes","title":"Covered / Uncovered Nodes","text":"<p>Given root of a binary tree A. A node is : - Uncovered if it appears as either the first or the last node on its level. - Covered otherwise Compute absolute difference of: $$ |\\text{(sum of covered values) - (sum of uncovered values)}| $$</p>"},{"location":"DSAyy/trees/#how_27","title":"how","text":"<p>Perform BFS, to identfy first or last at each level. <pre><code>from collections import deque\nclass TreeNode:\n    def __init__(self,val = 0, left= None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef covered_minus_uncovered_sum(root):\n    if not root:\n        return 0\n    covered_sum = 0\n    uncovered_sum = 0\n    q = deque([root])\n    while q:\n        sz = len(q)\n        for i in range(sz):\n            node = q.popleft()\n            if i == 0 or i == sz - 1:\n                uncovered_sum += node.val\n            else:\n                covered_sum += node.val\n            if node.left:\n                q.append(node.left)\n            if node.right:\n                q.append(node.right)\n    return covered_sum - uncovered_sum\n</code></pre></p>"},{"location":"DSAyy/trees/#inorder-traversal-of-a-binary-tree","title":"Inorder Traversal of A Binary Tree","text":"<p>Given <code>root</code> pointer of a binary tree, return its nodes in inOrder travesal.</p> <pre><code>class TreeNode:\n    def __init__(self,val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef inorder_traversal(root):\n    res, stack = [], []\n    while root or stack:\n        #go as far left as possible\n        while root:\n            stack.append(root)\n            root = root.left\n        #visit node (mid)\n        root = stack.pop()\n        res.append(root.val)\n        # then go right\n        root = root.right\n    return res\n</code></pre>"},{"location":"DSAyy/trees/#preorder-traversal-of-a-binary-tree","title":"Preorder Traversal Of a Binary Tree","text":"<p>Given <code>root</code> pointer of a binary tree, return its nodes in preorder traversal. <pre><code>class TreeNode:\n    def __init__(self, val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef preorder_traversal(root):\n    res, stack = [],[]\n    if root: stack.append(root)\n    while stack:\n        node = stack.pop()\n        res.append(node.val)\n        if node.right: \n            stack.append(node.right) #right first\n        if node.left:\n            stack.append(node.left) #then left, so left is processed first\n    return res\n</code></pre></p>"},{"location":"DSAyy/trees/#postorder-traversal-of-a-binary-tree","title":"PostOrder Traversal Of a binary Tree","text":"<p>Given <code>root</code> pointer of a binary tree, return its nodes in postorder traversal <pre><code>class TreeNode:\n    def __init__(self, val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef postorder_traversal(root):\n    if not root: return []\n    toVisit, visited = [root], []\n    while s1:\n        node = toVisit.pop()\n        visited.append(node)\n        if node.left: toVisit.append(node.left)\n        if node.right: toVisit.append(node.right)\n    return [n.val for n in reversed(visited)]\n</code></pre></p>"},{"location":"DSAyy/trees/#right-view-of-a-binary-tree","title":"Right view of a binary tree","text":"<p>Given <code>root</code>, return an <code>array</code> of int representing the right view of the tree. Basically the nodes that are visible when looked from the right.</p> <p>Basically the last element in every level order.</p> <pre><code>from collections import deque\nclass TreeNode:\n    def __init__(self,val = 0, left = 0, right = 0):\n        self.val = val\n        self.left =left\n        self.right = right\ndef rightView(root):\n    if not root: return []\n    right_view = []\n    q = deque([root])\n    while q:\n        sz = len(q)\n        for i in range(sz):\n            node = q.popleft()\n            if i == sz - 1:\n                right_view.append(node.val)\n            if node.left: q.append(node.left)\n            if node.right: q.append(node.right)\n    return right_view\n</code></pre>"},{"location":"DSAyy/trees/#cousins-in-a-binary-tree","title":"Cousins in a binary tree","text":"<p>Given <code>root</code> pointer of a binary tree with <code>N</code> nodes, and a target value <code>B</code> that exists in the tree. Return an <code>array</code> of all the cousins of node whole value is <code>B</code>. </p> <p>Two nodes are cousins, if they are on the same depth, but have different parents.  Sibling nodes are not cousins.</p>"},{"location":"DSAyy/trees/#how_28","title":"How","text":"<p>Perform a single BFS (level order), that keeps track of each node's parent 1. Record the nodes at the level <code>levelNodes</code> 2. Check if <code>B</code> is in <code>levelNodes</code> along with its parent pointer. 3. Return all other nodes on the level with different parent.</p> <pre><code>from collections import deque\nclass TreeNode:\n    def __init__(self,val = 0,left = None,right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef find_cousins(root,B):\n    if not root: return []\n    cousins = []\n    q = deque()\n    q.append((root,None)) # (node,parent)\n    while q: \n        sz = len(q)\n        level_nodes = []\n        target_parent = None\n        for _ in range(sz):\n            node, parent = q.popleft()\n            level_nodes.append((node,parent))\n            if node.val == B:\n                target_parent = parent\n        if target_parent:\n            for node,parent in level_nodes:\n                if parent != target_parent and node.val != B:\n                    cousins.append(node.val)\n        #enqueue children for the next level\n        for node,parent in level_nodes:\n            if node.left: q.append((node.left,node))\n            if node.right: q.append((node.right,node))\n    return cousins\n</code></pre>"},{"location":"DSAyy/trees/#reverse-level-order-traversal-of-a-binary-tree","title":"Reverse Level Order Traversal of a Binary Tree","text":"<p>Given <code>root</code>, return nodes in reverse level order. Like from bottom-most to the top.</p>"},{"location":"DSAyy/trees/#how_29","title":"How","text":"<p>Just do a normal BFS (level order) from top to bottom. But store each level's value in a list then prepend it to a <code>deque</code>.  1. Record current level, and push it to the front of the <code>deque</code>. 2. Now it will have from bottom to top coz we pushed to the front. <pre><code>from collections import deque\nclass TreeNode:\n    def __init__(self,val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef reverseLevel(root):\n    res = []\n    if not root: return res\n    q = deque([root])\n    levels = deque()\n    while q:\n        sz = len(q)\n        level = []\n        for _ in range(sz):\n            node = q.popleft()\n            level.append(node.val)\n            if node.left: q.append(node.left)\n            if node.right: q.append(node.right)\n        levels.appendleft(level)\n    for lvl in levels: res.extend(lvl)\n    return res\n</code></pre></p>"},{"location":"DSAyy/trees/#zigzag-level-order","title":"Zigzag Level Order","text":"<p>Given <code>root</code> of binary tree, return nodes in zigzag level order. - level 0, L to R - level 1, R to L basically alternating direction every level</p> <p>just reverse the even level bro i dont even know</p> <pre><code>from collections import deque\nclass TreeNode:\n    def __init__(self,val=0,left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef zigzag(root):\n    res = []\n    if not root: return res\n    q = deque([root])\n    left_to_right = True\n    while q:\n        sz = len(q)\n        level = []\n        for _ in range(sz):\n            node = q.popleft()\n            level.append(node)\n            if  node.left: q.append(node.left)\n            if node.right: q.append(node.right)\n        if not left_to_right: level = reversed(level)\n        left_to_right = !left_to_right\n        res.extend(level)\n    return res\n</code></pre>"},{"location":"DSAyy/trees/#populate-next-right-pointers-in-a-binary-tree","title":"Populate Next Right Pointers in a Binary Tree","text":"<p>Given the root pointer of a binary tree. The struct also has a next pointer. Populate each node's <code>next</code> pointer so that ir points to the node immediately to its right on the same level. If there is no such node, let <code>next</code> be null.</p> <pre><code>class TreeLinkNode:\n    def __init__(self, val = 0, left = None, right = None, next =None):\n        self.val = val\n        self.left= left\n        self.right = right\n        self.next = next\ndef connect(root):\n    head = root #head of current level\n    while head:\n        dummy = TreeLinkNode(0)\n        tail = dummy\n        curr = head\n\n        while cur:\n            if cur.left:\n                tail.next = cur.left\n                tail = tail.next\n            if cur.right:\n                tail.next = cur.right\n                tail = tail.next\n            cur = cur.next\n        head = dummy.next\n</code></pre>"},{"location":"DSAyy/trees/#burn-a-tree","title":"Burn a Tree","text":"<p>Given <code>root</code> of a binary tree A, and a target leaf <code>B</code>, a fire starts at node B at time = 0. Each second, the fire spreads from any burning node to its directly connected neighbors (left child, right child and parent). Compute minimum time required to burn the entire tree.</p>"},{"location":"DSAyy/trees/#how_30","title":"How","text":"<p>Run BFS, and treat the tree like an undirected graph. In BFS, also pass the time, and then check the min time.</p> <pre><code>from collections import deque, defaultdict\nclass TreeNode:\n    def __init__(self, val = 0, left = None, right = None):\n        self.val = val\n        self.left= left\n        self.right = right\ndef build_parent_map(root,parent_map):\n    queue = deque([root])\n    while queue:\n        node = queue.popleft()\n        if node.left:\n            parent_map[node.left] = node\n            queue.append(node.left)\n        if node.right:\n            parent_map[node.right] = node\n            queue.append(node.right)\ndef find_target_node(root, target):\n    if not root: return None\n    if root.val == target: return root\n    left = find_target_node(root.left, target)\n    if left: return left\n    return find_target_node(root.right, target)\ndef burn_tree(root, target_val):\n    if not root: return 0\n    parent_map = {}\n    build_parent_map(root,parent_map)\n    target_node = find_target_node(root,target_val)\n    visited = set()\n    queue = deque([target_node])\n    visited.add(target_node)\n    time = -1 #first level at t = 0\n    while queue:\n        sz = len(queue)\n        for _ in range(sz):\n            node = queue.popleft()\n            for neighbor in [node.left, node.right, parent_map.get(node)]:\n                if neighbor and neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)  \n        time += 1\n    return time\n</code></pre>"},{"location":"DSAyy/trees/#max-depth-of-a-binary-tree","title":"Max Depth of a Binary Tree","text":"<p>Given the <code>root</code> pointer of a binary tree, find its maximum depth. <pre><code>from collections import deque\nclass TreeNode:\n    def __init__(self, val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right= right\ndef maxDepth(root):\n    if not root: return 0\n    q = deque([root])\n    depth = 0\n    while q:\n        sz = len(q)\n        depth ++\n        for _ in range(sz):\n            node = q.popleft()\n            if node.left: q.append(node.left)\n            if node.right: q.append(node.right)\n    return depth\n</code></pre></p>"},{"location":"DSAyy/trees/#sum-root-to-leaf-numbers","title":"Sum Root to Leaf Numbers","text":"<p>Given <code>root</code> to a binary tree whose node contain 0-9, each root to leaf path represents a number concatenating the digits along the way. Return sum of all sum numbers modulo 1003.</p> <pre><code>class TreeNode:\n    def __init__(self,val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef sum_root_to_leaf_numbers(root):\n    if not root: return 0\n    MOD = 1003\n    result = 0\n    stack = [(root,root.val % MOD)] #(node, cur_sum modulo)\n    while stack:\n        node, curr = stack.pop()\n        if not node.left and not node.right:\n            result = (result + curr) % MOD\n        if node.right:\n            next_val = (curr*10 + node.right.val) % MOD\n            stack.append((node.right, next_val))\n        if node.left:\n            next_val = (curr*10 + node.left.val) % MOD\n            stack.append((node.left, next_val))\n    return result\n</code></pre>"},{"location":"DSAyy/trees/#path-sum","title":"Path Sum","text":"<p>Given <code>root</code> of a binary tree, and an int <code>B</code>, determine whether there exists a root-to-leaf path in A such that sum of node values along that path equals B.</p> <p>Just DFS and pass cur sum bro</p> <pre><code>class TreeNode:\n    def __init__(self, val = 0, left=  None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef has_path_sum(root, target_sum):\n    if not root: return 0\n    stack = [(root, root.val)] #(node, cur sum)\n    while stack:\n        node, cur_sum = stack.pop()\n        if not node.left and not node.right:\n            if cur_sum == target_sum: return 1\n        if node.right:\n            stack.append((node.right, cur_sum + node.right.val))\n        if node.left:\n            stack.append((node.left, cur_sum + node.left.val))\n    return 0\n</code></pre>"},{"location":"DSAyy/trees/#min-depth-of-a-binary-tree","title":"Min Depth of a Binary Tree","text":"<p>Given the <code>root</code> of a binary tree. Find its minimum depth. Basically min root-to-leaf path.</p> <pre><code>from collections import deque\nclass TreeNode:\n    def __init__(self,val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef min_depth(root):\n    if not root: return 0\n    queue= deque([(root,1)]) #(node, curr depth)\n    while queue:\n        node, depth = queue.popleft()\n        if not node.left and not node.right: #return the earliest you reach leaf\n            return depth\n        if node.left: \n            queue.append((node.left, depth + 1))\n        if node.right:\n            queue.append((node.right, depth + 1))\n    return 0    \n</code></pre>"},{"location":"DSAyy/trees/#root-to-leaf-paths-with-sum","title":"Root to leaf paths with sum","text":"<p>Given <code>root</code> of a binary tree, and an int <code>B</code>. Find all root-to-leaf paths such that the sum of the node values along each path equals <code>B</code>. Return a list of these.</p> <pre><code>class TreeNode:\n    def __init__(self, val = 0, left =None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef find_paths_with_sum(root, target_sum):\n    res = []\n    if not root: return res\n    stack = [(root, root.val, [root.val])] #(node, cur sum, path list)\n    while stack:\n        node, curr_sum, path = stack.pop()\n        if node.left is None and node.right is None:\n            if curr_sum == target_sum:\n                res.append(path)\n        if node.right:\n            new_path = path + [node.right.val]\n            stack.append((node.right, curr_sum + node.right.val, new_path))\n        if node.left:\n            new_path = path + [node.left.val]\n            stack.append((node.left, curr_sum + node.left.val, new_path))\n    return res\n</code></pre>"},{"location":"DSAyy/trees/#invert-binary-tree","title":"Invert Binary Tree","text":"<p>Given <code>root</code> of binary tree, invert the binary tree in place, and return the root of inverted tree. Basically mirror image kar diya.</p> <p>Left becomes right and right becomes left.</p> <pre><code>class TreeNode:\n    def __init__(self,val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef invert_binary_tree(root):\n    if not root: return None\n    stack = [root]\n    while stack:\n        node = stack.pop()\n        node.left, node.right = node.right, node.left\n        if node.left:\n            stack.append(node.left)\n        if node.right:\n            stack.append(node.right)\n    return root\n</code></pre>"},{"location":"DSAyy/trees/#least-common-ancestor-in-a-binary-tree","title":"Least Common Ancestor in a Binary Tree","text":"<p>Given <code>root</code> of an unordered binary tree, and two int <code>B</code> and <code>C</code>. Find value of LCA of nodes with value <code>B</code> and <code>C</code>. LCA is like deepest node with common descendents.</p>"},{"location":"DSAyy/trees/#how_31","title":"How","text":"<ol> <li>Locate each node and record its parent.<ul> <li>BFS from root.</li> <li>Do the parent mapping.</li> <li>store the <code>nodeB</code> and <code>nodeC</code> when you come across it.</li> <li>do untill both nodeB and nodeC are not found.</li> </ul> </li> <li>Build the ancestor chain for one node, then walk up from other.<ul> <li>Visit the ancestor chain of <code>nodeB</code>. Then check nodeC for the deepest ancestor already visited in <code>nodeB</code>'s chain. <pre><code>class TreeNode:\n    def __init__(self, val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right = right\ndef find_lca(root, B, C):\n    if not root: return -1\n    parent = {}\n    parent[root] = None\n    nodeB = nodeC = None\n\n    from collections import deque\n     q= deque([root])\n    while q: #fill the parent map and check if both nodes exist\n        node = q.popleft()\n        if node.val == B:\n            nodeB = node\n        if node.val == C:\n            nodeC = node\n        if node.left:\n            parent[node.left] = node\n            q.append(node.left)\n        if node.right:\n            parent[node.right] = node\n            q.append(node.right)\n    if not nodeB or not nodeC: return -1\n\n    ancestors = set() #find the common parent, from ancestor list\n    curr = nodeB\n    while curr:\n        ancestors.add(curr)\n        curr = parent[curr]\n    curr = nodeC\n    while curr:\n        if curr in ancestors: return curr.val\n        curr = parent[curr]\n    return -1\n</code></pre></li> </ul> </li> </ol>"},{"location":"DSAyy/trees/#flatten-binary-tree-to-linked-list","title":"Flatten Binary tree to Linked List","text":"<p>Given <code>root</code> of a binary tree. Flatten it into a linked list.  After flattening: 1. Every node's left child is <code>NULL</code> 2. Each node's right child points to the next node in preorder traversal of orignal tree. <pre><code>class TreeNode:\n    def __init__(self, val = 0, left = None, right = None):\n        self.val = val\n        self.left = left\n        self.right=  right\ndef flatten_binary_tree(root):\n    curr = root\n    while curr:\n        if curr.left is None:\n            curr = curr.right\n        else:\n            #find the rightmost node in left subtree\n            pred = curr.left\n            while pred.right:\n                pred = pred.right\n            #rewire the connections\n            pred.right = curr.right\n            curr.right = curr.left\n            curr.left = None\n            curr = curr.right\n    return root\n</code></pre></p>"},{"location":"DSAyy/trees/#order-of-peoples-heights","title":"Order of People's Heights","text":"<p>Given pos int <code>N</code>. arr <code>Heights</code> of len <code>N</code>, containing distinct heights of N people standing in a queue.</p> <p>arr <code>infront</code> of len <code>N</code>, where <code>InFronts[i]</code> is the number of people taller than the i-th person, who must stand infront of them.</p> <p>Return arr of len <code>N</code>, which is the actual ordering of heights from front to back that satisfies all the <code>infront</code> constraints.</p>"},{"location":"DSAyy/trees/#how_32","title":"How","text":"<p>Sort all people by asc height. When inserting shortest to tallest, every unpplaced person is strictly taller than the current one. Hence, if a person of height <code>h</code> has infronts  = <code>k</code>, we need to place them at (<code>k+1</code>)th empty slot, among the remaining positions.</p> <p>To find k-th empty slot, and mark a slot as occupied, we can use a segment tree. Each leaf holds 1 if that is position is still free, Internal nodes store the sum of their children (count of free slots in that sub range)</p> <ol> <li>sort in asc (height, infont), by height</li> <li>build seg tree <code>[1..N]</code> init all leaf as 1 (all slots are free)</li> <li>for each pair (h,k) in sorted order:<ul> <li>Query the segment tree to find the index of (k+1)th free slot.</li> <li>place height at \\(answer[pos - 1]\\) = h</li> <li>update the segtree at leaf pos to 0.</li> </ul> </li> <li>Return the filled answer.</li> </ol> <pre><code>class SegmentTree:\n    def __init__(self, size):\n        self.size = size\n        self.tree = [0]*(4 * size)\n    def build(self, node, l ,r):\n        if l == r:\n            self.tree[node] = 1\n            return\n        m = (l+r)//2\n        self.build(node * 2,  l ,m)\n        self.build(node*2 + 1, m+1, r)\n        self.tree[node] = self.tree[node * 2] + self.tree[node * 2 + 1]\n    def update(self, node, l ,r, pos):\n        if l == r:\n            self.tree[node] = 0\n            return\n        m = (l+r)//2\n        if pos &lt;= m:\n            self.update(node*2, l,m,pos)\n        else:\n            self.update(node*2 + 1, m + 1, r, pos)\n        self.tree[node] = self.tree[node*2] + self.tree[node*2 + 1]\n    def kth_free(self,node,l,r,k):\n        if l == r:\n            return l\n        m = (l + r) // 2\n        left_count = self.tree[node* 2]\n        if k &lt;= left_count:\n            return self.kth_free(node*2, l,m,k)\n        else:\n            return self.kth_free(node*2 + 1, m+1, r, k- left_count)\ndef reconstruct_queue(heights, in_fronts):\n    n = len(height)\n    people = [(heights[i], in_fronts[i]) for i in range(n)]\n    people.sort(key = lambda x: (x[0], x[1]))\n    seg = SegmentTree(n)\n    seg.build(1,1,n)\n    answer = [0]*n\n    for h, inf in people:\n        k = inf + 1\n        pos = sef.kth_free(1,1,n,k)\n        answer[pos - 1] = h\n        seg.update(1,1,n,pos)\n    return answer\n</code></pre>"}]}